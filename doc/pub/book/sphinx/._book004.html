
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ODE models</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Scaling of Differential Equations" href="index.html" />
    <link rel="next" title="Vibration problems" href="._book005.html" />
    <link rel="prev" title="Dimensions and units" href="._book003.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book005.html" title="Vibration problems"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book003.html" title="Dimensions and units"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Scaling of Differential Equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="ode-models">
<h1>ODE models<a class="headerlink" href="#ode-models" title="Permalink to this headline">¶</a></h1>
<p>This chapter introduces the basic techniques of scaling and the ways to
reason about scales. The first class of examples targets exponential
decay models, starting with the simple ordinary differential equation (ODE)
for exponential decay processes: <span class="math">\(u^{\prime}=-au\)</span>, with constant <span class="math">\(a&gt;0\)</span>.
Then we progress to various generalizations of this ODE, including nonlinear
versions and systems of ODEs. The next class of examples concerns
second-order ODEs for oscillatory systems, where the simplest
ODE reads <span class="math">\(mu^{\prime\prime} + ku=0\)</span>, with <span class="math">\(m\)</span> and <span class="math">\(k\)</span> as positive constants.
Various extensions with damping and force terms are discussed in detail.</p>
<div class="section" id="exponential-decay-problems">
<span id="sec-scale-decay"></span><h2>Exponential decay problems<a class="headerlink" href="#exponential-decay-problems" title="Permalink to this headline">¶</a></h2>
<div class="section" id="fundamental-ideas">
<h3>Fundamental ideas<a class="headerlink" href="#fundamental-ideas" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-0"></span><p id="index-1">Scaling is an extremely useful technique in mathematical modeling and
numerical simulation.  The purpose of the technique is three-fold:</p>
<ol class="arabic simple">
<li>Make independent and dependent variables dimensionless.</li>
<li>Make the size of independent and dependent variables about unity.</li>
<li>Reduce the number of independent physical parameters in the model.</li>
</ol>
<p id="index-2">The first and second item mean that for any variable, denote it by
<span class="math">\(q\)</span>, we introduce a corresponding dimensionless variable</p>
<div class="math">
\[\bar q = \frac{q-q_0}{q_c},\]</div>
<p>where <span class="math">\(q_0\)</span> is a reference value of <span class="math">\(q\)</span> (<span class="math">\(q_0=0\)</span> is a common choice) and
<span class="math">\(q_c\)</span> is a characteristic size of <span class="math">\(|q|\)</span>. Since the numerator and denominator
have the same dimension, <span class="math">\(\bar q\)</span> becomes a dimensionless number.</p>
<p>If <span class="math">\(q_c\)</span> is the maximum value of <span class="math">\(|q-q_0|\)</span>, we see that <span class="math">\(0 &lt; |\bar
q|\leq 1\)</span>. How to find <span class="math">\(q_c\)</span> is sometimes the big challenging of
scaling. Examples will illustrate various approaches to meet this
challenge.</p>
<p>The forthcoming text has the following goals.</p>
<blockquote>
<div><ul class="simple">
<li>Teach the technical steps of making a mathematical model, based
on differential equations, dimensionless.</li>
<li>Describe various techniques for reasoning about the scales, i.e.,
finding the characteristic sizes of quantities.</li>
<li>Teach how to identify and interpret dimensionless numbers arising
from the scaling process.</li>
<li>Provide a lot of different examples on making models dimensionless
with physically correct scales.</li>
<li>Demonstrate software tools for computing with numbers with units,
including doing unit conversions.</li>
<li>Introduce software tools for creating user interfaces that
can automatically perform unit conversion.</li>
<li>Use symbolic software (SymPy) to derive exact solutions of differential
equations.</li>
<li>Explain how to run a dimensionless model with software developed
for the problem with dimensions.</li>
</ul>
</div></blockquote>
<div class="admonition-limited-scope admonition">
<p class="first admonition-title">Limited scope</p>
<p class="last">Literature covering scaling and non-dimensionalization often also discuss
topics such as deriving functional relationships based on dimensional
reasoning, as well as dynamic similarity and use of dimensionless groups in
experimental investigations <a class="reference internal" href="._book010.html#ref3" id="id1">[Ref3]</a> <a class="reference internal" href="._book010.html#ref4" id="id2">[Ref4]</a>.
These topics are not covered herein, because our focus is strictly
on making models based on differential equations dimensionless.</p>
</div>
</div>
<div class="section" id="the-basic-model-problem">
<h3>The basic model problem<a class="headerlink" href="#the-basic-model-problem" title="Permalink to this headline">¶</a></h3>
<p id="index-3">Processes undergoing exponential reduction can be modeled by the ODE
problem</p>
<div class="math" id="equation-scale:decay:model">
<span id="eq-scale-decay-model"></span><span class="eqno">(1)</span>\[     u'(t) = -au(t),\quad u(0)=I,
     \\]</div>
<p>where <span class="math">\(a,I&gt;0\)</span> are prescribed constants and <span class="math">\(u(t)\)</span> is the unknown function.
For this particular model, we can easily derive the solution, <span class="math">\(u(t)=Ie^{-at}\)</span>,
which is helpful to have in mind during the scaling process.</p>
<div class="section" id="example-population-dynamics">
<h4>Example: Population dynamics<a class="headerlink" href="#example-population-dynamics" title="Permalink to this headline">¶</a></h4>
<p>The evolution of a population of humans, animals, cells, etc.,
under unlimited access to resources, can be
modeled by <a href="#equation-scale:decay:model">(1)</a>. Then <span class="math">\(u\)</span> is the number of
individuals in the population, strictly speaking an integer, but well
modeled by a real number in large populations.
The parameter <span class="math">\(a\)</span> is the increase in the number of individuals per
time and per individual.</p>
</div>
<div class="section" id="example-decay-of-pressure-with-altitude">
<h4>Example: Decay of pressure with altitude<a class="headerlink" href="#example-decay-of-pressure-with-altitude" title="Permalink to this headline">¶</a></h4>
<p>The simple model <a href="#equation-scale:decay:model">(1)</a> also governs the pressure
in the atmosphere (under many assumptions). In this case <span class="math">\(u\)</span> is the
pressure, measured in <span class="math">\(\hbox{Nm}^{-2}\)</span>; <span class="math">\(t\)</span> is the hight in meters;
and <span class="math">\(a=M/(R^*T)\)</span>, where
<span class="math">\(M\)</span> is the molar mass of the Earth&#8217;s air (0.029 kg/mol),
<span class="math">\(R^*\)</span> is the universal
gas constant (<span class="math">\(8.314\,\frac{\hbox{Nm}}{\hbox{mol\, K}}\)</span>),
and <span class="math">\(T\)</span> is the temperature in Kelvin (K).
The temperature depends on the hight so we have <span class="math">\(a=a(t)\)</span>.</p>
</div>
</div>
<div class="section" id="the-technical-steps-of-the-scaling-procedure">
<span id="sec-scale-decay-steps"></span><h3>The technical steps of the scaling procedure<a class="headerlink" href="#the-technical-steps-of-the-scaling-procedure" title="Permalink to this headline">¶</a></h3>
<div class="section" id="step-1-identify-independent-and-dependent-variables">
<h4>Step 1: Identify independent and dependent variables<a class="headerlink" href="#step-1-identify-independent-and-dependent-variables" title="Permalink to this headline">¶</a></h4>
<p>There is one independent variable, time <span class="math">\(t\)</span>, and one dependent variable,
<span class="math">\(u\)</span>.</p>
<span class="target" id="index-4"></span></div>
<div class="section" id="step-2-make-independent-and-dependent-variables-dimensionless">
<span id="index-5"></span><h4>Step 2: Make independent and dependent variables dimensionless<a class="headerlink" href="#step-2-make-independent-and-dependent-variables-dimensionless" title="Permalink to this headline">¶</a></h4>
<p>We introduce a new dimensionless <span class="math">\(t\)</span>, called <span class="math">\(\bar t\)</span>, defined by</p>
<div class="math">
\[\bar t = \frac{t}{t_c},\]</div>
<p>where <span class="math">\(t_c\)</span> is a <em>characteristic value</em> of <span class="math">\(t\)</span>. Similarly,
we introduce a dimensionless <span class="math">\(u\)</span>, named <span class="math">\(\bar u\)</span>, according to</p>
<div class="math">
\[\bar u = \frac{u}{u_c},\]</div>
<p>where <span class="math">\(u_c\)</span> is a constant <em>characteristic size</em> of <span class="math">\(u\)</span>. When <span class="math">\(u\)</span> has a specific
interpretation, say when <a href="#equation-scale:decay:model">(1)</a> models pressure
in an atmospheric layer, <span class="math">\(u_c\)</span> would be referred to as characteristic pressure.
For a decaying population, <span class="math">\(u\)</span> may be a characteristic number of
members in the population.</p>
</div>
<div class="section" id="step-3-derive-the-model-involving-only-dimensionless-variables">
<h4>Step 3: Derive the model involving only dimensionless variables<a class="headerlink" href="#step-3-derive-the-model-involving-only-dimensionless-variables" title="Permalink to this headline">¶</a></h4>
<p>The next task is to insert the new dimensionless variables in the
governing mathematical model. That is, we replace <span class="math">\(t\)</span> by <span class="math">\(t_c\bar t\)</span>
and <span class="math">\(u\)</span> by <span class="math">\(u_c\bar u\)</span> in <a href="#equation-scale:decay:model">(1)</a>. The derivative
with respect to <span class="math">\(\bar t\)</span> is derived as</p>
<div class="math">
\[\frac{du}{dt} = \frac{d (u_c\bar u)}{d\bar t}{d\bar t}{dt}
= u_c\frac{d\bar u}{d\bar t}\frac{1}{t_c} =
\frac{u_c}{t_c}\frac{d\bar u}{d\bar t}{\thinspace .}\]</div>
<p>The model <a href="#equation-scale:decay:model">(1)</a> now becomes</p>
<div class="math" id="equation-scale:decay:model:scaled0">
<span id="eq-scale-decay-model-scaled0"></span><span class="eqno">(2)</span>\[     \frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = -au_c\bar u,\quad u_c\bar u(0)=I{\thinspace .}\]</div>
</div>
<div class="section" id="step-4-make-each-term-dimensionless">
<h4>Step 4: Make each term dimensionless<a class="headerlink" href="#step-4-make-each-term-dimensionless" title="Permalink to this headline">¶</a></h4>
<p>Equation <a href="#equation-scale:decay:model:scaled0">(2)</a> still has terms with
dimensions. To make each term dimensionless, we usually divide by
the coefficient in front of the term with the highest time derivative
(but dividing by any coefficient will do). The result is</p>
<div class="math" id="equation-scale:decay:model:dimless0">
<span id="eq-scale-decay-model-dimless0"></span><span class="eqno">(3)</span>\[     \frac{d\bar u}{d\bar t} = -at_c\bar u,\quad \bar u(0)=u_c^{-1}I
     {\thinspace .}
     \\]</div>
</div>
<div class="section" id="step-5-estimate-the-scales">
<h4>Step 5: Estimate the scales<a class="headerlink" href="#step-5-estimate-the-scales" title="Permalink to this headline">¶</a></h4>
<p>A characteristic quantity like <span class="math">\(t_c\)</span> reflects the time scale in the
problem. Estimating such a time scale is certainly
the most challenging part of the scaling procedure. There are different
ways to reason. The first is to aim at a size of <span class="math">\(\bar u\)</span> and its derivatives
that is of order unity. If <span class="math">\(u_c\)</span> is chosen such that <span class="math">\(|\bar u|\)</span> is
of size unity, we see from <a href="#equation-scale:decay:model:dimless0">(3)</a> that
<span class="math">\(d\bar u/d\bar t\)</span> is of the size of <span class="math">\(\bar u\)</span> (i.e., unity)
if we choose <span class="math">\(t_c = 1/a\)</span>.</p>
<p id="index-6">Alternatively, we may look at a special case of the model where we have
analytical insight. In the present problem we are lucky to know the
exact solution for any value of the input data. For exponential
decay, <span class="math">\(u(t)\sim e^{-at}\)</span>, it is common to define a characteristic time
scale <span class="math">\(t_c\)</span> as the time it takes to reduce <span class="math">\(u\)</span> by a factor of <span class="math">\(1/e\)</span> (also
called the <em>e-folding time</em>):</p>
<div class="math">
\[e^{-at_c} = \frac{1}{e}e^{-a\cdot 0}\quad\Rightarrow\quad e^{-at_c}=e^{-1},\]</div>
<p>from which it follows that <span class="math">\(t_c = 1/a\)</span>.</p>
<p>In this example, two different, yet common ways of reasoning, lead to the
same value of <span class="math">\(t_c\)</span>. However, instead of using the e-folding time we
could use the half-time of the exponential decay as characteristic
time, which is also a very common measure of the time scale in such
processes. The half time is defined as the time it takes to halve <span class="math">\(u\)</span>:</p>
<div class="math">
\[e^{-at_c} = \frac{1}{2}e^{-a\cdot 0}
\quad\Rightarrow\quad t_c = a^{-1}\ln 2{\thinspace .}\]</div>
<p>There is a factor <span class="math">\(\ln 2 =0.69\)</span> difference from the other <span class="math">\(t_c\)</span> value.
As long as the factor is not an order of magnitude or more different,
we do not pay attention to such small differences.
Although <span class="math">\(t_c = a^{-1}\ln 2\)</span> is a fine time scale to be used in this
problem, it leads to a scaled differential equation <span class="math">\(u'=-(\ln 2) u\)</span>,
which is fine, but an unusual form. People tend to prefer <span class="math">\(u'=-u\)</span>,
which arises from <span class="math">\(t_c=1/a\)</span>. We shall therefore use the latter as
time scale.</p>
<p>Regarding <span class="math">\(u_c\)</span>, we may look at the initial condition
and realize that the choice <span class="math">\(u_c=I\)</span> makes <span class="math">\(\bar u(0)=1\)</span>. For <span class="math">\(\bar t&gt;0\)</span>
we know that <span class="math">\(\bar u\)</span> is decreasing, so <span class="math">\(u_c=I\)</span>
gives us <span class="math">\(\bar u\leq 1\)</span>, which is always a goal.
Alternatively, we may look to analytical insight, <span class="math">\(u(t)=Ie^{-at}\)</span>, to
see that <span class="math">\(u\leq I\)</span>, such that <span class="math">\(u_c=I\)</span> gives <span class="math">\(\bar u\leq 1\)</span>.</p>
<p>With <span class="math">\(t_c=1/a\)</span> and <span class="math">\(u_c=I\)</span>, we have the final dimensionless model</p>
<div class="math" id="equation-scale:decay:model:dimless">
<span id="eq-scale-decay-model-dimless"></span><span class="eqno">(4)</span>\[     \frac{d\bar u}{d\bar t} = -\bar u,\quad \bar u(0)=1
     {\thinspace .}
     \\]</div>
<p>This is a remarkable result in the sense that <em>all physical parameters</em>
(<span class="math">\(a\)</span> and <span class="math">\(I\)</span>)
are removed from the model! Or more precisely, there are no physical input
parameters to assign
before using the model. In particular, numerical investigations of the original
model <a href="#equation-scale:decay:model">(1)</a> would need experiments with different
<span class="math">\(a\)</span> and <span class="math">\(I\)</span> values, while numerical investigations of
<a href="#equation-scale:decay:model:dimless">(4)</a> can be limited to <em>a single run</em>! As soon
as we have computed the curve <span class="math">\(\bar u(\bar t)\)</span>, we can find the
solution <span class="math">\(u(t)\)</span> of <a href="#equation-scale:decay:model">(1)</a> by</p>
<div class="math" id="equation-scale:decay:u:dim">
<span id="eq-scale-decay-u-dim"></span><span class="eqno">(5)</span>\[     u(t) = u_c\bar u(t/t_c) = I\bar u(at)
     {\thinspace .}\]</div>
<p>This particular transformation actually means stretching the <span class="math">\(\bar t\)</span> and
<span class="math">\(\bar u\)</span> axes in a plot of <span class="math">\(\bar u(\bar t)\)</span> by the factors <span class="math">\(a\)</span> and <span class="math">\(I\)</span>,
respectively.</p>
<p>It is very common to drop the bars when the scaled problem has been
derived and work further with <a href="#equation-scale:decay:model:dimless">(4)</a> simply
written as</p>
<div class="math">
\[\frac{du}{dt} = -u,\quad u(0)=1
{\thinspace .}\]</div>
</div>
</div>
<div class="section" id="making-software-utilizing-the-dimensionless-model">
<span id="sec-scale-decay-prog"></span><h3>Making software utilizing the dimensionless model<a class="headerlink" href="#making-software-utilizing-the-dimensionless-model" title="Permalink to this headline">¶</a></h3>
<p>Software for solving <a href="#equation-scale:decay:model">(1)</a> could take advantage
of the fact that only one simulation of <a href="#equation-scale:decay:model:dimless">(4)</a>
is necessary. As soon as we have <span class="math">\(\bar u(\bar t)\)</span> accessible,
a simple scaling <a href="#equation-scale:decay:u:dim">(5)</a> computes the real <span class="math">\(u(t)\)</span>
for any given input data <span class="math">\(a\)</span> and <span class="math">\(I\)</span>. Although the numerical computation of
<span class="math">\(u(t)\)</span> from <a href="#equation-scale:decay:model">(1)</a> is very fast in this simple model
problem, using <a href="#equation-scale:decay:u:dim">(5)</a> is very much faster than
computing a full numerical solution in more complicated
differential equation problems.</p>
<p>We can compute with the dimensionless model <a href="#equation-scale:decay:model:dimless">(4)</a>
in two ways, either make a solver for <a href="#equation-scale:decay:model:dimless">(4)</a>
or reuse a solver for <a href="#equation-scale:decay:model">(1)</a> with the parameters
appropriately set (<span class="math">\(I=1\)</span>, <span class="math">\(a=1\)</span>).
The latter approach has the advantage of giving us
software that works both with a dimensionless model and a model
with dimensions and all the original physical parameters.</p>
<div class="section" id="software-for-the-original-problem-with-dimensions">
<h4>Software for the original problem with dimensions<a class="headerlink" href="#software-for-the-original-problem-with-dimensions" title="Permalink to this headline">¶</a></h4>
<p>We base our solver for
<a href="#equation-scale:decay:model:dimless">(4)</a> on a solver for <a href="#equation-scale:decay:model">(1)</a>.
Assume that we have some module <code class="docutils literal"><span class="pre">decay.py</span></code> that offers the following
functions:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">solver(I,</span> <span class="pre">a,</span> <span class="pre">T,</span> <span class="pre">dt,</span> <span class="pre">theta=0.5)</span></code> for returning the solution arrays
<code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">t</span></code> for <a href="#equation-scale:decay:model">(1)</a> solved by the <span class="math">\(\theta\)</span> rule.</li>
<li><code class="docutils literal"><span class="pre">read_command_line_argparse()</span></code> for reading parameters in the problem
from the command line and returning them: <code class="docutils literal"><span class="pre">I</span></code>, <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">T</span></code>, <code class="docutils literal"><span class="pre">theta</span></code> (<span class="math">\(\theta\)</span>),
and a list of <span class="math">\(\Delta t\)</span> values for time steps. (We shall only make
use of the first <span class="math">\(\Delta t\)</span> value.)</li>
</ul>
</div></blockquote>
<p>The basic statements for solving <a href="#equation-scale:decay:model">(1)</a> are
then</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">decay</span> <span class="kn">import</span> <span class="n">solver</span><span class="p">,</span> <span class="n">read_command_line_argparse</span>
<span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line_argparse</span><span class="p">()</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">plot</span><span class="p">,</span> <span class="n">show</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The module <a class="reference external" href="http://tinyurl.com/ofkw6kc/softeng/decay.py">decay.py</a> is developed
and explained in</p>
<p>Section refaux{softeng1:basic:module} in
the book <a class="reference external" href="http://tinyurl.com/nclmcng/doc/pub/book">Finite Difference Computing with Exponential Decay Models</a> <a class="reference internal" href="._book010.html#ref5" id="id3">[Ref5]</a>.</p>
<p>To solve the dimensionless problem, just fix <span class="math">\(I=1\)</span> and <span class="math">\(a=1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line_argparse</span><span class="p">()</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="a-plain-solution">
<h4>A plain solution<a class="headerlink" href="#a-plain-solution" title="Permalink to this headline">¶</a></h4>
<p>A key observation, as mentioned, is that we need to solve the problem
<a href="#equation-scale:decay:model:dimless">(4)</a> only once. All solutions
corresponding to different <span class="math">\(I\)</span> and <span class="math">\(a\)</span> values in the original physical
problem can be recovered by scaling this single solution with formula
<a href="#equation-scale:decay:u:dim">(5)</a>.  We therefore want to make software that
takes advantage of this fact. When requesting a solution, we see if it
has already been computed and stored in a file, and if so, the data
can be retrieved from file, otherwise we have to compute a new
solution and store it in a file.</p>
<p>The computational recipe goes as follows.</p>
<ol class="arabic simple">
<li>A computed solution <span class="math">\(\bar u(\bar t)\)</span> is stored in a file with name <code class="docutils literal"><span class="pre">u_scaled.dat</span></code>.</li>
<li>The first line in the file contains <span class="math">\(T\)</span>, <span class="math">\(\Delta t\)</span>, and <span class="math">\(\theta\)</span>
used to compute the stored <span class="math">\(\bar u(\bar t)\)</span>.</li>
<li>The <span class="math">\(T\)</span>, <span class="math">\(\Delta t\)</span>, and <span class="math">\(\theta\)</span> parameters are read from the
first line in the file and compared with those required by the user.</li>
<li>If one of the three parameters changes, the solution in the file
must be recomputed.</li>
</ol>
<p>The actual code may look as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">decay</span> <span class="kn">import</span> <span class="n">solver</span> <span class="k">as</span> <span class="n">solver_unscaled</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">solver_scaled</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-u, u(0)=1 for (0,T] with step dt and theta method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Is the scaled problem already solved and dimensionless</span>
    <span class="c"># curve available from file?</span>
    <span class="c"># See if u_scaled.dat has the right parameters.</span>
    <span class="n">already_computed</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">datafile</span> <span class="o">=</span> <span class="s">&#39;u_scaled.dat&#39;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">datafile</span><span class="p">):</span>      <span class="c"># does u_scaled.dat exist?</span>
        <span class="n">infile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">infoline</span> <span class="o">=</span> <span class="n">infile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>  <span class="c"># read the first line</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">infoline</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>      <span class="c"># split line into words</span>
        <span class="n">T_</span><span class="p">,</span> <span class="n">dt_</span><span class="p">,</span> <span class="n">theta_</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">T_</span> <span class="o">==</span> <span class="n">T</span> <span class="ow">and</span> <span class="n">dt_</span> <span class="o">==</span> <span class="n">dt</span> <span class="ow">and</span> <span class="n">theta_</span> <span class="o">==</span> <span class="n">theta</span><span class="p">:</span>
            <span class="c"># The file was computed with the desired data, load</span>
            <span class="c"># the solution into arrays</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>
            <span class="n">u_scaled</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span>
            <span class="n">t_scaled</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
            <span class="k">print</span> <span class="s">&#39;Read scaled solution from file&#39;</span>
            <span class="n">already_computed</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">infile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">already_computed</span><span class="p">:</span>
        <span class="c"># T, dt or theta is different from u_scaled.dat</span>
        <span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span> <span class="o">=</span> \
           <span class="n">solver_unscaled</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%f</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="si">%.1f</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">t_scaled</span><span class="p">,</span> <span class="n">u_scaled</span><span class="p">]))</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">print</span> <span class="s">&#39;Computed scaled solution&#39;</span>
    <span class="k">return</span> <span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span>

<span class="k">def</span> <span class="nf">unscale</span><span class="p">(</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">t_scaled</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">np.savetxt</span></code> function saves a two-dimensional arrays (&#8220;table&#8221;) to
a text file, and the <code class="docutils literal"><span class="pre">np.loadtxt</span></code> function can load the data back
into the program.</p>
</div>
<div class="section" id="simplifying-the-implementation-with-joblib">
<span id="index-7"></span><h4>Simplifying the implementation with joblib<a class="headerlink" href="#simplifying-the-implementation-with-joblib" title="Permalink to this headline">¶</a></h4>
<p>The Python package <code class="docutils literal"><span class="pre">joblib</span></code> has functionality that is very convenient
for implementing the <code class="docutils literal"><span class="pre">solver_scaled</span></code> function. The first time a
function is called with a set of arguments, the statements in the
function are executed and the return value is saved to file. If the
function is called again with the same set of arguments, the
statements in the function are not executed, but the return value is
read from file. In computer science, one would say that <code class="docutils literal"><span class="pre">joblib</span></code> in
this way provides <em>memorization</em> functionality for Python functions.
This functionality is particularly aimed at large-scale computations
with arrays that one would like to avoid being recomputed.</p>
<p>Utilizing <code class="docutils literal"><span class="pre">joblib</span></code>, our <code class="docutils literal"><span class="pre">solver_scaled</span></code> function can be dramatically
simplified:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver_scaled</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-u, u(0)=1 for (0,T] with step dt and theta method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s">&#39;Computing the numerical solution&#39;</span>
    <span class="k">return</span> <span class="n">solver_unscaled</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we create some &#8220;computer memory on disk&#8221;, i.e., some disk space to
store the result of a call to the <code class="docutils literal"><span class="pre">solver_scaled</span></code> function. Thereafter,
we redefine the name <code class="docutils literal"><span class="pre">solver_scaled</span></code> to a new function, created
by <code class="docutils literal"><span class="pre">joblib</span></code>, which calls our original <code class="docutils literal"><span class="pre">solver_scaled</span></code> function
if necessary and otherwise loads data from file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">joblib</span>
<span class="n">disk_memory</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">Memory</span><span class="p">(</span><span class="n">cachedir</span><span class="o">=</span><span class="s">&#39;temp&#39;</span><span class="p">)</span>
<span class="n">solver_scaled</span> <span class="o">=</span> <span class="n">disk_memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">solver_scaled</span><span class="p">)</span>
</pre></div>
</div>
<p>The solutions are actually stored in files in the directory <code class="docutils literal"><span class="pre">temp</span></code>.</p>
<p>A typical use case is to read values from the command line,
solve the unscaled problem (if necessary), scale the solution, and visualize
the solution with dimension:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c"># Read parameters, solve and plot</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line_argparse</span><span class="p">()</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># use only the first dt value</span>
    <span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span> <span class="o">=</span> <span class="n">solver_scaled</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">unscale</span><span class="p">(</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_scaled</span><span class="p">,</span> <span class="n">u_scaled</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;scaled time&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;scaled velocity&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Universial solution of scaled problem&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp1.png&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp1.pdf&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;I=</span><span class="si">%g</span><span class="s">, a=</span><span class="si">%g</span><span class="s">, theta=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp2.png&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp2.pdf&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The complete code resides in the file
<a class="reference external" href="http://tinyurl.com/nm5587k/scale/decay_scaled.py">decay_scaled.py</a>.</p>
<p>Note that we write a message <code class="docutils literal"><span class="pre">Computing</span> <span class="pre">the</span> <span class="pre">numerical</span> <span class="pre">solution</span></code> inside
the <code class="docutils literal"><span class="pre">solver_scaled</span></code> function. We can then easily detect when
the solution is actually computed and when it is simply read from file.
Here is a demo:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; # Very first run
Terminal&gt; python decay_scaled.py --T 7 --a 1 --I 0.5 --dt 0.2
[Memory] Calling __main__--home-hpl...
solver_scaled-alias(7.0, 0.2, 0.5)
Computing the numerical solution

Terminal&gt; # No change of T, dt, theta - can reuse solution in file
Terminal&gt; python decay_scaled.py --T 7 --a 4 --I 2.5 --dt 0.2

Terminal&gt; # Change of dt, must recompute
Terminal&gt; python decay_scaled.py --T 7 --a 4 --I 2.0 --dt 0.5
[Memory] Calling __main__--home-hpl...
solver_scaled-alias(7.0, 0.5, 0.5)
Computing the numerical solution

Terminal&gt; # Change of dt again, but dt=0.2 is already in a file
Terminal&gt; python decay_scaled.py --T 7 --a 0.5 --I 1 --dt 0.2
</pre></div>
</div>
<p>We realize that <code class="docutils literal"><span class="pre">joblib</span></code> has access to all previous runs and does not
recompute unless it is strictly required. Our previous implementation
without <code class="docutils literal"><span class="pre">joblib</span></code>
used only one file (for one numerical case)
and will therefore perform many more calls to
<code class="docutils literal"><span class="pre">solver_unscaled</span></code>.</p>
<p>A plot of the scaled and unscaled solution appears in Figure
<a class="reference internal" href="#sec-decay-fig-simplest"><span class="std std-ref">Scaled (left) and unscaled (right) exponential decay</span></a>.</p>
<div class="figure" id="id4">
<span id="sec-decay-fig-simplest"></span><a class="reference internal image-reference" href="_images/decay.png"><img alt="_images/decay.png" src="_images/decay.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Scaled (left) and unscaled (right) exponential decay</em></span></p>
</div>
<div class="admonition-on-the-implementation-of-a-simple-memoize-function admonition">
<p class="first admonition-title">On the implementation of a simple memoize function</p>
<p>A memoized function recalls
previous results when the same set
of arguments is encountered. That is, the function caches its results.
A simple implementation stores the arguments in a function call and
the returned results in a
dictionary, and if the arguments are seen again, one looks up
in the dictionary and return previously computed results:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Memoize</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># map arguments to results</span>

<span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">args</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">args</span><span class="p">]</span>

<span class="c"># Wrap my_compute_function(arg1, arg2, ...)</span>
<span class="n">my_compute_function</span> <span class="o">=</span> <span class="n">Memoize</span><span class="p">(</span><span class="n">my_compute_function</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">The memoize functionality in <code class="docutils literal"><span class="pre">joblib.Memory</span></code> is more sophisticated and
can work very efficiently with large array data structures as arguments.
Note that the simple version above can only be used when all arguments to
the function <code class="docutils literal"><span class="pre">f</span></code> are immutable (since the key in a dictionary has to be
immutable).</p>
</div>
</div>
</div>
<div class="section" id="scaling-a-generalized-problem">
<span id="sec-scale-decay-body"></span><h3>Scaling a generalized problem<a class="headerlink" href="#scaling-a-generalized-problem" title="Permalink to this headline">¶</a></h3>
<p>Now we consider an extension of the exponential decay ODE to the
form</p>
<div class="math" id="equation-scale:decay:model:g">
<span id="eq-scale-decay-model-g"></span><span class="eqno">(6)</span>\[     u'(t) = -au(t) + b,\quad u(0)=I\]\[     {\thinspace .}\]</div>
<p>One particular model, with constant <span class="math">\(a\)</span> and <span class="math">\(b\)</span>,
is a spherical micro-organism falling in air,</p>
<div class="math" id="equation-scale:decay:model:g:spec">
<span id="eq-scale-decay-model-g-spec"></span><span class="eqno">(7)</span>\[     u' = - \frac{3\pi d\mu}{\varrho_b V} u + g\left(\frac{\varrho}{\varrho_b} -1\right),\]</div>
<p>where <span class="math">\(d\)</span>, <span class="math">\(\mu\)</span>, <span class="math">\(\varrho_b\)</span>, <span class="math">\(\varrho\)</span>, <span class="math">\(V\)</span>, and <span class="math">\(g\)</span> are physical
parameters. The function <span class="math">\(u(t)\)</span> represents the vertical velocity,
being positive upwards.
We shall use this model in the following.</p>
<div class="section" id="exact-solution-1">
<h4>Exact solution  (1)<a class="headerlink" href="#exact-solution-1" title="Permalink to this headline">¶</a></h4>
<p>It can be handy to have the exact solution for reference, in case
of constant <span class="math">\(a\)</span> and <span class="math">\(b\)</span>:</p>
<div class="math">
\[{u_{\small\mbox{e}}}(t) = \frac{e^{-at}}{a}\left( b(e^{at}-1) + aI\right)
{\thinspace .}\]</div>
<p>It can be very handy to use a symbolic computation tool such as SymPy
to aid us in solving differential equations.
Let us therefore demonstrate how SymPy can be used to find this solution.
First we define the parameters in the problem as symbols
and <span class="math">\(u(t)\)</span> as a function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t a b I&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
</pre></div>
</div>
<p>The next task is to define the differential equation, either as
a symbolic expression that is to equal zero, or as
an equation <code class="docutils literal"><span class="pre">Eq(lhs,</span> <span class="pre">rhs)</span></code> with <code class="docutils literal"><span class="pre">lhs</span></code> and <code class="docutils literal"><span class="pre">rhs</span></code> as expressions for
the left- and right-hand side):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Define differential equation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">),</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The differential equation can be solved by the <code class="docutils literal"><span class="pre">dsolve</span></code> function, yielding
an equation of the form <code class="docutils literal"><span class="pre">u(t)</span> <span class="pre">==</span> <span class="pre">expression</span></code>. We want to grab the
expression on the right-hand side as our solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sol</span>
<span class="go">u(t) == (b + exp(a*(C1 - t)))/a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span>                    <span class="c"># grab solution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">u</span>
<span class="go">(b + exp(a*(C1 - t)))/a</span>
</pre></div>
</div>
<p>The solution contains the unknown integration constant <code class="docutils literal"><span class="pre">C1</span></code>, which must
be determined by the initial condition. We form the equation arising
from the initial condition <span class="math">\(u(0)=I\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">I</span><span class="p">)</span>   <span class="c"># substitute t by 0 in u</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">C1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sol</span>
<span class="go">[log(I*a - b)/a]</span>
</pre></div>
</div>
<p>The one solution that was found must then be substituted back in the
expression <code class="docutils literal"><span class="pre">u</span></code> to yield the final solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">u</span>
<span class="go">(b + exp(a*(-t + log(I*a - b)/a)))/a</span>
</pre></div>
</div>
<p>As in mathematics with pen and paper, we strive to simplify
expressions also in symbolic computing software.
This frequently requires some trial and error
process with SymPy&#8217;s simplification functions. A very standard
first try is to expand everything and run simplification algorithms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">u</span>
<span class="go">(I*a + b*exp(a*t) - b)*exp(-a*t)/a</span>
</pre></div>
</div>
<p>Note that doing <code class="docutils literal"><span class="pre">latex(u)</span></code> automatically converts the expression to LaTeX syntax
for inclusion in reports.</p>
</div>
<div class="section" id="theory">
<h4>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h4>
<p>The challenges in our scaling is to find the right <span class="math">\(u_c\)</span> and <span class="math">\(t_c\)</span>
scales. From <a href="#equation-scale:decay:model:g">(6)</a> we see that if <span class="math">\(u'\rightarrow 0\)</span>
as <span class="math">\(t\rightarrow\infty\)</span>, <span class="math">\(u\)</span> approaches the constant value <span class="math">\(b/a\)</span>. It can be
convenient to let the scaled <span class="math">\(\bar u\rightarrow 1\)</span> as
we approach the <span class="math">\(d\bar u/d\bar t = 0\)</span> state. This idea points to choosing</p>
<div class="math">
\[u_c = \frac{b}{a} = g\left(\frac{\varrho}{\varrho_b} -1\right)\left(\frac{3\pi d\mu}{\varrho_b V}\right)^{-1}
{\thinspace .}\]</div>
<div class="admonition-on-the-sign-of-the-scaled-velocity admonition">
<p class="first admonition-title">On the sign of the scaled velocity</p>
<p class="last">A little note on the sign of <span class="math">\(u_c\)</span> is necessary here.
With <span class="math">\(\varrho_b &lt; \varrho\)</span>, the buoyancy force upwards wins over the
gravity force downwards, and the body will move upwards. In this case,
the terminal velocity <span class="math">\(u_c &gt; 0\)</span>. When <span class="math">\(\varrho_b &gt; \varrho\)</span>, we get
a motion downwards, and <span class="math">\(u_c &lt; 0\)</span>. The corresponding <span class="math">\(u\)</span> is then also
negative, but the scaled velocity <span class="math">\(u/u_c\)</span>, becomes positive.</p>
</div>
<p id="index-8">Inserting <span class="math">\(u = u_c\bar u = b\bar u/a\)</span> and <span class="math">\(t=t_c\bar t\)</span> in
<a href="#equation-scale:decay:model:g">(6)</a> leads to</p>
<div class="math">
\[\frac{d\bar u}{d\bar t} = -t_c a\bar u + \frac{t_c}{u_c}b,
\quad \bar u(0) = I\frac{a}{b}
{\thinspace .}\]</div>
<p>We want the scales such that <span class="math">\(d\bar u/d\bar t\)</span> and <span class="math">\(\bar u\)</span> are
about unity.
To balance the size of <span class="math">\(\bar u\)</span> and <span class="math">\(d\bar u/d\bar t\)</span> we must
therefore choose
<span class="math">\(t_c = 1/a\)</span>, resulting in the scaled ODE problem</p>
<div class="math" id="equation-scale:decay:model:g:dimless">
<span id="eq-scale-decay-model-g-dimless"></span><span class="eqno">(8)</span>\[     \frac{d\bar u}{d\bar t} = -\bar u + 1,\quad u(0)=\beta,\]</div>
<p>where <span class="math">\(\beta\)</span> is a dimensionless number,</p>
<div class="math">
\[\beta = \frac{I}{u_c} = I\frac{a}{b},\]</div>
<p>reflecting the ratio of the initial velocity and the
terminal (<span class="math">\(t\rightarrow \infty\)</span>) velocity <span class="math">\(b/a\)</span>.
Scaling normally ends up with one or more dimensionless parameters,
such as <span class="math">\(\beta\)</span> here, containing ratios of physical effects in
the model. Many more examples on dimensionless parameters will appear
in later sections.</p>
<p>The analytical solution of the scaled model
<a href="#equation-scale:decay:model:g:dimless">(8)</a> reads</p>
<div class="math" id="equation-scale:decay:model:g:exact_scaled">
<span id="eq-scale-decay-model-g-exact-scaled"></span><span class="eqno">(9)</span>\[     \bar{u_{\small\mbox{e}}}(t) =
     e^{-t}\left( e^{t}-1 + \beta\right) = 1 + (\beta -1)e^{-t}{\thinspace .}\]</div>
<p>The result <a href="#equation-scale:decay:model:g:dimless">(8)</a> with the
solution <a href="#equation-scale:decay:model:g:exact_scaled">(9)</a> is actually
astonishing if <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are as in <a href="#equation-scale:decay:model:g:spec">(7)</a>:
the six parameters <span class="math">\(d\)</span>, <span class="math">\(\mu\)</span>, <span class="math">\(\varrho_b\)</span>, <span class="math">\(\varrho\)</span>, <span class="math">\(V\)</span>, and <span class="math">\(g\)</span>
are conjured to one:</p>
<div class="math">
\[\beta = I\frac{3\pi d\mu}{\varrho_b V}
\frac{1}{g}\left(\frac{\varrho}{\varrho_b} -1\right)^{-1},\]</div>
<p>which is an enormous simplification of the problem if our aim is to
investigate how <span class="math">\(u\)</span> varies with the physical input parameters in
the model.
In particular, if the motion starts from rest, <span class="math">\(\beta=0\)</span>, and
there are no physical parameters in the scaled model!
We can then perform a single simulation and recover all physical
cases by the unscaling procedure. More precisely,
having computed <span class="math">\(\bar u(\bar t)\)</span> from <a href="#equation-scale:decay:model:g:dimless">(8)</a>,
we can use</p>
<div class="math">
\[u(t) = \frac{b}{a}\bar u(at),\]</div>
<p>to scale us back to the original
problem again.
We observe that <a href="#equation-scale:decay:model:g:dimless">(8)</a> can utilize a solver
for <a href="#equation-scale:decay:model:g">(6)</a> by setting <span class="math">\(a=1\)</span>, <span class="math">\(b=1\)</span>, and <span class="math">\(I=\beta\)</span>.
Given some implementation of a solver for <a href="#equation-scale:decay:model:g">(6)</a>,
say <code class="docutils literal"><span class="pre">solver(I,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">T,</span> <span class="pre">dt,</span> <span class="pre">theta)</span></code>,
the scaled model is run by <code class="docutils literal"><span class="pre">solver(beta,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">T,</span> <span class="pre">dt,</span> <span class="pre">theta)</span></code>.</p>
</div>
<div class="section" id="software-1">
<h4>Software  (1)<a class="headerlink" href="#software-1" title="Permalink to this headline">¶</a></h4>
<p>We may develop a solver for the scaled problem that uses <code class="docutils literal"><span class="pre">joblib</span></code>
to cache solutions with the same <span class="math">\(\beta\)</span>, <span class="math">\(\Delta t\)</span>, and <span class="math">\(T\)</span>.
For now we fix <span class="math">\(\theta=0.5\)</span>.
The module <a class="reference external" href="http://tinyurl.com/ofkw6kc/genz/decay_vc.py">decay_vc.py</a> has a function
<code class="docutils literal"><span class="pre">solver(I,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">T,</span> <span class="pre">dt,</span> <span class="pre">theta)</span></code> for solving <span class="math">\(u'(t)=-a(t)u(t)+b(t)\)</span> for
<span class="math">\(t\in (0,T]\)</span>, <span class="math">\(u(0)=I\)</span>, with time step <code class="docutils literal"><span class="pre">dt</span></code>.
We reuse this function and call it with <span class="math">\(a=b=1\)</span> and <span class="math">\(I=\beta\)</span> to solve
the scaled problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">decay_vc</span> <span class="kn">import</span> <span class="n">solver</span> <span class="k">as</span> <span class="n">solver_unscaled</span>

<span class="k">def</span> <span class="nf">solver_scaled</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-u+1, u(0)=beta for (0,T]</span>
<span class="sd">    with step dt and theta method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s">&#39;Computing the numerical solution&#39;</span>
    <span class="k">return</span> <span class="n">solver_unscaled</span><span class="p">(</span>
        <span class="n">I</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">joblib</span>
<span class="n">disk_memory</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">Memory</span><span class="p">(</span><span class="n">cachedir</span><span class="o">=</span><span class="s">&#39;temp&#39;</span><span class="p">)</span>
<span class="n">solver_scaled</span> <span class="o">=</span> <span class="n">disk_memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">solver_scaled</span><span class="p">)</span>
</pre></div>
</div>
<p>If we want to plot the physical solution, we need an <code class="docutils literal"><span class="pre">unscale</span></code> function,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">unscale</span><span class="p">(</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ab</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">t_scaled</span>

<span class="k">def</span> <span class="nf">ab</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">mu</span><span class="o">/</span><span class="p">(</span><span class="n">rho_b</span><span class="o">*</span><span class="n">V</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">g</span><span class="o">*</span><span class="p">(</span><span class="n">rho</span><span class="o">/</span><span class="n">rho_b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
</pre></div>
</div>
<p>Looking at droplets of water in air, we can fix some of the parameters
and let the size parameter <span class="math">\(d\)</span> be the one for experimentation.
The following function sets physical parameters, computes <span class="math">\(\beta\)</span>,
runs the solver for the scaled problem (<code class="docutils literal"><span class="pre">joblib</span></code> detects
if it is necessary), and finally plots the scaled curve
<span class="math">\(\bar u(\bar t)\)</span> and the unscaled curve <span class="math">\(u(t)\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.075</span><span class="p">,</span> <span class="c"># Time step, scaled problem</span>
         <span class="n">T</span><span class="o">=</span><span class="mf">7.5</span><span class="p">,</span>    <span class="c"># Final time, scaled problem</span>
         <span class="n">d</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>  <span class="c"># Diameter (unscaled problem)</span>
         <span class="n">I</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>      <span class="c"># Initial velocity (unscaled problem)</span>
         <span class="p">):</span>
    <span class="c"># Set parameters, solve and plot</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="mf">0.00129E+3</span>  <span class="c"># air</span>
    <span class="n">rho_b</span> <span class="o">=</span> <span class="mf">1E+3</span>      <span class="c"># density of water</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="mf">0.001</span>        <span class="c"># viscosity of water</span>
    <span class="c"># Asumme we have list or similar for d</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>

    <span class="n">legends1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">legends2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">betas</span> <span class="o">=</span> <span class="p">[]</span>     <span class="c"># beta values already computed (for plot)</span>

    <span class="k">for</span> <span class="n">d_</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">d_</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>  <span class="c"># volume</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ab</span><span class="p">(</span><span class="n">d_</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">a</span><span class="o">/</span><span class="n">b</span>
        <span class="c"># Restrict to 3 digits in beta</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">print</span> <span class="s">&#39;beta=</span><span class="si">%.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">beta</span>
        <span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span> <span class="o">=</span> <span class="n">solver_scaled</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

        <span class="c"># Avoid plotting curves with the same beta value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">beta</span> <span class="ow">in</span> <span class="n">betas</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_scaled</span><span class="p">,</span> <span class="n">u_scaled</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
            <span class="n">legends1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;beta=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">beta</span><span class="p">)</span>
        <span class="n">betas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">unscale</span><span class="p">(</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span><span class="p">,</span> <span class="n">d_</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
        <span class="n">legends2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;d=</span><span class="si">%g</span><span class="s"> [mm]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d_</span><span class="o">*</span><span class="mi">1000</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;scaled time&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;scaled velocity&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;lower right&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The most complicated part of the code is related to plotting, but
this part can be skipped when trying to understand how we work with
a scaled model to perform the computations.
The complete program is found in the file
<a class="reference external" href="http://tinyurl.com/nm5587k/scale/falling_body.py">falling_body.py</a>.</p>
<p>Since <span class="math">\(I=0\)</span> implies <span class="math">\(\beta=0\)</span>, we can run different <span class="math">\(d\)</span> values without
any need to recompute <span class="math">\(\bar u(\bar t)\)</span> as long as we assume the particle
starts from rest.</p>
<p>From the scaling, we see that <span class="math">\(u_c = b/a\sim d^{-2}\)</span> and
also that <span class="math">\(t_c=1/a \sim d^{-2}\)</span>, so plotting of <span class="math">\(u(t)\)</span> with dimensions
for various <span class="math">\(d\)</span> values will involve significant variations in the time
and velocity scales. Figure <a class="reference internal" href="#sec-scale-decay-body-fig"><span class="std std-ref">Velocity of falling body: scaled (left) and with dimensions (right)</span></a>
has an example with <span class="math">\(d=1,2,3\)</span> mm, where we clearly see the different
time and velocity scales in the figure with unscaled variables.
Note that the scaled velocity is positive because of the sign of <span class="math">\(u_c\)</span>
(see the box above).</p>
<div class="figure" id="id5">
<span id="sec-scale-decay-body-fig"></span><a class="reference internal image-reference" href="_images/falling_body.png"><img alt="_images/falling_body.png" src="_images/falling_body.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Velocity of falling body: scaled (left) and with dimensions (right)</em></span></p>
</div>
</div>
</div>
<div class="section" id="variable-coefficients">
<span id="sec-scale-decay-jump"></span><h3>Variable coefficients<a class="headerlink" href="#variable-coefficients" title="Permalink to this headline">¶</a></h3>
<p>When a prescribed coefficient like <span class="math">\(a(t)\)</span> in <span class="math">\(u'(t) = -a(t)u(t)\)</span>
varies with time one usually also
performs a scaling of this <span class="math">\(a\)</span>,</p>
<div class="math">
\[\bar a(\bar t) = \frac{a(t) - a_0}{a_c},\]</div>
<p>where the goal is to have the scaled <span class="math">\(|\bar a|\)</span>
of size unity: <span class="math">\(|\bar a|\leq 1\)</span>.
This property is obtained by choosing <span class="math">\(a_c\)</span> as the maximum value
of <span class="math">\(|a(t)-a_0|\)</span> for <span class="math">\(t\in [0,T]\)</span>, which is usually a quantity that
can be estimated since <span class="math">\(a(t)\)</span> is known as a function of <span class="math">\(t\)</span>. The <span class="math">\(a_0\)</span>
parameter can be chosen as 0 here. (It could be tempting to
choose <span class="math">\(a_0=\min_t a(t)\)</span> so that <span class="math">\(0\leq \bar a\leq 1\)</span>, but then there
is at least one point where <span class="math">\(\bar a = 0\)</span> and
the differential equation collapses to <span class="math">\(u'=0\)</span>.)</p>
<p>As an example, imagine a decaying cell culture where we at time <span class="math">\(t_1\)</span>
change the environment such that the death rate increases: <span class="math">\(a(t) = d\)</span> for
<span class="math">\(t &lt; t_1\)</span> and <span class="math">\(a(t)=5d\)</span> for <span class="math">\(t\geq t_1\)</span>. The model reads <span class="math">\(u'=-a(t)u\)</span>, <span class="math">\(u(0)=I\)</span>.</p>
<p>The <span class="math">\(a(t)\)</span> function is scaled by letting the characteristic size be
<span class="math">\(a_c=d\)</span> (and <span class="math">\(a_0=0\)</span>):</p>
<div class="math">
\[\begin{split}\bar a (\bar t) = \left\lbrace\begin{array}{ll}
1, &amp; \bar t &lt; t_1/t_c\\
5, &amp; \bar t \geq t_1/t_c
\end{array}\right.\end{split}\]</div>
<p id="index-9">The scaled equation becomes</p>
<div class="math">
\[\frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = a_c\bar a(\bar t) u_c\bar u,\quad
u_c\bar u(0) = I{\thinspace .}\]</div>
<p>The characteristic time, previously taken as <span class="math">\(t_c=1/a\)</span>, can now be
taken as <span class="math">\(t_c=t_1\)</span> or <span class="math">\(t_c=1/d\)</span>. The natural choice of <span class="math">\(u_c\)</span> is <span class="math">\(I\)</span>.
With <span class="math">\(t_c=1/d\)</span> we get</p>
<div class="math" id="equation-sec:scale:decay:jump:eq1">
<span id="eq-sec-scale-decay-jump-eq1"></span><span class="eqno">(10)</span>\[\begin{split}     \bar u'(\bar t)=-\bar a\bar u,\quad \bar u(0)=1,\quad
     \bar a = \left\lbrace\begin{array}{ll}
     1, &amp; \bar t &lt; \gamma\\
     5, &amp; \bar t \geq \gamma
     \end{array}\right.\end{split}\]</div>
<p>where</p>
<div class="math">
\[\gamma = t_1 d\]</div>
<p>is a dimensionless number in the problem. With <span class="math">\(t_c=t_1\)</span>, we get</p>
<div class="math">
\[\begin{split}\bar u'(\bar t)=-\gamma\bar a\bar u,\quad \bar u(0)=1,\quad
\bar a = \left\lbrace\begin{array}{ll}
1, &amp; \bar t &lt; 1\\
5, &amp; \bar t \geq 1
\end{array}\right.\end{split}\]</div>
<p>The dimensionless parameter <span class="math">\(\gamma\)</span> is now in the equation rather than in
the definition of <span class="math">\(\bar a\)</span>. Both problems involve <span class="math">\(\gamma\)</span>, which
is the ratio between the time when the environmental change happens
and the typical time for the decay (<span class="math">\(1/d\)</span>).</p>
<p>A computation with the scaled model <a href="#equation-sec:scale:decay:jump:eq1">(10)</a>
and the original model with dimensions appears in
Figure <a class="reference internal" href="#sec-scale-decay-jump-fig"><span class="std std-ref">Exponential decay with jump: scaled model (left) and unscaled model (right)</span></a>.</p>
<div class="figure" id="id6">
<span id="sec-scale-decay-jump-fig"></span><a class="reference internal image-reference" href="_images/decay_jump.png"><img alt="_images/decay_jump.png" src="_images/decay_jump.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Exponential decay with jump: scaled model (left) and unscaled model (right)</em></span></p>
</div>
</div>
<div class="section" id="scaling-a-cooling-problem-with-constant-surroundings">
<span id="scale-decay-cooling-const"></span><h3>Scaling a cooling problem with constant surroundings<a class="headerlink" href="#scaling-a-cooling-problem-with-constant-surroundings" title="Permalink to this headline">¶</a></h3>
<p>The heat exchange between a body at temperature <span class="math">\(T(t)\)</span> and the
surroundings at <span class="math">\(T_s(t)\)</span> can be modeled by Newton&#8217;s law of cooling:</p>
<div class="math" id="equation-scale:decay:cooling:model">
<span id="eq-scale-decay-cooling-model"></span><span class="eqno">(11)</span>\[     T'(t) = -k(T-T_s(t)),\quad T(0)=T_0,\]</div>
<p>where <span class="math">\(k\)</span> is a prescribed heat transfer coefficient.
An analytical solution is always handy to have as a control of the
choice of scales. Here we have
the result <span class="math">\(T(t) = T_s + (T_0 - T_s)e^{-kt}\)</span> when <span class="math">\(T_s\)</span> is constant,
which is also the assumption for now.</p>
<p>Physically, we expect the temperature to start at <span class="math">\(T_0\)</span> and then
to move toward the surroundings (<span class="math">\(T_s\)</span>). We therefore expect
that <span class="math">\(T\)</span> lies between <span class="math">\(T_0\)</span> and <span class="math">\(T_s\)</span>. This is mathematically
demonstrated by the analytical solution as well. A proper scaling
is therefore to scale and translate <span class="math">\(T\)</span> according to</p>
<div class="math" id="equation-scale:decay:cooling:Tbar">
<span id="eq-scale-decay-cooling-tbar"></span><span class="eqno">(12)</span>\[     \bar T = \frac{T-T_0}{T_s-T_0}\]\[     {\thinspace .}\]</div>
<p>Now, <span class="math">\(0\leq \bar T\leq 1\)</span>.</p>
<p>Scaling time by <span class="math">\(\bar t = t/t_c\)</span> and inserting
<span class="math">\(T= T_0 + (T_s-T_0)\bar T\)</span> and <span class="math">\(t=t_c\bar t\)</span> in the
problem <a href="#equation-scale:decay:cooling:model">(11)</a> gives</p>
<div class="math">
\[\frac{d\bar T}{d\bar t} = - t_ck(\bar T - 1),\quad \bar T(0) = 0
{\thinspace .}\]</div>
<p>A natural choice, as argued in other exponential decay problems,
is to choose <span class="math">\(t_ck=1\)</span>, which leaves us with the scaled problem</p>
<div class="math" id="equation-scale:decay:cooling:Tbar:eq">
<span id="eq-scale-decay-cooling-tbar-eq"></span><span class="eqno">(13)</span>\[     \frac{d\bar T}{d\bar t} = - (\bar T - 1),\quad \bar T(0)=0\]\[     {\thinspace .}\]</div>
<p>No physical parameter enters this problem!
Our scaling implies that <span class="math">\(\bar T\)</span> starts at
0 and approaches 1 as <span class="math">\(\bar t\rightarrow\infty\)</span>, also in the case
<span class="math">\(T_s &lt; T_0\)</span>. The physical temperature is always recovered as</p>
<div class="math" id="equation-scale:decay:cooling:T">
<span id="eq-scale-decay-cooling-t"></span><span class="eqno">(14)</span>\[     T(t) = T_0 + (T_s-T_0)\bar T (k\bar t)\]\[     {\thinspace .}\]</div>
<p>An implementation for <a href="#equation-scale:decay:cooling:model">(11)</a> works for
<a href="#equation-scale:decay:cooling:Tbar:eq">(13)</a> by setting <span class="math">\(k=1\)</span>, <span class="math">\(T_s=1\)</span>, and <span class="math">\(T_0=0\)</span>.</p>
<p>An alternative scaling is to choose</p>
<div class="math" id="equation-scale:decay:cooling:Tbar2">
<span id="eq-scale-decay-cooling-tbar2"></span><span class="eqno">(15)</span>\[     \bar T = \frac{T-T_s}{T_0-T_s}\]\[     {\thinspace .}\]</div>
<p>Now <span class="math">\(\bar T=1\)</span> initially and approaches zero as <span class="math">\(t\rightarrow\infty\)</span>.
The resulting scaled ODE problem then becomes</p>
<div class="math" id="equation-scale:decay:cooling:Tbar:eq2">
<span id="eq-scale-decay-cooling-tbar-eq2"></span><span class="eqno">(16)</span>\[     \frac{d\bar T}{d\bar t} = - \bar T,\quad \bar T(0)=1\]\[     {\thinspace .}\]</div>
</div>
<div class="section" id="scaling-a-cooling-problem-with-time-dependent-surroundings">
<span id="scale-decay-cooling-osc"></span><h3>Scaling a cooling problem with time-dependent surroundings<a class="headerlink" href="#scaling-a-cooling-problem-with-time-dependent-surroundings" title="Permalink to this headline">¶</a></h3>
<p>Let us apply the model <a href="#equation-scale:decay:cooling:model">(11)</a> in
case the surrounding temperature varies in time. Say we have
an oscillating temperature environment according to</p>
<div class="math" id="equation-scale:decay:cooling:Tst">
<span id="eq-scale-decay-cooling-tst"></span><span class="eqno">(17)</span>\[     T_s(t) = T_m + a\sin(\omega t)\]\[     {\thinspace .}\]</div>
<div class="section" id="exact-solution-2">
<h4>Exact solution  (2)<a class="headerlink" href="#exact-solution-2" title="Permalink to this headline">¶</a></h4>
<p>It is possible to solve the differential equation problem analytically,
and such a solution is a good help to see what scales are.
In general, using the method of integrating factors for the
original differential equation, we have</p>
<div class="math">
\[T(t) = T_0e^{-kt} + e^{-kt}k\int_0^t e^{k\tau}T_s(\tau)d\tau{\thinspace .}\]</div>
<p>With <span class="math">\(T_s(t)=T_m + a\sin (wt)\)</span> we can use SymPy to help us with
integrations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T_m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t k T_m a w&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T_s</span> <span class="o">=</span> <span class="n">T_m</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">T_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Q</span>
<span class="go">(-T_m*k**2 - T_m*w**2 + a*k*w +</span>
<span class="go">(T_m*k**2 + T_m*w**2 + a*k**2*sin(t*w) -</span>
<span class="go">a*k*w*cos(t*w))*exp(k*t))*exp(-k*t)/((k**2 + w**2))</span>
</pre></div>
</div>
<p>Reordering the result, we get</p>
<div class="math">
\[T(t) = T_0e^{-kt} + T_m(1- e^{-kt}) +  (k^2 + w^2)^{-1}(akw e^{-kt}
+ ak\sin (wt) - akw\cos(wt)){\thinspace .}\]</div>
</div>
<div class="section" id="scaling-1">
<span id="index-10"></span><h4>Scaling  (1)<a class="headerlink" href="#scaling-1" title="Permalink to this headline">¶</a></h4>
<p>The scaling <a href="#equation-scale:decay:cooling:Tbar">(12)</a> brings in a time-dependent
characteristic temperature scale <span class="math">\(T_s-T_0\)</span>. Let us start with a
fixed scale, where we take the characteristic temperature variation to
be <span class="math">\(T_m - T_0\)</span>:</p>
<div class="math">
\[\bar T = \frac{T-T_0}{T_m-T_0}{\thinspace .}\]</div>
<p>We see from the analytical solution, and realize also by physical
reasoning, that <span class="math">\(T\)</span> sets out at <span class="math">\(T_0\)</span>, but with time, it will oscillate
around <span class="math">\(T_m\)</span>. The typical average temperature span is therefore
<span class="math">\(|T_m-T_0|\)</span>.</p>
<p>We get from the differential equation, with <span class="math">\(t_c=1/k\)</span> as in the former
case,</p>
<div class="math">
\[k(T_m-T_0)\frac{d\bar T}{d\bar t} = -k((T_m-T_0)\bar T + T_0 - T_m - a
\sin(wt),\]</div>
<p>resulting in</p>
<div class="math" id="equation-scale:decay:cooling:model:scaled">
<span id="eq-scale-decay-cooling-model-scaled"></span><span class="eqno">(18)</span>\[     \frac{d\bar T}{d\bar t} = -\bar T + 1 + \alpha\sin (\beta \bar t),\quad
     \bar T(0)=0,\]</div>
<p>where we have two dimensionless numbers:</p>
<div class="math">
\[\alpha = \frac{a}{T_m-T_0},\quad \beta = \frac{w}{k}{\thinspace .}\]</div>
<p>The <span class="math">\(\alpha\)</span> quantity
measures the ratio of temperatures: amplitude of oscillations versus
characteristic total temperature variation.
The <span class="math">\(\beta\)</span> number is the ratio of the two time scales:
the frequency of the oscillations in <span class="math">\(T_s\)</span> and the inverse
e-folding time of the heat transfer. For clear interpretation of <span class="math">\(\beta\)</span>
we may introduce the period
<span class="math">\(P=2\pi/w\)</span> of the oscillations in <span class="math">\(T_s\)</span> and the e-folding time <span class="math">\(e=1/k\)</span>. Then
<span class="math">\(\beta = 2\pi e/P\)</span> and measures the period versus the e-folding time.</p>
<p>The original problem features five physical parameters: <span class="math">\(k\)</span>, <span class="math">\(T_0\)</span>,
<span class="math">\(T_m\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(w\)</span>, but only two dimensionless numbers appear in the
scaled model.</p>
</div>
<div class="section" id="software-2">
<h4>Software  (2)<a class="headerlink" href="#software-2" title="Permalink to this headline">¶</a></h4>
<p>Implementing the unscaled problem <a href="#equation-scale:decay:cooling:model">(11)</a>
can be reused for the scaled model by setting <span class="math">\(k=1\)</span>, <span class="math">\(T_0=0\)</span>, and
<span class="math">\(T_s(t) = 1 + \alpha\sin (\beta \bar t)\)</span> (<span class="math">\(T_m=1\)</span>, <span class="math">\(a=\alpha\)</span>, <span class="math">\(w=\beta\)</span>).</p>
</div>
<div class="section" id="discussion-of-the-time-scale-1">
<h4>Discussion of the time scale  (1)<a class="headerlink" href="#discussion-of-the-time-scale-1" title="Permalink to this headline">¶</a></h4>
<p>Looking at the analytical insight we have, <span class="math">\(T(t)\)</span> has two characteristic
terms in time: <span class="math">\(e^{-kt}\)</span> and <span class="math">\(\sin(wt)\)</span>. The former points to a time
scale <span class="math">\(t_c=1/k\)</span>, while the latter to <span class="math">\(t_c=1/w\)</span>.
Which one should be chosen? Bringing the temperature from <span class="math">\(T_0\)</span> to
the level of the surroundings, <span class="math">\(T_m\)</span>, goes like <span class="math">\(e^{-kt}\)</span>, so
in this process <span class="math">\(t_c=1/k\)</span> is the characteristic time. Thereafter,
the body&#8217;s temperature just responds to the oscillations and the
<span class="math">\(\sin (wt)\)</span> (and <span class="math">\(\cos(wt)\)</span>) term dominates. For these large times,
<span class="math">\(t_c=1/w\)</span> is the appropriate time scale. Choosing <span class="math">\(t_c=1/w\)</span>
results in</p>
<div class="math" id="equation-scale:decay:cooling:model:scaled2">
<span id="eq-scale-decay-cooling-model-scaled2"></span><span class="eqno">(19)</span>\[     \frac{d\bar T}{d\bar t} = -\beta^{-1}(\bar T - (1 + \alpha\sin (\bar t))),\quad
     \bar T(0)=0{\thinspace .}\]</div>
<p>Let us illustrate another, less effective, scaling.
The temperature scale in
<a href="#equation-scale:decay:cooling:Tbar">(12)</a> looks natural, so we apply this
choice of scale. The characteristic temperature <span class="math">\(T_0-T_s\)</span>
now involves
a time-dependent term <span class="math">\(T_s(t)\)</span>. The mathematical steps become a bit
more technically involved:</p>
<div class="math">
\[T(t) = T_0 + (T_s(t)-T_0)\bar T,\]</div>
<div class="math">
\[\frac{dT}{dt} = \frac{dT_s}{dt}\bar T +
(T_s-T_0)\frac{d\bar T}{d\bar t}\frac{d\bar t}{dt}
{\thinspace .}\]</div>
<p>With <span class="math">\(\bar t = t/t_c = kt\)</span> we get from the differential equation</p>
<div class="math">
\[\frac{dT_s}{dt}\bar T +
(T_s-T_0)\frac{d\bar T}{d\bar t}k
= -k(\bar T - 1)(T_s - T_0),\]</div>
<p>which after dividing by <span class="math">\(k(T_s-T_0)\)</span> results in</p>
<div class="math">
\[\frac{d\bar T}{d\bar t} = -(\bar T - 1) -
\frac{dT_s}{dt}\frac{\bar T}{k(T_s-T_0},\]</div>
<p>or</p>
<div class="math">
\[\frac{d\bar T}{d\bar t} = -(\bar T - 1) -
\frac{a\omega\cos(\omega \bar t/k)}{k(T_m + a\sin(\omega \bar t/k) -T_0)}\bar T
{\thinspace .}\]</div>
<p>The last term is complicated and becomes more tractable if we factor
out dimensionless numbers. To this end, we scale <span class="math">\(T_s\)</span> by (e.g.) <span class="math">\(T_m\)</span>,
which means to factor out <span class="math">\(T_m\)</span> in the denominator. We are then
left with</p>
<div class="math" id="equation-scale:decay:cooling:Tbar:eq3">
<span id="eq-scale-decay-cooling-tbar-eq3"></span><span class="eqno">(20)</span>\[     \frac{d\bar T}{d\bar t} = -(\bar T - 1) -
     \alpha\beta \frac{\cos(\beta \bar t)}{1 + \alpha\sin(\beta\bar t) - \gamma}
     \bar T,\]</div>
<p>where <span class="math">\(\alpha\)</span>, <span class="math">\(\beta\)</span>, and <span class="math">\(\gamma\)</span> are dimensionless numbers
characterizing the relative importance of parameters in the problem:</p>
<div class="math">
\[\alpha=a/T_m,\quad \beta = \omega/k,\quad \gamma = T_0/T_m
{\thinspace .}\]</div>
<p>We notice that <a href="#equation-scale:decay:cooling:Tbar:eq3">(20)</a>
is not a special case of the original problem
<a href="#equation-scale:decay:cooling:model">(11)</a>. Furthermore, the original five
parameters <span class="math">\(k\)</span>, <span class="math">\(T_m\)</span>, <span class="math">\(a\)</span>, <span class="math">\(\omega\)</span>, and
<span class="math">\(T_0\)</span> are reduced to three dimensionless parameters.
We conclude that this scaling is inferior, because
using the temperature scale <span class="math">\(T_0-T_m\)</span> enables reuse of the software
for the unscaled problem and only two dimensionless parameters appear
in the scaled model.</p>
</div>
</div>
<div class="section" id="scaling-a-nonlinear-ode">
<span id="sec-scale-decay-nonlinear"></span><h3>Scaling a nonlinear ODE<a class="headerlink" href="#scaling-a-nonlinear-ode" title="Permalink to this headline">¶</a></h3>
<p id="index-11">Exponential growth models, <span class="math">\(u'=au\)</span>, are not realistic in environments
with limited resources. The idea is then to assume that
the growth rate <span class="math">\(a\)</span> decreases with <span class="math">\(u\)</span> and vanishes when we reach the maximum
value <span class="math">\(M\)</span> of <span class="math">\(u\)</span> the environment can sustain. The initial growth rate
is set to <span class="math">\(r\)</span>: <span class="math">\(a(0)=\varrho\)</span>.
In general, this reasoning gives rise to models</p>
<div class="math" id="equation-sec:scale:decay:nonlinear:model1">
<span id="eq-sec-scale-decay-nonlinear-model1"></span><span class="eqno">(21)</span>\[     u' = a(u)u,\quad u(0)=I,\]</div>
<p>with the logistic model, corresponding to <span class="math">\(a(u)=\varrho(1-u/M)\)</span>,
as the simplest:</p>
<div class="math" id="equation-sec:scale:decay:nonlinear:model2">
<span id="eq-sec-scale-decay-nonlinear-model2"></span><span class="eqno">(22)</span>\[     u' = \varrho u(1-u/M),\quad u(0)=I{\thinspace .}\]</div>
<p>A general choice of <span class="math">\(a\)</span> might be <span class="math">\(a(u)=\varrho(1-u/M)^p\)</span> for some exponent <span class="math">\(p\)</span>.</p>
<p id="index-12">Let us scale <a href="#equation-sec:scale:decay:nonlinear:model1">(21)</a> with
<span class="math">\(a(u)=\varrho (1-u/M)^p\)</span>.
The natural scale for <span class="math">\(u\)</span> is <span class="math">\(M\)</span> (<span class="math">\(u_c=M\)</span>), since we know that
<span class="math">\(0 &lt; u\leq M\)</span>, and this makes the dimensionless <span class="math">\(\bar u = u/M \in (0,1]\)</span>.
The function <span class="math">\(a(u)\)</span> is
typically varying between 0 and <span class="math">\(\varrho\)</span>, so it can be scaled as</p>
<div class="math">
\[\bar a(\bar u) = \frac{a(u)}{\varrho} = (1 - \frac{u}{M})^p =
(1 - \bar u)^p{\thinspace .}\]</div>
<p>Time is scaled as <span class="math">\(\bar t = t/t_c\)</span> for some suitable characteristic time <span class="math">\(t_c\)</span>.
Inserted in <a href="#equation-sec:scale:decay:nonlinear:model1">(21)</a>, we get</p>
<div class="math">
\[\frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = \varrho\bar a u_c\bar u,\quad u_c\bar u(0)=I,\]</div>
<p>resulting in</p>
<div class="math">
\[\frac{d\bar u}{d\bar t} = t_c \varrho (1 - \bar u)^p \bar u,\quad
\bar u(0) =\frac{I}{M}{\thinspace .}\]</div>
<p>A natural choice is <span class="math">\(t_c =1/\varrho\)</span> as in other exponential growth models
since it leads to the term on the right-hand side to be about unity,
as the left-hand side, if the scaling is physically correct.
Introducing the dimensionless parameter</p>
<div class="math">
\[\alpha = \frac{I}{M},\]</div>
<p>measuring the fraction of the initial population compared to the maximum
one, we get the dimensionless model</p>
<div class="math" id="equation-sec:scale:decay:nonlinear:model1:scaled">
<span id="eq-sec-scale-decay-nonlinear-model1-scaled"></span><span class="eqno">(23)</span>\[     \frac{d\bar u}{d\bar t} = (1 - \bar u)^p \bar u,\quad
     \bar u(0) =\alpha{\thinspace .}\]</div>
<p>Here, we have two dimensionless parameters: <span class="math">\(\alpha\)</span> and <span class="math">\(p\)</span>. A classical
logistic model with <span class="math">\(p=1\)</span> has only one dimensionless variable.</p>
<p>We could try another scaling of <span class="math">\(u\)</span> where we also translate <span class="math">\(\bar u\)</span>:</p>
<div class="math">
\[\bar u = \frac{u-I}{M}{\thinspace .}\]</div>
<p>This choice of <span class="math">\(\bar u\)</span> results in</p>
<div class="math" id="equation-sec:scale:decay:nonlinear:model1:scaled2">
<span id="eq-sec-scale-decay-nonlinear-model1-scaled2"></span><span class="eqno">(24)</span>\[     \frac{d\bar u}{d\bar t} = (1 - \alpha - \bar u)^p \bar u,\quad
     \bar u(0) =0{\thinspace .}\]</div>
<p>The essential difference between <a href="#equation-sec:scale:decay:nonlinear:model1:scaled">(23)</a>
and <a href="#equation-sec:scale:decay:nonlinear:model1:scaled2">(24)</a> is that
<span class="math">\(\bar u\in [\alpha, 1]\)</span> in the former and <span class="math">\(\bar u \in [0, 1-\alpha]\)</span> in
the latter. Both models involve the dimensionless numbers <span class="math">\(\alpha\)</span> and <span class="math">\(p\)</span>.
An advantage of <a href="#equation-sec:scale:decay:nonlinear:model1:scaled">(23)</a>
is that software for the unscaled model can easily be used for the
scaled model by choosing <span class="math">\(I=\alpha\)</span>, <span class="math">\(M=1\)</span>, and <span class="math">\(\varrho=1\)</span>.</p>
</div>
<div class="section" id="ode-systems-for-spreading-of-diseases">
<h3>ODE systems for spreading of diseases<a class="headerlink" href="#ode-systems-for-spreading-of-diseases" title="Permalink to this headline">¶</a></h3>
<p>The field of epidemiology frequently applies ODE systems to describe the spreading of diseases, such as smallpox, measles, plague, ordinary flu, swine flu,
and HIV. Different models include different effects, which are reflected
in dimensionless numbers. Most of the effects are modeled as exponential
decay or growth of the dependent variables.</p>
<div class="section" id="sir-model">
<h4>SIR model<a class="headerlink" href="#sir-model" title="Permalink to this headline">¶</a></h4>
<p>The model has three categories of people: susceptibles (S) who can get
the disease, infected (I) who are infected and may infect susceptibles,
and recovered (R) who have recovered from the disease and gained
immunity. We introduce <span class="math">\(S(t)\)</span>, <span class="math">\(I(t)\)</span>, and <span class="math">\(R(t)\)</span> as the number of
people in the categories S, I, and R, respectively.
The model, naturally known as the SIR model, takes the form a system of ODEs:</p>
<div class="math" id="equation-scale:SIR:S">
<span id="eq-scale-sir-s"></span><span class="eqno">(25)</span>\[     \frac{dS}{dt} = - \beta SI,\]</div>
<div class="math" id="equation-scale:SIR:I">
<span id="eq-scale-sir-i"></span><span class="eqno">(26)</span>\[     \frac{dI}{dt} = \beta SI - \nu I,\]</div>
<div class="math" id="equation-scale:SIR:R">
<span id="eq-scale-sir-r"></span><span class="eqno">(27)</span>\[     \frac{dR}{dt} = \nu I,\]</div>
<p>where <span class="math">\(\beta\)</span> and <span class="math">\(nu\)</span> are empirical constants. The average time for recovering
from the disease can be shown to be <span class="math">\(\nu^{-1}\)</span>, but <span class="math">\(\beta\)</span> is much harder
to estimate, so working with a scaled model where <span class="math">\(k\)</span> is &#8220;scaled away&#8221;
is advantageous. Adding <a href="#equation-scale:SIR:S">(25)</a>-<a href="#equation-scale:SIR:R">(27)</a>
shows that</p>
<div class="math">
\[\frac{dS}{dt}+\frac{dI}{dt}+\frac{dR}{dt}=0\quad\Rightarrow\quad
S+I+R=\hbox{const}=N,\]</div>
<p>where <span class="math">\(N\)</span> is the size of the population. It is natural to scale
<span class="math">\(S\)</span>, <span class="math">\(I\)</span>, and <span class="math">\(R\)</span> by, e.g., <span class="math">\(S(0)\)</span>:</p>
<div class="math">
\[\bar S = \frac{S}{S(0)},\quad \bar I = \frac{I}{S(0)},\quad
\bar R = \frac{R}{S(0)}{\thinspace .}\]</div>
<p>Introducing <span class="math">\(\bar t = t/t_c\)</span>, we arrive at the equations</p>
<div class="math">
\[\begin{split}\frac{d\bar S}{d\bar t} &amp;= - t_c S(0) \beta\bar S\bar I,
\\
\frac{d\bar I}{d\bar t} &amp;= t_c S(0) \beta \bar S\bar I - t_c \nu \bar I,
\\
\frac{d\bar R}{d\bar t} &amp;= t_c \nu I,\end{split}\]</div>
<p>with initial conditions <span class="math">\(\bar S(0)=1\)</span>, <span class="math">\(\bar I(0)=I_0/S(0)=\alpha\)</span>, and
<span class="math">\(\bar R(0)=R(0)/S(0)\)</span>. Normally, <span class="math">\(R(0)=0\)</span>.</p>
<p>Taking <span class="math">\(t_c=1/\nu\)</span>, corresponding to a time unit equal to the time it takes
to recover from the disease, we end up with the scaled model</p>
<div class="math" id="equation-scale:SIR:S2">
<span id="eq-scale-sir-s2"></span><span class="eqno">(28)</span>\[     \frac{d\bar S}{d\bar t} = - R_0\bar S\bar I,\]</div>
<div class="math" id="equation-scale:SIR:I2">
<span id="eq-scale-sir-i2"></span><span class="eqno">(29)</span>\[     \frac{d\bar I}{d\bar t} = R_0 \bar S\bar I - \bar I,\]</div>
<div class="math" id="equation-scale:SIR:R2">
<span id="eq-scale-sir-r2"></span><span class="eqno">(30)</span>\[     \frac{d\bar R}{d\bar t} = I,\]</div>
<p>with <span class="math">\(\bar S(0)=1\)</span>, <span class="math">\(\bar I(0)=\alpha\)</span>, <span class="math">\(\bar R(0)=0\)</span>, and <span class="math">\(R_0\)</span> as
the dimensionless number</p>
<div class="math">
\[R_0 = \frac{S(0)\beta}{\nu}{\thinspace .}\]</div>
<p>We see from <a href="#equation-scale:SIR:I2">(29)</a> that to make the disease spreading,
<span class="math">\(d\bar I/d\bar t &gt;0\)</span>, and therefore <span class="math">\(R_0 S(0) - 1 &gt; 0\)</span> or <span class="math">\(R_0 &gt; 1\)</span>
since <span class="math">\(S(0)=1\)</span>.
Therefore, <span class="math">\(R_0\)</span> reflects the disease&#8217;s ability to spread and is
consequently an important dimensionless quantity, known as the <em>basic
reproductive number</em>.
[<strong>hpl 1</strong>: Explain interpretation.]</p>
<p>Looking at <a href="#equation-scale:SIR:I">(26)</a>, we see that to increase <span class="math">\(I\)</span> initially,
we must have <span class="math">\(dI/dt &gt;0\)</span> at <span class="math">\(t=0\)</span>, which implies
<span class="math">\(\beta I(0)S(0) - \nu I(0) &gt;0\)</span>, i.e., <span class="math">\(R_0 &gt; 1\)</span>.</p>
<p>We can also scale <span class="math">\(S\)</span>, <span class="math">\(I\)</span>, and <span class="math">\(R\)</span> by the total population <span class="math">\(N=S(0)+I(0)+R(0)\)</span>,</p>
<div class="math">
\[\bar S = \frac{S}{N},\quad \bar I = \frac{I}{N},\quad
\bar R = \frac{R}{N)}{\thinspace .}\]</div>
<p>With the same time scale, one gets the system <a href="#equation-scale:SIR:S2">(28)</a>-<a href="#equation-scale:SIR:R2">(30)</a>, but with <span class="math">\(R_0\)</span> replaced by the dimensionless number:</p>
<div class="math">
\[\tilde R_0 = \frac{N\beta}{\nu}{\thinspace .}\]</div>
<p>The initial conditions become <span class="math">\(\bar S(0)=1-\alpha\)</span>, <span class="math">\(\bar I(0)=\alpha\)</span>,
and <span class="math">\(\bar R(0)=0\)</span>.</p>
<p>For the disease to spread at <span class="math">\(t=0\)</span>, we must have <span class="math">\(\tilde R_0 \bar S(0) &gt; 1\)</span>,
but <span class="math">\(\tilde R_0 \bar S(0) = N\beta/\nu \cdot S(0)/N = R_0\)</span>, so the
criterion is still <span class="math">\(R_0 &gt; 1\)</span>. Since <span class="math">\(R_0\)</span> is a more famous number than
<span class="math">\(\tilde R_0\)</span>, we can write the ODEs with <span class="math">\(R_0/S(0) = R_0/(1-\alpha)\)</span>
instead of <span class="math">\(\tilde R_0\)</span>.</p>
<p>Choosing <span class="math">\(t_c\)</span> to make the <span class="math">\(SI\)</span> terms balance the time derivatives,
<span class="math">\(t_c = (N\beta)^{-1}\)</span>, moves <span class="math">\(\tilde R_0\)</span> (or <span class="math">\(R_0\)</span> if we scale
<span class="math">\(S\)</span>, <span class="math">\(I\)</span>, and <span class="math">\(R\)</span> by <span class="math">\(S(0)\)</span>) to the <span class="math">\(I\)</span> terms:</p>
<div class="math">
\[\begin{split}\frac{d\bar S}{d\bar t} &amp;= - \bar S\bar I,
\\
\frac{d\bar I}{d\bar t} &amp;= \bar S\bar I - \tilde R_0^{-1} \bar I,
\\
\frac{d\bar R}{d\bar t} &amp;= \tilde R_0^{-1} I{\thinspace .}\end{split}\]</div>
</div>
<div class="section" id="sirv-model-with-finite-immunity">
<h4>SIRV model with finite immunity<a class="headerlink" href="#sirv-model-with-finite-immunity" title="Permalink to this headline">¶</a></h4>
<p>A common extension of the SIR model involves finite immunity: after
some period of time, recovered individuals lose their immunity
and become susceptibles again. This is modeled as
a leakage <span class="math">\(-\mu R\)</span> from the R to the S category, where <span class="math">\(\mu^{-1}\)</span>
is the average time it takes to lose immunity.
Vaccination is another extension: a fraction <span class="math">\(pS\)</span> is removed from the
S category by successful vaccination and brought to a new category V (the
vaccinated). The ODE model reads</p>
<div class="math" id="equation-scale:SIRV:S">
<span id="eq-scale-sirv-s"></span><span class="eqno">(31)</span>\[     \frac{dS}{dt} = - \beta SI - pS + \mu R,\]</div>
<div class="math" id="equation-scale:SIRV:I">
<span id="eq-scale-sirv-i"></span><span class="eqno">(32)</span>\[     \frac{dI}{dt} = \beta SI - \nu I,\]</div>
<div class="math" id="equation-scale:SIRV:R">
<span id="eq-scale-sirv-r"></span><span class="eqno">(33)</span>\[     \frac{dR}{dt} = \nu I -\mu R,\]</div>
<div class="math" id="equation-scale:SIRV:V">
<span id="eq-scale-sirv-v"></span><span class="eqno">(34)</span>\[     \frac{dV}{dt} = p S{\thinspace .}\]</div>
<p>Using <span class="math">\(t_c=1/\nu\)</span> and scaling the unknowns by <span class="math">\(S(0)\)</span> leads to
the dimensionless model</p>
<div class="math" id="equation-scale:SIRV:S2">
<span id="eq-scale-sirv-s2"></span><span class="eqno">(35)</span>\[     \frac{d\bar S}{d\bar t} = - R_0 \bar S \bar I - \delta S + \gamma \bar R,\]</div>
<div class="math" id="equation-scale:SIRV:I2">
<span id="eq-scale-sirv-i2"></span><span class="eqno">(36)</span>\[     \frac{d\bar I}{d\bar t} = R_0 \bar S \bar I - \bar I,\]</div>
<div class="math" id="equation-scale:SIRV:R2">
<span id="eq-scale-sirv-r2"></span><span class="eqno">(37)</span>\[     \frac{d\bar R}{d\bar t} = \bar I -\gamma \bar R,\]</div>
<div class="math" id="equation-scale:SIRV:V2">
<span id="eq-scale-sirv-v2"></span><span class="eqno">(38)</span>\[     \frac{d\bar V}{d\bar t} = \delta \bar S,\]</div>
<p>with two new dimensionless parameters:</p>
<div class="math">
\[\gamma = \frac{\mu}{\nu},\quad \delta = \frac{p}{\nu}{\thinspace .}\]</div>
<p>The quantity <span class="math">\(p^{-1}\)</span> can be interpreted as the average time it takes
to vaccinate a susceptible successfully. Writing <span class="math">\(\gamma = \nu^{-1}/\mu^{-1}\)</span>
and <span class="math">\(\delta = \nu^{-1}/p^{-1}\)</span> gives the interpretation that <span class="math">\(\gamma\)</span>
is the ratio of the average time to recover and the average time to
lose immunity, while <span class="math">\(\delta\)</span> is the ratio of the average time to recover
and the average time to successfully vaccinate a susceptible.</p>
</div>
</div>
<div class="section" id="michaelis-menten-kinetics-for-biochemical-reactions">
<span id="scale-mmk"></span><h3>Michaelis-Menten kinetics for biochemical reactions<a class="headerlink" href="#michaelis-menten-kinetics-for-biochemical-reactions" title="Permalink to this headline">¶</a></h3>
<p>A classical reaction model in biochemistry describes how a
substrate S is turned into a product P with aid of an enzyme E.
S and E react to form a complex ES in the first stage of the reaction.
In the second stage, ES is turned into E and P.
Introducing the amount of S, E, ES, and P by <span class="math">\([S]\)</span>, <span class="math">\([E]\)</span>, <span class="math">\([ES]\)</span>, and
<span class="math">\([P]\)</span>, the mathematical model can be written as</p>
<div class="math" id="equation-scale:MMK:ES1">
<span id="eq-scale-mmk-es1"></span><span class="eqno">(39)</span>\[     \frac{d[ES]}{dt} = k_+[E][S] - k_v[ES] - k_-[ES],\]</div>
<div class="math" id="equation-scale:MMK:P1">
<span id="eq-scale-mmk-p1"></span><span class="eqno">(40)</span>\[     \frac{d[P]}{dt} = k_v[ES],\]</div>
<div class="math" id="equation-scale:MMK:S1">
<span id="eq-scale-mmk-s1"></span><span class="eqno">(41)</span>\[     \frac{d[S]}{dt} = -k_+[E][S] + k_-[ES],\]</div>
<div class="math" id="equation-scale:MMK:E1">
<span id="eq-scale-mmk-e1"></span><span class="eqno">(42)</span>\[     \frac{d[E]}{dt} = -k_+[E][S] + k_-[ES] + k_v[ES]{\thinspace .}\]</div>
<p>The initial conditions are <span class="math">\([ES](0)=[P](0)=0\)</span>, and <span class="math">\([S]=S_0\)</span>, <span class="math">\([E]=E_0\)</span>.
Three rate constants are involved: <span class="math">\(k_+\)</span>, <span class="math">\(k_-\)</span>, and <span class="math">\(k_v\)</span>.</p>
<p>The amount of substance is measured in the unit <a class="reference external" href="https://en.wikipedia.org/wiki/Mole_(unit)">mole</a> (mol). From the equations we can see that
<span class="math">\(k_+\)</span> is measured in <span class="math">\(\hbox{s}^{-1}\hbox{mol}^{-1}\)</span>, while <span class="math">\(k_-\)</span> and
<span class="math">\(k_v\)</span> are measured in <span class="math">\(\hbox{s}^{-1}\)</span>. It is convenient to get rid of
the mole unit for the amount of a substance. When working with
dimensionless quantities, only ratios of the rate constants and not their
specific values are needed.</p>
<div class="section" id="classical-analysis">
<h4>Classical analysis<a class="headerlink" href="#classical-analysis" title="Permalink to this headline">¶</a></h4>
<p>The typical analysis of the present ODE system is to first observe
two conservation equations, arising from simply adding the ODEs:</p>
<div class="math">
\[\frac{d[ES]}{dt} + \frac{d[E]}{dt}  =0,\]</div>
<div class="math">
\[\frac{d[ES]}{dt} + \frac{d[S]}{dt} + \frac{d[P]}{dt} = 0,\]</div>
<p>from which it follows that</p>
<div class="math" id="equation-scale:MMK:cons1">
<span id="eq-scale-mmk-cons1"></span><span class="eqno">(43)</span>\[     [ES] + [E] = E_0,\]</div>
<div class="math" id="equation-scale:MMK:cons2">
<span id="eq-scale-mmk-cons2"></span><span class="eqno">(44)</span>\[     [ES] + [S] + [P] = S_0{\thinspace .}\]</div>
<p>Using <a href="#equation-scale:MMK:cons1">(43)</a>, we can eliminate <span class="math">\([E]\)</span> and obtain a
system of only two ODEs,</p>
<div class="math">
\[\frac{d[ES]}{dt} = k_+([ES]-E_0)[S] - (k_v + k_-)[ES],\]</div>
<div class="math">
\[\frac{d[S]}{dt} = -k_+([ES]-E_0)[S] + k_-[ES]{\thinspace .}\]</div>
<p>A common assumption is that the formation of <span class="math">\([ES]\)</span> is very fast and that
it reaches an equilibrium state, <span class="math">\([ES]^{\prime}=0\)</span>. This implies</p>
<div class="math">
\[k_+([ES]-E_0)[S] - (k_v + k_-)[ES]=0\quad\Rightarrow\quad
[ES] = \frac{E_0[S]}{[S] - K},\]</div>
<p>where</p>
<div class="math">
\[K = \frac{k_- + k_v}{k_+},\]</div>
<p>is the Michaelis constant. Using the expression for <span class="math">\([ES]\)</span> in the
equation for <span class="math">\([S]\)</span> gives</p>
<div class="math" id="equation-scale:MMK:Seq1">
<span id="eq-scale-mmk-seq1"></span><span class="eqno">(45)</span>\[     \frac{dS}{dt} = \frac{k_vE_0[S]}{[S] + K}{\thinspace .}\]</div>
<p>We see that the parameter <span class="math">\(K\)</span> is central.</p>
</div>
<div class="section" id="dimensionless-ode-system">
<h4>Dimensionless ODE system<a class="headerlink" href="#dimensionless-ode-system" title="Permalink to this headline">¶</a></h4>
<p>Let us reason how to make the original ODE system dimensionless.
Aiming at <span class="math">\([S]\)</span> and <span class="math">\([E]\)</span> of unit size, two obvious dimensionless
unknowns are</p>
<div class="math">
\[\bar S = \frac{[S]}{S_0},\quad
\bar E = \frac{[E]}{E_0}{\thinspace .}\]</div>
<p>For the other two unknowns we just introduce scales to be determined
later:</p>
<div class="math">
\[\bar P = \frac{[P]}{P_c},\quad
\bar{Q} = \frac{[ES]}{Q_c}{\thinspace .}\]</div>
<p>With <span class="math">\(\bar t = t/t_c\)</span> the equations become</p>
<div class="math">
\[\begin{split}\frac{d\bar Q}{d\bar t} &amp;= t_ck_+\frac{E_0S_0}{Q_c}\bar E\bar S
- t_c(k_v + k_-)\bar Q,\\
\frac{d\bar P}{d\bar t} &amp;= t_ck_v\frac{Q_c}{P_c}\bar Q,\\
\frac{d\bar S}{d\bar t} &amp;= -t_ck_+E_0\bar E\bar S
+ t_ck_-\frac{Q_c}{S_0}\bar Q,\\
\frac{d\bar E}{d\bar t} &amp;= -t_ck_+S_0\bar E\bar S
+ t_c(k_- + k_v)\frac{Q_c}{E_0}\bar Q{\thinspace .}\end{split}\]</div>
</div>
<div class="section" id="determining-scales">
<h4>Determining scales<a class="headerlink" href="#determining-scales" title="Permalink to this headline">¶</a></h4>
<p>Choosing the scales is actually a quite complicated matter that requires
extensive analysis of the equations to determine the characteristics of
the solutions. Much literature is written about this, but here we shall
take a simplistic and pragmatic approach.
Besides the Michaelis constant, there is another important parameter,</p>
<div class="math">
\[\epsilon = \frac{E_0}{S_0},\]</div>
<p>because most applications will involve a small <span class="math">\(\epsilon\)</span>.
We shall have <span class="math">\(K\)</span> and <span class="math">\(\epsilon\)</span> in mind while choosing scales such that
these symbols appear naturally in the scaled equations.</p>
<p>Looking at the equations, we see that the <span class="math">\(K\)</span> parameter will appear
if <span class="math">\(t_c\sim 1/k_+\)</span>. However, <span class="math">\(1/k_+\)</span> does not have the dimension
<span class="math">\(\hbox{[T]}^{-1}\)</span> as required, so we need to add a factor with dimension
mol. A natural choice is
<span class="math">\(t_c^{-1}=k_+S_0\)</span> or <span class="math">\(t_c^{-1}=k_+E_0\)</span>. Since often <span class="math">\(S_0\gg E_0\)</span>,
the former <span class="math">\(t_c\)</span> is a short time scale and the latter is a long
time scale. If the interest is in the long time scale, we set</p>
<div class="math">
\[t_c = \frac{1}{k_+E_0}{\thinspace .}\]</div>
<p>The equations then take the form</p>
<div class="math">
\[\begin{split}\frac{d\bar Q}{d\bar t} &amp;= \frac{S_0}{Q_c}\bar E\bar S
- KE_0^{-1}\bar Q,\\
\frac{d\bar P}{d\bar t} &amp;= \frac{k_v}{k_+ E_0}\frac{Q_c}{P_c}\bar Q,\\
\frac{d\bar S}{d\bar t} &amp;= -\bar E\bar S
+ \frac{k_-}{k_+E_0}\frac{Q_c}{S_0}\bar Q,\\
\frac{d\bar E}{d\bar t} &amp;= -\epsilon^{-1}\bar E\bar S
+ K\frac{Q_c}{E_0^2}\bar Q{\thinspace .}\end{split}\]</div>
<p>The <span class="math">\([ES]\)</span> variable starts and ends at zero, and its maximum value
can be roughly estimated from the equation for <span class="math">\([ES]^{\prime}\)</span>
by setting <span class="math">\([ES]^{\prime}=0\)</span>, which gives an estimate of</p>
<div class="math">
\[Q_c = \frac{E_0S_0}{K},\]</div>
<p>if we approximate <span class="math">\([E][S]\)</span> by <span class="math">\(E_0S_0\)</span>.</p>
<p>The equation for <span class="math">\(\bar P\)</span> simplifies if we choose <span class="math">\(P_c=Q_c\)</span>.
With these assumptions one gets</p>
<div class="math">
\[\begin{split}\frac{d\bar Q}{d\bar t} &amp;= KE_0^{-1} (\bar E\bar S
- \bar Q),\\
\frac{d\bar P}{d\bar t} &amp;= \frac{k_v}{k_+ E_0}\bar Q,\\
\frac{d\bar S}{d\bar t} &amp;= -\bar E\bar S
+ \frac{k_-}{k_+E_0}\frac{E_0}{K}\bar Q,\\
\frac{d\bar E}{d\bar t} &amp;= -\epsilon^{-1}\bar E\bar S
+ \epsilon^{-1}\bar Q{\thinspace .}\end{split}\]</div>
<p>We can now identify the dimensionless numbers</p>
<div class="math">
\[\alpha = \frac{K}{E_0},\quad \beta = \frac{k_v}{k_+ E_0},
\quad \gamma = \frac{k_-}{k_+E_0},\]</div>
<p>where we see that <span class="math">\(\alpha = \beta + \gamma\)</span>, so <span class="math">\(\gamma\)</span> can be eliminated,
leading to the final set of equations:</p>
<div class="math" id="equation-scale:MMK:Q2">
<span id="eq-scale-mmk-q2"></span><span class="eqno">(46)</span>\[     \frac{d\bar Q}{d\bar t} = \alpha (\bar E\bar S
     - \bar Q),\]</div>
<div class="math" id="equation-scale:MMK:P2">
<span id="eq-scale-mmk-p2"></span><span class="eqno">(47)</span>\[     \frac{d\bar P}{d\bar t} = \beta\bar Q,\]</div>
<div class="math" id="equation-scale:MMK:S2">
<span id="eq-scale-mmk-s2"></span><span class="eqno">(48)</span>\[     \frac{d\bar S}{d\bar t} = -\bar E\bar S
     + (1 - \beta\alpha^{-1})\bar Q,\]</div>
<div class="math" id="equation-scale:MMK:E2">
<span id="eq-scale-mmk-e2"></span><span class="eqno">(49)</span>\[     \epsilon\frac{d\bar E}{d\bar t} = -\bar E\bar S + \bar Q{\thinspace .}\]</div>
<p>The five initial parameters (<span class="math">\(S_0\)</span>, <span class="math">\(E_0\)</span>, <span class="math">\(k_+\)</span>, <span class="math">\(k_-\)</span>, and <span class="math">\(k_v\)</span>)
are reduced to three dimensionless constants:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(\alpha\)</span> is the dimensionless Michaelis constant, reflecting the
ratio of the production of P and E (<span class="math">\(k_v+k_-\)</span>) versus the production of
the complex (<span class="math">\(k_+\)</span>), made dimensionless by <span class="math">\(E_0\)</span>,</li>
<li><span class="math">\(\epsilon\)</span> is the initial fraction of enzyme relative to the substrate,</li>
<li><span class="math">\(\beta\)</span> measures the relative importance of production of P (<span class="math">\(k_v\)</span>)
versus production of the complex (<span class="math">\(k_+\)</span>), made dimensionless by <span class="math">\(E_0\)</span>.</li>
</ul>
</div></blockquote>
<p>Observe that software developed for
solving <a href="#equation-scale:MMK:ES1">(39)</a>-<a href="#equation-scale:MMK:E1">(42)</a> cannot be reused
for solving <a href="#equation-scale:MMK:Q2">(46)</a>-<a href="#equation-scale:MMK:E2">(49)</a> since the latter
system has a slightly different structure.</p>
</div>
<div class="section" id="analysis-of-the-scaled-system">
<h4>Analysis of the scaled system<a class="headerlink" href="#analysis-of-the-scaled-system" title="Permalink to this headline">¶</a></h4>
<p>In the scaled system, we may assume <span class="math">\(\epsilon\)</span> small, which from
<a href="#equation-scale:MMK:E2">(49)</a> gives rise to the simplification
<span class="math">\(\epsilon\bar E^{\prime}=0\)</span>, and thereby the relation <span class="math">\(\bar Q = \bar E\bar S\)</span>.
The conservation equation <span class="math">\([ES] + [E]= E_0\)</span> reads <span class="math">\(Q_c\bar Q + E_0\bar E =
E_0\)</span> such that <span class="math">\(\bar E = 1 - Q_c\bar Q/E_0=1- \bar Q S_0/K = 1 - \epsilon^{-1}\alpha^{-1}\bar Q\)</span>. The relation <span class="math">\(\bar Q=\bar E\bar S\)</span> then becomes</p>
<div class="math">
\[\bar Q = (1 - \epsilon^{-1}\alpha^{-1}\bar Q)\bar S,\]</div>
<p>which can be solved for <span class="math">\(\bar Q\)</span>:</p>
<div class="math">
\[\bar Q = \frac{\bar S}{1 + \epsilon^{-1}\alpha^{-1}\bar S}{\thinspace .}\]</div>
<p>The equation <a href="#equation-scale:MMK:S2">(48)</a> for <span class="math">\(\bar S\)</span> becomes</p>
<div class="math" id="equation-scale:MMK:Seq2">
<span id="eq-scale-mmk-seq2"></span><span class="eqno">(50)</span>\[     \frac{d\bar S}{d\bar t} = -\beta\alpha^{-1}\bar Q =
     -\frac{\beta\bar S}{\alpha + \epsilon^{-1}\bar S}{\thinspace .}\]</div>
<p>This is a more precise analysis than the one leading to
<a href="#equation-scale:MMK:Seq1">(45)</a> since we now realize that the
mathematical assumption for the simplification is
<span class="math">\(\epsilon\rightarrow 0\)</span>.</p>
<p>Is <a href="#equation-scale:MMK:Seq2">(50)</a> consistent with <a href="#equation-scale:MMK:Seq1">(45)</a>? It is
easy to make algebraic mistakes when deriving scaled equations,
so it is always wise to carry out such consistency checks.
Introducing dimensions in <a href="#equation-scale:MMK:Seq2">(50)</a> leads to</p>
<div class="math">
\[\frac{t_c}{S_0}\frac{d S}{dt} =
\frac{d\bar S}{d\bar t}  =
-\frac{\beta\bar S}{\alpha + \epsilon^{-1}\bar S}
= \frac{k_v}{k_+E_0}\frac{S}{KE_0^{-1} + E_0^{-1}S_0\bar S}
= \frac{k_v}{k_+}\frac{\bar S}{K + S},\]</div>
<p>and hence with <span class="math">\(t_c^{-1}=k_+E_0\)</span>,</p>
<div class="math">
\[\frac{dS}{dt} = \frac{k_vE_0 S}{K + S},\]</div>
<p>which is <a href="#equation-scale:MMK:Seq1">(45)</a>.</p>
<p>Figure <a class="reference internal" href="#scale-mmk-fig"><span class="std std-ref">Simulation of a biochemical process</span></a> shows the impact of <span class="math">\(\epsilon\)</span>: with a small
value (0.1) we see that <span class="math">\(\bar Q\approx 0\)</span>, which justifies the
simplifications performed above. We also observe that all the unknowns
vary between 0 and about 1, indicating that the scaling is successful
for the chosen dimensionless numbers.</p>
<div class="figure" id="id7">
<span id="scale-mmk-fig"></span><a class="reference internal image-reference" href="_images/biochem.png"><img alt="_images/biochem.png" src="_images/biochem.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-text"><em>Simulation of a biochemical process</em></span></p>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">ODE models</a><ul>
<li><a class="reference internal" href="#exponential-decay-problems">Exponential decay problems</a><ul>
<li><a class="reference internal" href="#fundamental-ideas">Fundamental ideas</a></li>
<li><a class="reference internal" href="#the-basic-model-problem">The basic model problem</a><ul>
<li><a class="reference internal" href="#example-population-dynamics">Example: Population dynamics</a></li>
<li><a class="reference internal" href="#example-decay-of-pressure-with-altitude">Example: Decay of pressure with altitude</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-technical-steps-of-the-scaling-procedure">The technical steps of the scaling procedure</a><ul>
<li><a class="reference internal" href="#step-1-identify-independent-and-dependent-variables">Step 1: Identify independent and dependent variables</a></li>
<li><a class="reference internal" href="#step-2-make-independent-and-dependent-variables-dimensionless">Step 2: Make independent and dependent variables dimensionless</a></li>
<li><a class="reference internal" href="#step-3-derive-the-model-involving-only-dimensionless-variables">Step 3: Derive the model involving only dimensionless variables</a></li>
<li><a class="reference internal" href="#step-4-make-each-term-dimensionless">Step 4: Make each term dimensionless</a></li>
<li><a class="reference internal" href="#step-5-estimate-the-scales">Step 5: Estimate the scales</a></li>
</ul>
</li>
<li><a class="reference internal" href="#making-software-utilizing-the-dimensionless-model">Making software utilizing the dimensionless model</a><ul>
<li><a class="reference internal" href="#software-for-the-original-problem-with-dimensions">Software for the original problem with dimensions</a></li>
<li><a class="reference internal" href="#a-plain-solution">A plain solution</a></li>
<li><a class="reference internal" href="#simplifying-the-implementation-with-joblib">Simplifying the implementation with joblib</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scaling-a-generalized-problem">Scaling a generalized problem</a><ul>
<li><a class="reference internal" href="#exact-solution-1">Exact solution  (1)</a></li>
<li><a class="reference internal" href="#theory">Theory</a></li>
<li><a class="reference internal" href="#software-1">Software  (1)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#variable-coefficients">Variable coefficients</a></li>
<li><a class="reference internal" href="#scaling-a-cooling-problem-with-constant-surroundings">Scaling a cooling problem with constant surroundings</a></li>
<li><a class="reference internal" href="#scaling-a-cooling-problem-with-time-dependent-surroundings">Scaling a cooling problem with time-dependent surroundings</a><ul>
<li><a class="reference internal" href="#exact-solution-2">Exact solution  (2)</a></li>
<li><a class="reference internal" href="#scaling-1">Scaling  (1)</a></li>
<li><a class="reference internal" href="#software-2">Software  (2)</a></li>
<li><a class="reference internal" href="#discussion-of-the-time-scale-1">Discussion of the time scale  (1)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scaling-a-nonlinear-ode">Scaling a nonlinear ODE</a></li>
<li><a class="reference internal" href="#ode-systems-for-spreading-of-diseases">ODE systems for spreading of diseases</a><ul>
<li><a class="reference internal" href="#sir-model">SIR model</a></li>
<li><a class="reference internal" href="#sirv-model-with-finite-immunity">SIRV model with finite immunity</a></li>
</ul>
</li>
<li><a class="reference internal" href="#michaelis-menten-kinetics-for-biochemical-reactions">Michaelis-Menten kinetics for biochemical reactions</a><ul>
<li><a class="reference internal" href="#classical-analysis">Classical analysis</a></li>
<li><a class="reference internal" href="#dimensionless-ode-system">Dimensionless ODE system</a></li>
<li><a class="reference internal" href="#determining-scales">Determining scales</a></li>
<li><a class="reference internal" href="#analysis-of-the-scaled-system">Analysis of the scaled system</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book003.html"
                        title="previous chapter">Dimensions and units</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book005.html"
                        title="next chapter">Vibration problems</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book004.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book005.html" title="Vibration problems"
             >next</a> |</li>
        <li class="right" >
          <a href="._book003.html" title="Dimensions and units"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Scaling of Differential Equations</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2015, Hans Petter Langtangen. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>