
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ODE models</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Scaling of Differential Equations" href="index.html" />
    <link rel="next" title="Vibration problems" href="._book005.html" />
    <link rel="prev" title="Dimensions and units" href="._book003.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book005.html" title="Vibration problems"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book003.html" title="Dimensions and units"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Scaling of Differential Equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="ode-models">
<h1>ODE models<a class="headerlink" href="#ode-models" title="Permalink to this headline">¶</a></h1>
<p>This chapter introduces the basic techniques of scaling and the ways to
reason about scales. The first class of examples targets exponential
decay models, starting with the simple ordinary differential equation (ODE)
for exponential decay processes: <span class="math">\(u^{\prime}=-au\)</span>, with constant <span class="math">\(a&gt;0\)</span>.
Then we progress to various generalizations of this ODE, including nonlinear
versions and systems of ODEs. The next class of examples concerns
second-order ODEs for oscillatory systems, where the simplest
ODE reads <span class="math">\(mu^{\prime\prime} + ku=0\)</span>, with <span class="math">\(m\)</span> and <span class="math">\(k\)</span> as positive constants.
Various extensions with damping and force terms are discussed in detail.</p>
<div class="section" id="exponential-decay-problems">
<span id="sec-scale-decay"></span><h2>Exponential decay problems<a class="headerlink" href="#exponential-decay-problems" title="Permalink to this headline">¶</a></h2>
<div class="section" id="fundamental-ideas">
<h3>Fundamental ideas<a class="headerlink" href="#fundamental-ideas" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-0"></span><p id="index-1">Scaling is an extremely useful technique in mathematical modeling and
numerical simulation.  The purpose of the technique is three-fold:</p>
<ol class="arabic simple">
<li>Make independent and dependent variables dimensionless.</li>
<li>Make the size of independent and dependent variables about unity.</li>
<li>Reduce the number of independent physical parameters in the model.</li>
</ol>
<p id="index-2">The first and second item mean that for any variable, denote it by
<span class="math">\(q\)</span>, we introduce a corresponding dimensionless variable</p>
<div class="math">
\[\bar q = \frac{q-q_0}{q_c},\]</div>
<p>where <span class="math">\(q_0\)</span> is a reference value of <span class="math">\(q\)</span> (<span class="math">\(q_0=0\)</span> is a common choice) and
<span class="math">\(q_c\)</span> is a characteristic size of <span class="math">\(|q|\)</span>. Since the numerator and denominator
have the same dimension, <span class="math">\(\bar q\)</span> becomes a dimensionless number.</p>
<p>If <span class="math">\(q_c\)</span> is the maximum value of <span class="math">\(|q-q_0|\)</span>, we see that <span class="math">\(0 &lt; |\bar
q|\leq 1\)</span>. How to find <span class="math">\(q_c\)</span> is sometimes the big challenge of
scaling. Examples will illustrate various approaches to meet this
challenge.</p>
<p>The forthcoming text has the following goals.</p>
<blockquote>
<div><ul class="simple">
<li>Teach the technical steps of making a mathematical model, based
on differential equations, dimensionless.</li>
<li>Describe various techniques for reasoning about the scales, i.e.,
finding the characteristic sizes of quantities.</li>
<li>Teach how to identify and interpret dimensionless numbers arising
from the scaling process.</li>
<li>Provide a lot of different examples on making models dimensionless
with physically correct scales.</li>
<li>Demonstrate software tools for computing with numbers with units,
including doing unit conversions.</li>
<li>Introduce software tools for creating user interfaces that
can automatically perform unit conversion.</li>
<li>Use symbolic software (SymPy) to derive exact solutions of differential
equations.</li>
<li>Explain how to run a dimensionless model with software developed
for the problem with dimensions.</li>
</ul>
</div></blockquote>
<div class="admonition-what-this-book-is-and-is-not admonition">
<p class="first admonition-title">What this book is and is not</p>
<p>Books covering scaling and non-dimensionalization very often cover
topics not treated in the present book. One key topic is
dimensional analysis and the famous Buckingham Pi Theorem
<a class="reference internal" href="._book010.html#ref04" id="id1">[Ref04]</a> <a class="reference internal" href="._book010.html#ref05" id="id2">[Ref05]</a>, which
can be used to derive the dimensionless numbers in a given problem
without the need for a detailed model with differential equations.
This is a strong statement of great
practical significance, especially when doing physical experiments.
However, as will be shown in this book, the dimensionless numbers in
a problem also arise, in a very natural way,
from scaling the differential equation(s).
Provided one has a model based on differential equation, there is
actually no need for classical dimensional analysis.</p>
<p>Other classical topics closely related to scaling and non-dimensionalization
are analytical solution methods like perturbation techniques and
similarity solutions. These are not addressed in this book.
There are numerous texts on perturbation techniques, and these build
on an already scaled differential equations. Similarity solutions do not
fit within the present scope since these involve non-dimensional
<em>combinations of the independent variables</em> to derive new differential
equations that are easier to solve.</p>
<p class="last">Our scope is to scale differential
equations to simplify the setting of parameters in numerical simulations,
and at the same time understand more of the physics
through interpretation of the dimensionless numbers that automatically
arise from the scaling procedure.</p>
</div>
</div>
<div class="section" id="the-basic-model-problem">
<h3>The basic model problem<a class="headerlink" href="#the-basic-model-problem" title="Permalink to this headline">¶</a></h3>
<p id="index-3">Processes undergoing exponential reduction can be modeled by the ODE
problem</p>
<div class="math" id="eq-scale-decay-model">
\[\tag{2}
u'(t) = -au(t),\quad u(0)=I,\]</div>
<p>where <span class="math">\(a,I&gt;0\)</span> are prescribed constants and <span class="math">\(u(t)\)</span> is the unknown function.
For this particular model, we can easily derive the solution, <span class="math">\(u(t)=Ie^{-at}\)</span>,
which is helpful to have in mind during the scaling process.</p>
<div class="section" id="example-population-dynamics">
<h4>Example: Population dynamics<a class="headerlink" href="#example-population-dynamics" title="Permalink to this headline">¶</a></h4>
<p>The evolution of a population of humans, animals, cells, etc.,
under unlimited access to resources, can be
modeled by <a class="reference internal" href="#eq-scale-decay-model"><span class="std std-ref">(2)</span></a>. Then <span class="math">\(u\)</span> is the number of
individuals in the population, strictly speaking an integer, but well
modeled by a real number in large populations.
The parameter <span class="math">\(a\)</span> is the increase in the number of individuals per
time and per individual.</p>
</div>
<div class="section" id="example-decay-of-pressure-with-altitude">
<h4>Example: Decay of pressure with altitude<a class="headerlink" href="#example-decay-of-pressure-with-altitude" title="Permalink to this headline">¶</a></h4>
<p>The simple model <a class="reference internal" href="#eq-scale-decay-model"><span class="std std-ref">(2)</span></a> also governs the pressure
in the atmosphere (under many assumptions, such as an ideal gas in
equilibrium). In this case <span class="math">\(u\)</span> is the
pressure, measured in <span class="math">\(\hbox{Nm}^{-2}\)</span>; <span class="math">\(t\)</span> is the hight in meters;
and <span class="math">\(a=M/(R^*T)\)</span>, where
<span class="math">\(M\)</span> is the molar mass of the Earth&#8217;s air (0.029 kg/mol),
<span class="math">\(R^*\)</span> is the universal
gas constant (<span class="math">\(8.314\,\frac{\hbox{Nm}}{\hbox{mol K}}\)</span>),
and <span class="math">\(T\)</span> is the temperature in Kelvin (K).
The temperature depends on the hight so we have <span class="math">\(a=a(t)\)</span>.</p>
</div>
</div>
<div class="section" id="the-technical-steps-of-the-scaling-procedure">
<span id="sec-scale-decay-steps"></span><h3>The technical steps of the scaling procedure<a class="headerlink" href="#the-technical-steps-of-the-scaling-procedure" title="Permalink to this headline">¶</a></h3>
<div class="section" id="step-1-identify-independent-and-dependent-variables">
<h4>Step 1: Identify independent and dependent variables<a class="headerlink" href="#step-1-identify-independent-and-dependent-variables" title="Permalink to this headline">¶</a></h4>
<p>There is one independent variable, time <span class="math">\(t\)</span>, and one dependent variable,
<span class="math">\(u\)</span>.</p>
<span class="target" id="index-4"></span></div>
<div class="section" id="step-2-make-independent-and-dependent-variables-dimensionless">
<span id="index-5"></span><h4>Step 2: Make independent and dependent variables dimensionless<a class="headerlink" href="#step-2-make-independent-and-dependent-variables-dimensionless" title="Permalink to this headline">¶</a></h4>
<p>We introduce a new dimensionless <span class="math">\(t\)</span>, called <span class="math">\(\bar t\)</span>, defined by</p>
<div class="math" id="eq-auto1">
\[\tag{3}
\bar t = \frac{t}{t_c},\]</div>
<p>where <span class="math">\(t_c\)</span> is a <em>characteristic value</em> of <span class="math">\(t\)</span>. Similarly,
we introduce a dimensionless <span class="math">\(u\)</span>, named <span class="math">\(\bar u\)</span>, according to</p>
<div class="math" id="eq-auto2">
\[\tag{4}
\bar u = \frac{u}{u_c},\]</div>
<p>where <span class="math">\(u_c\)</span> is a constant <em>characteristic size</em> of <span class="math">\(u\)</span>. When <span class="math">\(u\)</span> has a specific
interpretation, say when <a class="reference internal" href="#eq-scale-decay-model"><span class="std std-ref">(2)</span></a> models pressure
in an atmospheric layer, <span class="math">\(u_c\)</span> would be referred to as characteristic pressure.
For a decaying population, <span class="math">\(u_c\)</span> may be a characteristic number of
members in the population, e.g., the initial population <span class="math">\(I\)</span>.</p>
</div>
<div class="section" id="step-3-derive-the-model-involving-only-dimensionless-variables">
<h4>Step 3: Derive the model involving only dimensionless variables<a class="headerlink" href="#step-3-derive-the-model-involving-only-dimensionless-variables" title="Permalink to this headline">¶</a></h4>
<p>The next task is to insert the new dimensionless variables in the
governing mathematical model. That is, we replace <span class="math">\(t\)</span> by <span class="math">\(t_c\bar t\)</span>
and <span class="math">\(u\)</span> by <span class="math">\(u_c\bar u\)</span> in <a class="reference internal" href="#eq-scale-decay-model"><span class="std std-ref">(2)</span></a>. The derivative
with respect to <span class="math">\(\bar t\)</span> is derived as</p>
<div class="math">
\[\frac{du}{dt} = \frac{d (u_c\bar u)}{d\bar t}\frac{d\bar t}{dt}
= u_c\frac{d\bar u}{d\bar t}\frac{1}{t_c} =
\frac{u_c}{t_c}\frac{d\bar u}{d\bar t}{\thinspace .}\]</div>
<p>The model <a class="reference internal" href="#eq-scale-decay-model"><span class="std std-ref">(2)</span></a> now becomes</p>
<div class="math" id="eq-scale-decay-model-scaled0">
\[\tag{5}
\frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = -au_c\bar u,\quad u_c\bar u(0)=I{\thinspace .}\]</div>
</div>
<div class="section" id="step-4-make-each-term-dimensionless">
<h4>Step 4: Make each term dimensionless<a class="headerlink" href="#step-4-make-each-term-dimensionless" title="Permalink to this headline">¶</a></h4>
<p>Equation <a class="reference internal" href="#eq-scale-decay-model-scaled0"><span class="std std-ref">(5)</span></a> still has terms with
dimensions. To make each term dimensionless, we usually divide by
the coefficient in front of the term with the highest time derivative
(but dividing by any coefficient in any term will do). The result is</p>
<div class="math" id="eq-scale-decay-model-dimless0">
\[\tag{6}
\frac{d\bar u}{d\bar t} = -at_c\bar u,\quad \bar u(0)=u_c^{-1}I
    {\thinspace .}\]</div>
</div>
<div class="section" id="step-5-estimate-the-scales">
<h4>Step 5: Estimate the scales<a class="headerlink" href="#step-5-estimate-the-scales" title="Permalink to this headline">¶</a></h4>
<p>A characteristic quantity like <span class="math">\(t_c\)</span> reflects the time scale in the
problem. Estimating such a time scale is certainly
the most challenging part of the scaling procedure. There are different
ways to reason. The first is to aim at a size of <span class="math">\(\bar u\)</span> and its derivatives
that is of order unity. If <span class="math">\(u_c\)</span> is chosen such that <span class="math">\(|\bar u|\)</span> is
of size unity, we see from <a class="reference internal" href="#eq-scale-decay-model-dimless0"><span class="std std-ref">(6)</span></a> that
<span class="math">\(d\bar u/d\bar t\)</span> is of the size of <span class="math">\(\bar u\)</span> (i.e., unity)
if we choose <span class="math">\(t_c = 1/a\)</span>.</p>
<p id="index-6">Alternatively, we may look at a special case of the model where we have
analytical insight. In the present problem we are lucky to know the
exact solution for any value of the input data. For exponential
decay, <span class="math">\(u(t)\sim e^{-at}\)</span>, it is common to define a characteristic time
scale <span class="math">\(t_c\)</span> as the time it takes to reduce <span class="math">\(u\)</span> by a factor of <span class="math">\(1/e\)</span> (also
called the <em>e-folding time</em>):</p>
<div class="math">
\[e^{-at_c} = \frac{1}{e}e^{-a\cdot 0}\quad\Rightarrow\quad e^{-at_c}=e^{-1},\]</div>
<p>from which it follows that <span class="math">\(t_c = 1/a\)</span>.</p>
<p>In this example, two different, yet common ways of reasoning, lead to the
same value of <span class="math">\(t_c\)</span>. However, instead of using the e-folding time we
could use the half-time of the exponential decay as characteristic
time, which is also a very common measure of the time scale in such
processes. The half time is defined as the time it takes to halve <span class="math">\(u\)</span>:</p>
<div class="math">
\[e^{-at_c} = \frac{1}{2}e^{-a\cdot 0}
\quad\Rightarrow\quad t_c = a^{-1}\ln 2{\thinspace .}\]</div>
<p>There is a factor <span class="math">\(\ln 2 =0.69\)</span> difference from the other <span class="math">\(t_c\)</span> value.
As long as the factor is not an order of magnitude or more different,
we do not pay attention to such small differences.
Although <span class="math">\(t_c = a^{-1}\ln 2\)</span> is a fine time scale to be used in this
problem, it leads to a scaled differential equation <span class="math">\(u'=-(\ln 2) u\)</span>,
which is fine, but an unusual form. People tend to prefer the simpler
ODE <span class="math">\(u'=-u\)</span>,
which arises from <span class="math">\(t_c=1/a\)</span>, and we shall therefore use this
time scale.</p>
<p>Regarding <span class="math">\(u_c\)</span>, we may look at the initial condition
and realize that the choice <span class="math">\(u_c=I\)</span> makes <span class="math">\(\bar u(0)=1\)</span>. For <span class="math">\(\bar t&gt;0\)</span>
we know that <span class="math">\(\bar u\)</span> is decreasing, so <span class="math">\(u_c=I\)</span>
gives us <span class="math">\(\bar u\leq 1\)</span>, which is always a goal
(alternatively, we may look to analytical insight, <span class="math">\(u(t)=Ie^{-at}\)</span>, to
see that <span class="math">\(u\leq I\)</span>, such that <span class="math">\(u_c=I\)</span> gives <span class="math">\(\bar u\leq 1\)</span>).</p>
<p>With <span class="math">\(t_c=1/a\)</span> and <span class="math">\(u_c=I\)</span>, we have the final dimensionless model</p>
<div class="math" id="eq-scale-decay-model-dimless">
\[\tag{7}
\frac{d\bar u}{d\bar t} = -\bar u,\quad \bar u(0)=1
    {\thinspace .}\]</div>
<p>This is a remarkable result in the sense that <em>all physical parameters</em>
(<span class="math">\(a\)</span> and <span class="math">\(I\)</span>)
are removed from the model! Or more precisely, there are no physical input
parameters to assign
before using the model. In particular, numerical investigations of the original
model <a class="reference internal" href="#eq-scale-decay-model"><span class="std std-ref">(2)</span></a> would need experiments with different
<span class="math">\(a\)</span> and <span class="math">\(I\)</span> values, while numerical investigations of
<a class="reference internal" href="#eq-scale-decay-model-dimless"><span class="std std-ref">(7)</span></a> can be limited to <em>a single run</em>! As soon
as we have computed the curve <span class="math">\(\bar u(\bar t)\)</span>, we can find the
solution <span class="math">\(u(t)\)</span> of <a class="reference internal" href="#eq-scale-decay-model"><span class="std std-ref">(2)</span></a> by</p>
<div class="math" id="eq-scale-decay-u-dim">
\[\tag{8}
u(t) = u_c\bar u(t/t_c) = I\bar u(at)
    {\thinspace .}\]</div>
<p>This particular transformation actually means stretching the <span class="math">\(\bar t\)</span> and
<span class="math">\(\bar u\)</span> axes in a plot of <span class="math">\(\bar u(\bar t)\)</span> by the factors <span class="math">\(a\)</span> and <span class="math">\(I\)</span>,
respectively.</p>
<p>It is very common to drop the bars when the scaled problem has been
derived and work further with <a class="reference internal" href="#eq-scale-decay-model-dimless"><span class="std std-ref">(7)</span></a> simply
written as</p>
<div class="math">
\[\frac{du}{dt} = -u,\quad u(0)=1
{\thinspace .}\]</div>
<p>Nevertheless, in this book we have decided to stick to bars for all
dimensionless quantities.</p>
</div>
</div>
<div class="section" id="making-software-for-utilizing-the-scaled-model">
<span id="sec-scale-decay-prog"></span><h3>Making software for utilizing the scaled model<a class="headerlink" href="#making-software-for-utilizing-the-scaled-model" title="Permalink to this headline">¶</a></h3>
<p>Software for solving <a class="reference internal" href="#eq-scale-decay-model"><span class="std std-ref">(2)</span></a> could take advantage
of the fact that only one simulation of <a class="reference internal" href="#eq-scale-decay-model-dimless"><span class="std std-ref">(7)</span></a>
is necessary. As soon as we have <span class="math">\(\bar u(\bar t)\)</span> accessible,
a simple scaling <a class="reference internal" href="#eq-scale-decay-u-dim"><span class="std std-ref">(8)</span></a> computes the real <span class="math">\(u(t)\)</span>
for any given input data <span class="math">\(a\)</span> and <span class="math">\(I\)</span>. Although the numerical computation of
<span class="math">\(u(t)\)</span> from <a class="reference internal" href="#eq-scale-decay-model"><span class="std std-ref">(2)</span></a> is very fast in this simple model
problem, using <a class="reference internal" href="#eq-scale-decay-u-dim"><span class="std std-ref">(8)</span></a> is very much faster than
computing a full numerical solution in more complicated
differential equation problems.</p>
<p>We can compute with the dimensionless model <a class="reference internal" href="#eq-scale-decay-model-dimless"><span class="std std-ref">(7)</span></a>
in two ways, either make a solver for <a class="reference internal" href="#eq-scale-decay-model-dimless"><span class="std std-ref">(7)</span></a>
or reuse a solver for <a class="reference internal" href="#eq-scale-decay-model"><span class="std std-ref">(2)</span></a> with the parameters
appropriately set (<span class="math">\(I=1\)</span>, <span class="math">\(a=1\)</span>).
The latter approach has the advantage of giving us
software that works both with a dimensionless model and a model
with dimensions and all the original physical parameters.</p>
<div class="section" id="software-for-the-original-problem-with-dimensions">
<h4>Software for the original problem with dimensions<a class="headerlink" href="#software-for-the-original-problem-with-dimensions" title="Permalink to this headline">¶</a></h4>
<p>We base our solver for
<a class="reference internal" href="#eq-scale-decay-model-dimless"><span class="std std-ref">(7)</span></a> on a solver for <a class="reference internal" href="#eq-scale-decay-model"><span class="std std-ref">(2)</span></a>.
Assume that we have some module <code class="docutils literal"><span class="pre">decay.py</span></code> that offers the following
functions:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">solver(I,</span> <span class="pre">a,</span> <span class="pre">T,</span> <span class="pre">dt,</span> <span class="pre">theta=0.5)</span></code> for returning the solution arrays
<code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">t</span></code> for <a class="reference internal" href="#eq-scale-decay-model"><span class="std std-ref">(2)</span></a> solved by the so-called
<span class="math">\(\theta\)</span> rule. This rule includes the Forward Euler scheme (<span class="math">\(\theta=0\)</span>),
the Backward Euler scheme (<span class="math">\(\theta=1\)</span>), or the Crank-Nicolson
(centered midpoint) scheme (<span class="math">\(\theta=\frac{1}{2}\)</span>).</li>
<li><code class="docutils literal"><span class="pre">read_command_line_argparse()</span></code> for reading parameters in the problem
from the command line and returning them: <code class="docutils literal"><span class="pre">I</span></code>, <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">T</span></code>, <code class="docutils literal"><span class="pre">theta</span></code> (<span class="math">\(\theta\)</span>),
and a list of <span class="math">\(\Delta t\)</span> values for time steps. (We shall only make
use of the first <span class="math">\(\Delta t\)</span> value.)</li>
</ul>
</div></blockquote>
<p>The basic statements for solving <a class="reference internal" href="#eq-scale-decay-model"><span class="std std-ref">(2)</span></a> are
then</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">decay</span> <span class="kn">import</span> <span class="n">solver</span><span class="p">,</span> <span class="n">read_command_line_argparse</span>
<span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line_argparse</span><span class="p">()</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">plot</span><span class="p">,</span> <span class="n">show</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The module <a class="reference external" href="http://tinyurl.com/o8pb3yy/decay.py">decay.py</a> is developed
and explained in</p>
<p>Section refaux{softeng1:basic:module} in
the book <a class="reference external" href="http://tinyurl.com/nclmcng/doc/pub/book">Finite Difference Computing with Exponential Decay Models</a> <a class="reference internal" href="._book010.html#ref06" id="id3">[Ref06]</a>.</p>
<p>To solve the dimensionless problem, just fix <span class="math">\(I=1\)</span> and <span class="math">\(a=1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line_argparse</span><span class="p">()</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="avoiding-unnecessary-computations">
<h4>Avoiding unnecessary computations<a class="headerlink" href="#avoiding-unnecessary-computations" title="Permalink to this headline">¶</a></h4>
<p>A key observation, as mentioned, is that we need to solve the problem
<a class="reference internal" href="#eq-scale-decay-model-dimless"><span class="std std-ref">(7)</span></a> only once. All solutions
corresponding to different <span class="math">\(I\)</span> and <span class="math">\(a\)</span> values in the original physical
problem can be recovered by scaling this single solution with formula
<a class="reference internal" href="#eq-scale-decay-u-dim"><span class="std std-ref">(8)</span></a>.  We may therefore want to make software that
takes advantage of this fact. When requesting a solution, we see if it
has already been computed and stored in a file, and if so, the data
can be retrieved from file, otherwise we have to compute a new
solution and store it in a file.</p>
<p>A very plain solution to the problem is found in the file
<a class="reference external" href="http://tinyurl.com/o8pb3yy/decay_scaled_v1.py">decay_scaled_v1.py</a>.
The <code class="docutils literal"><span class="pre">np.savetxt</span></code> function saves a two-dimensional arrays (&#8220;table&#8221;) to
a text file, and the <code class="docutils literal"><span class="pre">np.loadtxt</span></code> function can load the data back
into the program. A better solution to this problem is obtained
by using the <code class="docutils literal"><span class="pre">joblib</span></code> package as described next.</p>
<span class="target" id="index-7"></span></div>
<div class="section" id="implementation-with-joblib">
<span id="index-8"></span><h4>Implementation with joblib<a class="headerlink" href="#implementation-with-joblib" title="Permalink to this headline">¶</a></h4>
<p>The Python package <code class="docutils literal"><span class="pre">joblib</span></code> has functionality that is very convenient
for implementing the <code class="docutils literal"><span class="pre">solver_scaled</span></code> function. The first time a
function is called with a set of arguments, the statements in the
function are executed and the return value is saved to file. If the
function is called again with the same set of arguments, the
statements in the function are not executed, but the return value is
read from file. In computer science, one would say that <code class="docutils literal"><span class="pre">joblib</span></code> in
this way provides <em>memorization</em> functionality for Python functions.
This functionality is particularly aimed at large-scale computations
with arrays that one would like to avoid being recomputed. We
illustrate the technique here in a very simple mathematical context.</p>
<p>First we make a <code class="docutils literal"><span class="pre">solver_scaled</span></code> function for the scaled
model that just calls up a <code class="docutils literal"><span class="pre">solver_unscaled</span></code> for the problem with
dimensions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">decay</span> <span class="kn">import</span> <span class="n">solver_unscaled</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">solver_scaled</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-u, u(0)=1 for (0,T] with step dt and theta method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s">&#39;Computing the numerical solution&#39;</span>
    <span class="k">return</span> <span class="n">solver_unscaled</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we create some &#8220;computer memory on disk&#8221;, i.e., some disk space to
store the result of a call to the <code class="docutils literal"><span class="pre">solver_scaled</span></code> function. Thereafter,
we redefine the name <code class="docutils literal"><span class="pre">solver_scaled</span></code> to a new function, created
by <code class="docutils literal"><span class="pre">joblib</span></code>, which calls our original <code class="docutils literal"><span class="pre">solver_scaled</span></code> function
if necessary and otherwise loads data from file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">joblib</span>
<span class="n">disk_memory</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">Memory</span><span class="p">(</span><span class="n">cachedir</span><span class="o">=</span><span class="s">&#39;temp&#39;</span><span class="p">)</span>
<span class="n">solver_scaled</span> <span class="o">=</span> <span class="n">disk_memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">solver_scaled</span><span class="p">)</span>
</pre></div>
</div>
<p>The solutions are actually stored in files in the cache directory <code class="docutils literal"><span class="pre">temp</span></code>.</p>
<p>A typical use case is to read values from the command line,
solve the unscaled problem (if necessary), scale the solution, and visualize
the solution with dimension:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">decay</span> <span class="kn">import</span> <span class="n">unscale</span><span class="p">,</span> <span class="n">read_command_line_argparse</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c"># Read parameters, solve and plot</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line_argparse</span><span class="p">()</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># use only the first dt value</span>
    <span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span> <span class="o">=</span> <span class="n">solver_scaled</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">unscale</span><span class="p">(</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_scaled</span><span class="p">,</span> <span class="n">u_scaled</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;scaled time&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;scaled velocity&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Universial solution of scaled problem&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp1.png&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp1.pdf&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;I=</span><span class="si">%g</span><span class="s">, a=</span><span class="si">%g</span><span class="s">, theta=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp2.png&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp2.pdf&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The complete code resides in the file
<a class="reference external" href="http://tinyurl.com/o8pb3yy/decay_scaled.py">decay_scaled.py</a>.
A plot of the scaled and unscaled solution appears in Figure
<a class="reference internal" href="#sec-decay-fig-simplest"><span class="std std-ref">Scaled (left) and unscaled (right) exponential decay</span></a>.</p>
<div class="figure" id="id5">
<span id="sec-decay-fig-simplest"></span><a class="reference internal image-reference" href="_images/decay.png"><img alt="_images/decay.png" src="_images/decay.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Scaled (left) and unscaled (right) exponential decay</em></span></p>
</div>
<p>Note that we write a message <code class="docutils literal"><span class="pre">Computing</span> <span class="pre">the</span> <span class="pre">numerical</span> <span class="pre">solution</span></code> inside
the <code class="docutils literal"><span class="pre">solver_scaled</span></code> function. We can then easily detect when
the solution is actually computed and when it is simply read from file.
Here is a demo:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; # Very first run
Terminal&gt; python decay_scaled.py --T 7 --a 1 --I 0.5 --dt 0.2
[Memory] Calling __main__--home-hpl...
solver_scaled-alias(7.0, 0.2, 0.5)
Computing the numerical solution

Terminal&gt; # No change of T, dt, theta - can reuse solution in file
Terminal&gt; python decay_scaled.py --T 7 --a 4 --I 2.5 --dt 0.2

Terminal&gt; # Change of dt, must recompute
Terminal&gt; python decay_scaled.py --T 7 --a 4 --I 2.0 --dt 0.5
[Memory] Calling __main__--home-hpl...
solver_scaled-alias(7.0, 0.5, 0.5)
Computing the numerical solution

Terminal&gt; # Change of dt again, but dt=0.2 is already in a file
Terminal&gt; python decay_scaled.py --T 7 --a 0.5 --I 1 --dt 0.2
</pre></div>
</div>
<p>We realize that <code class="docutils literal"><span class="pre">joblib</span></code> has access to all previous runs and does not
recompute unless it is strictly required. Our previous implementation
without <code class="docutils literal"><span class="pre">joblib</span></code>
used only one file (for one numerical case)
and will therefore perform many more calls to
<code class="docutils literal"><span class="pre">solver_unscaled</span></code>.</p>
<div class="admonition-on-the-implementation-of-a-simple-memoize-function admonition">
<p class="first admonition-title">On the implementation of a simple memoize function</p>
<p>A memoized function recalls
previous results when the same set
of arguments is encountered. That is, the function caches its results.
A simple implementation stores the arguments in a function call and
the returned results in a
dictionary, and if the arguments are seen again, one looks up
in the dictionary and return previously computed results:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Memoize</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># map arguments to results</span>

<span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">args</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">args</span><span class="p">]</span>

<span class="c"># Wrap my_compute_function(arg1, arg2, ...)</span>
<span class="n">my_compute_function</span> <span class="o">=</span> <span class="n">Memoize</span><span class="p">(</span><span class="n">my_compute_function</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">The memoize functionality in <code class="docutils literal"><span class="pre">joblib.Memory</span></code> is more sophisticated and
can work very efficiently with large array data structures as arguments.
Note that the simple version above can only be used when all arguments to
the function <code class="docutils literal"><span class="pre">f</span></code> are immutable (since the key in a dictionary has to be
immutable).</p>
</div>
</div>
</div>
<div class="section" id="scaling-a-generalized-problem">
<span id="sec-scale-decay-body"></span><h3>Scaling a generalized problem<a class="headerlink" href="#scaling-a-generalized-problem" title="Permalink to this headline">¶</a></h3>
<p>Now we consider an extension of the exponential decay ODE to the
form</p>
<div class="math" id="eq-scale-decay-model-g">
\[\tag{9}
u'(t) = -au(t) + b,\quad u(0)=I\]\[    {\thinspace .}\]</div>
<p>One particular model, with constant <span class="math">\(a\)</span> and <span class="math">\(b\)</span>,
is a spherical micro-organism falling in air,</p>
<div class="math" id="eq-scale-decay-model-g-spec">
\[\tag{10}
u' = - \frac{3\pi d\mu}{\varrho_b V} u + g\left(\frac{\varrho}{\varrho_b} -1\right),\]</div>
<p>where <span class="math">\(d\)</span>, <span class="math">\(\mu\)</span>, <span class="math">\(\varrho_b\)</span>, <span class="math">\(\varrho\)</span>, <span class="math">\(V\)</span>, and <span class="math">\(g\)</span> are physical
parameters. The function <span class="math">\(u(t)\)</span> represents the vertical velocity,
being positive upwards.
We shall use this model in the following.</p>
<div class="section" id="exact-solution-1">
<h4>Exact solution<a class="headerlink" href="#exact-solution-1" title="Permalink to this headline">¶</a></h4>
<p>It can be handy to have the exact solution for reference, in case
of constant <span class="math">\(a\)</span> and <span class="math">\(b\)</span>:</p>
<div class="math">
\[{u_{\small\mbox{e}}}(t) = \frac{e^{-at}}{a}\left( b(e^{at}-1) + aI\right)
{\thinspace .}\]</div>
<div class="admonition-solving-differential-equations-in-sympy admonition">
<p class="first admonition-title">Solving differential equations in SymPy</p>
<p>It can be very useful to use a symbolic computation tool such as SymPy
to aid us in solving differential equations.
Let us therefore demonstrate how SymPy can be used to find this solution.
First we define the parameters in the problem as symbols
and <span class="math">\(u(t)\)</span> as a function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t a b I&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
</pre></div>
</div>
<p>The next task is to define the differential equation, either as
a symbolic expression that is to equal zero, or as
an equation <code class="docutils literal"><span class="pre">Eq(lhs,</span> <span class="pre">rhs)</span></code> with <code class="docutils literal"><span class="pre">lhs</span></code> and <code class="docutils literal"><span class="pre">rhs</span></code> as expressions for
the left- and right-hand side):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Define differential equation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">),</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The differential equation can be solved by the <code class="docutils literal"><span class="pre">dsolve</span></code> function, yielding
an equation of the form <code class="docutils literal"><span class="pre">u(t)</span> <span class="pre">==</span> <span class="pre">expression</span></code>. We want to grab the
expression on the right-hand side as our solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sol</span>
<span class="go">u(t) == (b + exp(a*(C1 - t)))/a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span>                    <span class="c"># grab solution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">u</span>
<span class="go">(b + exp(a*(C1 - t)))/a</span>
</pre></div>
</div>
<p>The solution contains the unknown integration constant <code class="docutils literal"><span class="pre">C1</span></code>, which must
be determined by the initial condition. We form the equation arising
from the initial condition <span class="math">\(u(0)=I\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">I</span><span class="p">)</span>   <span class="c"># substitute t by 0 in u</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">C1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sol</span>
<span class="go">[log(I*a - b)/a]</span>
</pre></div>
</div>
<p>The one solution that was found (stored in a list!)
must then be substituted back in the
expression <code class="docutils literal"><span class="pre">u</span></code> to yield the final solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">u</span>
<span class="go">(b + exp(a*(-t + log(I*a - b)/a)))/a</span>
</pre></div>
</div>
<p>As in mathematics with pen and paper, we strive to simplify
expressions also in symbolic computing software.
This frequently requires some trial and error
process with SymPy&#8217;s simplification functions. A very standard
first try is to expand everything and run simplification algorithms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">u</span>
<span class="go">(I*a + b*exp(a*t) - b)*exp(-a*t)/a</span>
</pre></div>
</div>
<p class="last">Doing <code class="docutils literal"><span class="pre">latex(u)</span></code> automatically converts the expression to LaTeX syntax
for inclusion in reports.</p>
</div>
</div>
<div class="section" id="theory">
<h4>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h4>
<p>The challenges in our scaling is to find the right <span class="math">\(u_c\)</span> and <span class="math">\(t_c\)</span>
scales. From <a class="reference internal" href="#eq-scale-decay-model-g"><span class="std std-ref">(9)</span></a> we see that if <span class="math">\(u'\rightarrow 0\)</span>
as <span class="math">\(t\rightarrow\infty\)</span>, <span class="math">\(u\)</span> approaches the constant value <span class="math">\(b/a\)</span>. It can be
convenient to let the scaled <span class="math">\(\bar u\rightarrow 1\)</span> as
we approach the <span class="math">\(d\bar u/d\bar t = 0\)</span> state. This idea points to choosing</p>
<div class="math" id="eq-auto3">
\[\tag{11}
u_c = \frac{b}{a} = g\left(\frac{\varrho}{\varrho_b} -1\right)\left(\frac{3\pi d\mu}{\varrho_b V}\right)^{-1}
    {\thinspace .}\]</div>
<div class="admonition-on-the-sign-of-the-scaled-velocity admonition">
<p class="first admonition-title">On the sign of the scaled velocity</p>
<p class="last">A little note on the sign of <span class="math">\(u_c\)</span> is necessary here.
With <span class="math">\(\varrho_b &lt; \varrho\)</span>, the buoyancy force upwards wins over the
gravity force downwards, and the body will move upwards. In this case,
the terminal velocity <span class="math">\(u_c &gt; 0\)</span>. When <span class="math">\(\varrho_b &gt; \varrho\)</span>, we get
a motion downwards, and <span class="math">\(u_c &lt; 0\)</span>. The corresponding <span class="math">\(u\)</span> is then also
negative, but the scaled velocity <span class="math">\(u/u_c\)</span>, becomes positive.</p>
</div>
<p id="index-9">Inserting <span class="math">\(u = u_c\bar u = b\bar u/a\)</span> and <span class="math">\(t=t_c\bar t\)</span> in
<a class="reference internal" href="#eq-scale-decay-model-g"><span class="std std-ref">(9)</span></a> leads to</p>
<div class="math">
\[\frac{d\bar u}{d\bar t} = -t_c a\bar u + \frac{t_c}{u_c}b,
\quad \bar u(0) = I\frac{a}{b}
{\thinspace .}\]</div>
<p>We want the scales such that <span class="math">\(d\bar u/d\bar t\)</span> and <span class="math">\(\bar u\)</span> are
about unity.
To balance the size of <span class="math">\(\bar u\)</span> and <span class="math">\(d\bar u/d\bar t\)</span> we must
therefore choose
<span class="math">\(t_c = 1/a\)</span>, resulting in the scaled ODE problem</p>
<div class="math" id="eq-scale-decay-model-g-dimless">
\[\tag{12}
\frac{d\bar u}{d\bar t} = -\bar u + 1,\quad u(0)=\beta,\]</div>
<p>where <span class="math">\(\beta\)</span> is a dimensionless number,</p>
<div class="math" id="eq-auto4">
\[\tag{13}
\beta = \frac{I}{u_c} = I\frac{a}{b},\]</div>
<p>reflecting the ratio of the initial velocity and the
terminal (<span class="math">\(t\rightarrow \infty\)</span>) velocity <span class="math">\(b/a\)</span>.
Scaling normally ends up with one or more dimensionless parameters,
such as <span class="math">\(\beta\)</span> here, containing ratios of physical effects in
the model. Many more examples on dimensionless parameters will appear
in later sections.</p>
<p>The analytical solution of the scaled model
<a class="reference internal" href="#eq-scale-decay-model-g-dimless"><span class="std std-ref">(12)</span></a> reads</p>
<div class="math" id="eq-scale-decay-model-g-exact-scaled">
\[\tag{14}
\bar{u_{\small\mbox{e}}}(t) =
    e^{-t}\left( e^{t}-1 + \beta\right) = 1 + (\beta -1)e^{-t}{\thinspace .}\]</div>
<p>The result <a class="reference internal" href="#eq-scale-decay-model-g-dimless"><span class="std std-ref">(12)</span></a> with the
solution <a class="reference internal" href="#eq-scale-decay-model-g-exact-scaled"><span class="std std-ref">(14)</span></a> is actually
astonishing if <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are as in <a class="reference internal" href="#eq-scale-decay-model-g-spec"><span class="std std-ref">(10)</span></a>:
the six parameters <span class="math">\(d\)</span>, <span class="math">\(\mu\)</span>, <span class="math">\(\varrho_b\)</span>, <span class="math">\(\varrho\)</span>, <span class="math">\(V\)</span>, and <span class="math">\(g\)</span>
are conjured to one:</p>
<div class="math">
\[\beta = I\frac{3\pi d\mu}{\varrho_b V}
\frac{1}{g}\left(\frac{\varrho}{\varrho_b} -1\right)^{-1},\]</div>
<p>which is an enormous simplification of the problem if our aim is to
investigate how <span class="math">\(u\)</span> varies with the physical input parameters in
the model.
In particular, if the motion starts from rest, <span class="math">\(\beta=0\)</span>, and
there are no physical parameters in the scaled model!
We can then perform a single simulation and recover all physical
cases by the unscaling procedure. More precisely,
having computed <span class="math">\(\bar u(\bar t)\)</span> from <a class="reference internal" href="#eq-scale-decay-model-g-dimless"><span class="std std-ref">(12)</span></a>,
we can use</p>
<div class="math" id="eq-auto5">
\[\tag{15}
u(t) = \frac{b}{a}\bar u(at),\]</div>
<p>to scale us back to the original
problem again.
We observe that <a class="reference internal" href="#eq-scale-decay-model-g-dimless"><span class="std std-ref">(12)</span></a> can utilize a solver
for <a class="reference internal" href="#eq-scale-decay-model-g"><span class="std std-ref">(9)</span></a> by setting <span class="math">\(a=1\)</span>, <span class="math">\(b=1\)</span>, and <span class="math">\(I=\beta\)</span>.
Given some implementation of a solver for <a class="reference internal" href="#eq-scale-decay-model-g"><span class="std std-ref">(9)</span></a>,
say <code class="docutils literal"><span class="pre">solver(I,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">T,</span> <span class="pre">dt,</span> <span class="pre">theta)</span></code>,
the scaled model is run by <code class="docutils literal"><span class="pre">solver(beta,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">T,</span> <span class="pre">dt,</span> <span class="pre">theta)</span></code>.</p>
</div>
<div class="section" id="software-1">
<span id="index-10"></span><h4>Software<a class="headerlink" href="#software-1" title="Permalink to this headline">¶</a></h4>
<p>We may develop a solver for the scaled problem that uses <code class="docutils literal"><span class="pre">joblib</span></code>
to cache solutions with the same <span class="math">\(\beta\)</span>, <span class="math">\(\Delta t\)</span>, and <span class="math">\(T\)</span>.
For now we fix <span class="math">\(\theta=0.5\)</span>.
The module <a class="reference external" href="http://tinyurl.com/o8pb3yy/decay_vc.py">decay_vc.py</a>
(see ref[the section <span class="xref std std-ref">decay:general</span>][ in [Ref06]_[the
section <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book006.html#implementation-of-the-generalized-model-problem">Implementation of the generalized model problem</a>
<a class="reference internal" href="._book010.html#ref06" id="id4">[Ref06]</a>] for details)
has a function
<code class="docutils literal"><span class="pre">solver(I,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">T,</span> <span class="pre">dt,</span> <span class="pre">theta)</span></code> for solving <span class="math">\(u'(t)=-a(t)u(t)+b(t)\)</span> for
<span class="math">\(t\in (0,T]\)</span>, <span class="math">\(u(0)=I\)</span>, with time step <code class="docutils literal"><span class="pre">dt</span></code>.
We reuse this function and call it with <span class="math">\(a=b=1\)</span> and <span class="math">\(I=\beta\)</span> to solve
the scaled problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">decay_vc</span> <span class="kn">import</span> <span class="n">solver</span> <span class="k">as</span> <span class="n">solver_unscaled</span>

<span class="k">def</span> <span class="nf">solver_scaled</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-u+1, u(0)=beta for (0,T]</span>
<span class="sd">    with step dt and theta method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s">&#39;Computing the numerical solution&#39;</span>
    <span class="k">return</span> <span class="n">solver_unscaled</span><span class="p">(</span>
        <span class="n">I</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">joblib</span>
<span class="n">disk_memory</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">Memory</span><span class="p">(</span><span class="n">cachedir</span><span class="o">=</span><span class="s">&#39;temp&#39;</span><span class="p">)</span>
<span class="n">solver_scaled</span> <span class="o">=</span> <span class="n">disk_memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">solver_scaled</span><span class="p">)</span>
</pre></div>
</div>
<p>If we want to plot the physical solution, we need an <code class="docutils literal"><span class="pre">unscale</span></code> function,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">unscale</span><span class="p">(</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ab</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">t_scaled</span>

<span class="k">def</span> <span class="nf">ab</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">mu</span><span class="o">/</span><span class="p">(</span><span class="n">rho_b</span><span class="o">*</span><span class="n">V</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">g</span><span class="o">*</span><span class="p">(</span><span class="n">rho</span><span class="o">/</span><span class="n">rho_b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
</pre></div>
</div>
<p>Looking at droplets of water in air, we can fix some of the parameters
and let the size parameter <span class="math">\(d\)</span> be the one for experimentation.
The following function sets physical parameters, computes <span class="math">\(\beta\)</span>,
runs the solver for the scaled problem (<code class="docutils literal"><span class="pre">joblib</span></code> detects
if it is necessary), and finally plots the scaled curve
<span class="math">\(\bar u(\bar t)\)</span> and the unscaled curve <span class="math">\(u(t)\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.075</span><span class="p">,</span> <span class="c"># Time step, scaled problem</span>
         <span class="n">T</span><span class="o">=</span><span class="mf">7.5</span><span class="p">,</span>    <span class="c"># Final time, scaled problem</span>
         <span class="n">d</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>  <span class="c"># Diameter (unscaled problem)</span>
         <span class="n">I</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>      <span class="c"># Initial velocity (unscaled problem)</span>
         <span class="p">):</span>
    <span class="c"># Set parameters, solve and plot</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="mf">0.00129E+3</span>  <span class="c"># air</span>
    <span class="n">rho_b</span> <span class="o">=</span> <span class="mf">1E+3</span>      <span class="c"># density of water</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="mf">0.001</span>        <span class="c"># viscosity of water</span>
    <span class="c"># Asumme we have list or similar for d</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>

    <span class="n">legends1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">legends2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">betas</span> <span class="o">=</span> <span class="p">[]</span>     <span class="c"># beta values already computed (for plot)</span>

    <span class="k">for</span> <span class="n">d_</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">d_</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>  <span class="c"># volume</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ab</span><span class="p">(</span><span class="n">d_</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">a</span><span class="o">/</span><span class="n">b</span>
        <span class="c"># Restrict to 3 digits in beta</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">print</span> <span class="s">&#39;beta=</span><span class="si">%.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">beta</span>
        <span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span> <span class="o">=</span> <span class="n">solver_scaled</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

        <span class="c"># Avoid plotting curves with the same beta value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">beta</span> <span class="ow">in</span> <span class="n">betas</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_scaled</span><span class="p">,</span> <span class="n">u_scaled</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
            <span class="n">legends1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;beta=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">beta</span><span class="p">)</span>
        <span class="n">betas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">unscale</span><span class="p">(</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span><span class="p">,</span> <span class="n">d_</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
        <span class="n">legends2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;d=</span><span class="si">%g</span><span class="s"> [mm]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d_</span><span class="o">*</span><span class="mi">1000</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;scaled time&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;scaled velocity&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;lower right&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The most complicated part of the code is related to plotting, but
this part can be skipped when trying to understand how we work with
a scaled model to perform the computations.
The complete program is found in the file
<a class="reference external" href="http://tinyurl.com/o8pb3yy/falling_body.py">falling_body.py</a>.</p>
<p>Since <span class="math">\(I=0\)</span> implies <span class="math">\(\beta=0\)</span>, we can run different <span class="math">\(d\)</span> values without
any need to recompute <span class="math">\(\bar u(\bar t)\)</span> as long as we assume the particle
starts from rest.</p>
<p>From the scaling, we see that <span class="math">\(u_c = b/a\sim d^{-2}\)</span> and
also that <span class="math">\(t_c=1/a \sim d^{-2}\)</span>, so plotting of <span class="math">\(u(t)\)</span> with dimensions
for various <span class="math">\(d\)</span> values will involve significant variations in the time
and velocity scales. Figure <a class="reference internal" href="#sec-scale-decay-body-fig"><span class="std std-ref">Velocity of falling body: scaled (left) and with dimensions (right)</span></a>
has an example with <span class="math">\(d=1,2,3\)</span> mm, where we clearly see the different
time and velocity scales in the figure with unscaled variables.
Note that the scaled velocity is positive because of the sign of <span class="math">\(u_c\)</span>
(see the box above).</p>
<div class="figure" id="id6">
<span id="sec-scale-decay-body-fig"></span><a class="reference internal image-reference" href="_images/falling_body.png"><img alt="_images/falling_body.png" src="_images/falling_body.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Velocity of falling body: scaled (left) and with dimensions (right)</em></span></p>
</div>
</div>
</div>
<div class="section" id="variable-coefficients">
<span id="sec-scale-decay-jump"></span><h3>Variable coefficients<a class="headerlink" href="#variable-coefficients" title="Permalink to this headline">¶</a></h3>
<p>When a prescribed coefficient like <span class="math">\(a(t)\)</span> in <span class="math">\(u'(t) = -a(t)u(t)\)</span>
varies with time one usually also
performs a scaling of this <span class="math">\(a\)</span>,</p>
<div class="math">
\[\bar a(\bar t) = \frac{a(t) - a_0}{a_c},\]</div>
<p>where the goal is to have the scaled <span class="math">\(\bar a\)</span>
of size unity: <span class="math">\(|\bar a|\leq 1\)</span>.
This property is obtained by choosing <span class="math">\(a_c\)</span> as the maximum value
of <span class="math">\(|a(t)-a_0|\)</span> for <span class="math">\(t\in [0,T]\)</span>, which is usually a quantity that
can be estimated since <span class="math">\(a(t)\)</span> is known as a function of <span class="math">\(t\)</span>. The <span class="math">\(a_0\)</span>
parameter can be chosen as 0 here. (It could be tempting to
choose <span class="math">\(a_0=\min_t a(t)\)</span> so that <span class="math">\(0\leq \bar a\leq 1\)</span>, but then there
is at least one point where <span class="math">\(\bar a = 0\)</span> and
the differential equation collapses to <span class="math">\(u'=0\)</span>.)</p>
<p>As an example, imagine a decaying cell culture where we at time <span class="math">\(t_1\)</span>
change the environment (typically the nutrition)
such that the death rate increases by a factor 5.
Mathematically, <span class="math">\(a(t) = d\)</span> for
<span class="math">\(t &lt; t_1\)</span> and <span class="math">\(a(t)=5d\)</span> for <span class="math">\(t\geq t_1\)</span>. The model reads <span class="math">\(u'=-a(t)u\)</span>, <span class="math">\(u(0)=I\)</span>.</p>
<p>The <span class="math">\(a(t)\)</span> function is scaled by letting the characteristic size be
<span class="math">\(a_c=d\)</span> and <span class="math">\(a_0=0\)</span>:</p>
<div class="math">
\[\begin{split}\bar a (\bar t) = \left\lbrace\begin{array}{ll}
1, &amp; \bar t &lt; t_1/t_c\\
5, &amp; \bar t \geq t_1/t_c
\end{array}\right.\end{split}\]</div>
<p id="index-11">The scaled equation becomes</p>
<div class="math">
\[\frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = a_c\bar a(\bar t) u_c\bar u,\quad
u_c\bar u(0) = I{\thinspace .}\]</div>
<p>The natural choice of <span class="math">\(u_c\)</span> is <span class="math">\(I\)</span>.
The characteristic time, previously taken as <span class="math">\(t_c=1/a\)</span>, can now be
chosen as <span class="math">\(t_c=t_1\)</span> or <span class="math">\(t_c=1/d\)</span>.
With <span class="math">\(t_c=1/d\)</span> we get</p>
<div class="math" id="eq-sec-scale-decay-jump-eq1">
\[\begin{split}\tag{16}
\bar u'(\bar t)=-\bar a\bar u,\quad \bar u(0)=1,\quad
    \bar a = \left\lbrace\begin{array}{ll}
    1, &amp; \bar t &lt; \gamma\\
    5, &amp; \bar t \geq \gamma
    \end{array}\right.\end{split}\]</div>
<p>where</p>
<div class="math">
\[\gamma = t_1 d\]</div>
<p>is a dimensionless number in the problem. With <span class="math">\(t_c=t_1\)</span>, we get</p>
<div class="math">
\[\begin{split}\bar u'(\bar t)=-\gamma\bar a\bar u,\quad \bar u(0)=1,\quad
\bar a = \left\lbrace\begin{array}{ll}
1, &amp; \bar t &lt; 1\\
5, &amp; \bar t \geq 1
\end{array}\right.\end{split}\]</div>
<p>The dimensionless parameter <span class="math">\(\gamma\)</span> is now in the equation rather than in
the definition of <span class="math">\(\bar a\)</span>. Both problems involve <span class="math">\(\gamma\)</span>, which
is the ratio between the time when the environmental change happens
and the typical time for the decay (<span class="math">\(1/d\)</span>).</p>
<p>A computation with the scaled model <a class="reference internal" href="#eq-sec-scale-decay-jump-eq1"><span class="std std-ref">(16)</span></a>
and the original model with dimensions appears in
Figure <a class="reference internal" href="#sec-scale-decay-jump-fig"><span class="std std-ref">Exponential decay with jump: scaled model (left) and unscaled model (right)</span></a>.</p>
<div class="figure" id="id7">
<span id="sec-scale-decay-jump-fig"></span><a class="reference internal image-reference" href="_images/decay_jump.png"><img alt="_images/decay_jump.png" src="_images/decay_jump.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Exponential decay with jump: scaled model (left) and unscaled model (right)</em></span></p>
</div>
</div>
<div class="section" id="scaling-a-cooling-problem-with-constant-surroundings">
<span id="scale-decay-cooling-const"></span><h3>Scaling a cooling problem with constant surroundings<a class="headerlink" href="#scaling-a-cooling-problem-with-constant-surroundings" title="Permalink to this headline">¶</a></h3>
<p>The heat exchange between a body at temperature <span class="math">\(T(t)\)</span> and the
surroundings at constant temperature <span class="math">\(T_s\)</span>
can be modeled by Newton&#8217;s law of cooling:</p>
<div class="math" id="eq-scale-decay-cooling-model">
\[\tag{17}
T'(t) = -k(T-T_s),\quad T(0)=T_0,\]</div>
<p>where <span class="math">\(k\)</span> is a prescribed heat transfer coefficient.</p>
<div class="section" id="exact-solution-2">
<h4>Exact solution<a class="headerlink" href="#exact-solution-2" title="Permalink to this headline">¶</a></h4>
<p>An analytical solution is always handy to have as a control of the
choice of scales. The solution of <a class="reference internal" href="#eq-scale-decay-cooling-model"><span class="std std-ref">(17)</span></a>
is by standard methods for ODEs found to be
<span class="math">\(T(t) = T_s + (T_0 - T_s)e^{-kt}\)</span>.</p>
</div>
<div class="section" id="scaling-1">
<h4>Scaling<a class="headerlink" href="#scaling-1" title="Permalink to this headline">¶</a></h4>
<p>Physically, we expect the temperature to start at <span class="math">\(T_0\)</span> and then
to move toward the surroundings (<span class="math">\(T_s\)</span>). We therefore expect
that <span class="math">\(T\)</span> lies between <span class="math">\(T_0\)</span> and <span class="math">\(T_s\)</span>. This is mathematically
demonstrated by the analytical solution as well. A proper scaling
is therefore to scale and translate <span class="math">\(T\)</span> according to</p>
<div class="math" id="eq-scale-decay-cooling-tbar">
\[\tag{18}
\bar T = \frac{T-T_0}{T_s-T_0}\]\[    {\thinspace .}\]</div>
<p>Now, <span class="math">\(0\leq \bar T\leq 1\)</span>.</p>
<p>Scaling time by <span class="math">\(\bar t = t/t_c\)</span> and inserting
<span class="math">\(T= T_0 + (T_s-T_0)\bar T\)</span> and <span class="math">\(t=t_c\bar t\)</span> in the
problem <a class="reference internal" href="#eq-scale-decay-cooling-model"><span class="std std-ref">(17)</span></a> gives</p>
<div class="math">
\[\frac{d\bar T}{d\bar t} = - t_ck(\bar T - 1),\quad \bar T(0) = 0
{\thinspace .}\]</div>
<p>A natural choice, as argued in other exponential decay problems,
is to choose <span class="math">\(t_ck=1\)</span>, which leaves us with the scaled problem</p>
<div class="math" id="eq-scale-decay-cooling-tbar-eq">
\[\tag{19}
\frac{d\bar T}{d\bar t} = - (\bar T - 1),\quad \bar T(0)=0\]\[    {\thinspace .}\]</div>
<p>No physical parameter enters this problem!
Our scaling implies that <span class="math">\(\bar T\)</span> starts at
0 and approaches 1 as <span class="math">\(\bar t\rightarrow\infty\)</span>, also in the case
<span class="math">\(T_s &lt; T_0\)</span>. The physical temperature is always recovered as</p>
<div class="math" id="eq-scale-decay-cooling-t">
\[\tag{20}
T(t) = T_0 + (T_s-T_0)\bar T (k\bar t)\]\[    {\thinspace .}\]</div>
</div>
<div class="section" id="software-2">
<h4>Software<a class="headerlink" href="#software-2" title="Permalink to this headline">¶</a></h4>
<p>An implementation for <a class="reference internal" href="#eq-scale-decay-cooling-model"><span class="std std-ref">(17)</span></a> works for
<a class="reference internal" href="#eq-scale-decay-cooling-tbar-eq"><span class="std std-ref">(19)</span></a> by setting <span class="math">\(k=1\)</span>, <span class="math">\(T_s=1\)</span>, and <span class="math">\(T_0=0\)</span>.</p>
</div>
<div class="section" id="alternative-scaling-1">
<h4>Alternative scaling<a class="headerlink" href="#alternative-scaling-1" title="Permalink to this headline">¶</a></h4>
<p>An alternative temperature scaling is to choose</p>
<div class="math" id="eq-scale-decay-cooling-tbar2">
\[\tag{21}
\bar T = \frac{T-T_s}{T_0-T_s}\]\[    {\thinspace .}\]</div>
<p>Now <span class="math">\(\bar T=1\)</span> initially and approaches zero as <span class="math">\(t\rightarrow\infty\)</span>.
The resulting scaled ODE problem then becomes</p>
<div class="math" id="eq-scale-decay-cooling-tbar-eq2">
\[\tag{22}
\frac{d\bar T}{d\bar t} = - \bar T,\quad \bar T(0)=1\]\[    {\thinspace .}\]</div>
</div>
</div>
<div class="section" id="scaling-a-cooling-problem-with-time-dependent-surroundings">
<span id="scale-decay-cooling-osc"></span><h3>Scaling a cooling problem with time-dependent surroundings<a class="headerlink" href="#scaling-a-cooling-problem-with-time-dependent-surroundings" title="Permalink to this headline">¶</a></h3>
<p>Let us apply the model <a class="reference internal" href="#eq-scale-decay-cooling-model"><span class="std std-ref">(17)</span></a> in
case the surrounding temperature varies in time. Say we have
an oscillating temperature environment according to</p>
<div class="math" id="eq-scale-decay-cooling-tst">
\[\tag{23}
T_s(t) = T_m + a\sin(\omega t)\]\[    {\thinspace .}\]</div>
<div class="section" id="exact-solution-3">
<h4>Exact solution<a class="headerlink" href="#exact-solution-3" title="Permalink to this headline">¶</a></h4>
<p>It is possible to solve the differential equation problem analytically,
and such a solution is a good help to see what scales are.
In general, using the method of integrating factors for the
original differential equation, we have</p>
<div class="math">
\[T(t) = T_0e^{-kt} + e^{-kt}k\int_0^t e^{k\tau}T_s(\tau)d\tau{\thinspace .}\]</div>
<p>With <span class="math">\(T_s(t)=T_m + a\sin (\omega t)\)</span> we can use SymPy to help us with
integrations (note that we use <code class="docutils literal"><span class="pre">w</span></code> for <span class="math">\(\omega\)</span> in the computer code):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T_m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t k T_m a w&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T_s</span> <span class="o">=</span> <span class="n">T_m</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">T_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Q</span>
<span class="go">(-T_m*k**2 - T_m*w**2 + a*k*w +</span>
<span class="go">(T_m*k**2 + T_m*w**2 + a*k**2*sin(t*w) -</span>
<span class="go">a*k*w*cos(t*w))*exp(k*t))*exp(-k*t)/((k**2 + w**2))</span>
</pre></div>
</div>
<p>Reordering the result, we get</p>
<div class="math">
\[T(t) = T_0e^{-kt} + T_m(1- e^{-kt}) +  (k^2 + \omega^2)^{-1}(ak\omega e^{-kt}
+ ak\sin (\omega t) - akw\cos(\omega t)){\thinspace .}\]</div>
</div>
<div class="section" id="scaling-2">
<span id="index-12"></span><h4>Scaling<a class="headerlink" href="#scaling-2" title="Permalink to this headline">¶</a></h4>
<p>The scaling <a class="reference internal" href="#eq-scale-decay-cooling-tbar"><span class="std std-ref">(18)</span></a> brings in a time-dependent
characteristic temperature scale <span class="math">\(T_s-T_0\)</span>. Let us start with a
fixed scale, where we take the characteristic temperature variation to
be <span class="math">\(T_m - T_0\)</span>:</p>
<div class="math">
\[\bar T = \frac{T-T_0}{T_m-T_0}{\thinspace .}\]</div>
<p>We see from the analytical solution, and realize also by physical
reasoning, that <span class="math">\(T\)</span> sets out at <span class="math">\(T_0\)</span>, but with time, it will oscillate
around <span class="math">\(T_m\)</span>. The typical average temperature span is therefore
<span class="math">\(|T_m-T_0|\)</span>, unless <span class="math">\(a\)</span> is much larger than <span class="math">\(|T_m-T_0|\)</span> or <span class="math">\(T_0\)</span> is
very close to <span class="math">\(T_m\)</span> (see <a class="reference internal" href="._book009.html#sec-scale-exer-decay-cooling-osc"><span class="std std-ref">Exercise 3: Perform alternative scalings</span></a> for
a discussion of these cases).</p>
<p>We get from the differential equation, with <span class="math">\(t_c=1/k\)</span> as in the former
case,</p>
<div class="math">
\[k(T_m-T_0)\frac{d\bar T}{d\bar t} = -k((T_m-T_0)\bar T + T_0 - T_m - a
\sin(\omega t),\]</div>
<p>resulting in</p>
<div class="math" id="eq-scale-decay-cooling-model-scaled">
\[\tag{24}
\frac{d\bar T}{d\bar t} = -\bar T + 1 + \alpha\sin (\beta \bar t),\quad
    \bar T(0)=0,\]</div>
<p>where we have two dimensionless numbers:</p>
<div class="math">
\[\alpha = \frac{a}{T_m-T_0},\quad \beta = \frac{\omega}{k}{\thinspace .}\]</div>
<p>The <span class="math">\(\alpha\)</span> quantity measures the ratio of temperatures: amplitude of
oscillations versus distance from initial temperature to the average
temperature for large times.  The <span class="math">\(\beta\)</span> number is the ratio of the
two time scales: the frequency of the oscillations in <span class="math">\(T_s\)</span> and the
inverse e-folding time of the heat transfer. For clear interpretation
of <span class="math">\(\beta\)</span> we may introduce the period <span class="math">\(P=2\pi/\omega\)</span> of the
oscillations in <span class="math">\(T_s\)</span> and the e-folding time <span class="math">\(e=1/k\)</span>. Then <span class="math">\(\beta =
2\pi e/P\)</span> and measures the e-folding time versus the period.</p>
<p>The original problem features five physical parameters: <span class="math">\(k\)</span>, <span class="math">\(T_0\)</span>,
<span class="math">\(T_m\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(\omega\)</span>, but only two dimensionless numbers appear in the
scaled model <a class="reference internal" href="#eq-scale-decay-cooling-model-scaled"><span class="std std-ref">(24)</span></a>.</p>
<p>[<strong>hpl 8</strong>: Geir can write about the Pi theorem here - it gives three parameters and a suboptimal solution compared to the scaling of the ODE directly.]</p>
</div>
<div class="section" id="software-3">
<h4>Software<a class="headerlink" href="#software-3" title="Permalink to this headline">¶</a></h4>
<p>Implementations of the unscaled problem <a class="reference internal" href="#eq-scale-decay-cooling-model"><span class="std std-ref">(17)</span></a>
can be reused for the scaled model by setting <span class="math">\(k=1\)</span>, <span class="math">\(T_0=0\)</span>, and
<span class="math">\(T_s(t) = 1 + \alpha\sin (\beta \bar t)\)</span> (<span class="math">\(T_m=1\)</span>, <span class="math">\(a=\alpha\)</span>, <span class="math">\(\omega =\beta\)</span>).
The file <a class="reference external" href="http://tinyurl.com/o8pb3yy/osc_cooling.py">osc_cooling.py</a> contains
solvers for the problem with dimensions and
for the scaled problem. The figure below
shows three cases of <span class="math">\(\beta\)</span> values: small, medium, and large.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/osc_cooling.png"><img alt="_images/osc_cooling.png" src="_images/osc_cooling.png" style="width: 500px;" /></a>
</div>
<p>For the small <span class="math">\(\beta\)</span> value, the oscillations in the surrounding
temperature are slow enough compared to <span class="math">\(k\)</span> for the heating and
cooling process to follow the surrounding temperature, with a small
time lag. For larger <span class="math">\(\beta\)</span>, the heating and cooling requires more
time, and the oscillations get smaller.</p>
</div>
<div class="section" id="discussion-of-the-time-scale-1">
<h4>Discussion of the time scale<a class="headerlink" href="#discussion-of-the-time-scale-1" title="Permalink to this headline">¶</a></h4>
<p>Looking at the analytical insight we have, <span class="math">\(T(t)\)</span> has two characteristic
terms in time: <span class="math">\(e^{-kt}\)</span> and <span class="math">\(\sin(\omega t)\)</span>. The former points to a time
scale <span class="math">\(t_c=1/k\)</span>, while the latter to <span class="math">\(t_c=1/\omega\)</span>.
Which one should be chosen? Bringing the temperature from <span class="math">\(T_0\)</span> to
the level of the surroundings, <span class="math">\(T_m\)</span>, goes like <span class="math">\(e^{-kt}\)</span>, so
in this process <span class="math">\(t_c=1/k\)</span> is the characteristic time. Thereafter,
the body&#8217;s temperature just responds to the oscillations and the
<span class="math">\(\sin (\omega t)\)</span> (and <span class="math">\(\cos(\omega t)\)</span>) term dominates. For these large times,
<span class="math">\(t_c=1/\omega\)</span> is the appropriate time scale. Choosing <span class="math">\(t_c=1/\omega\)</span>
results in</p>
<div class="math" id="eq-scale-decay-cooling-model-scaled2">
\[\tag{25}
\frac{d\bar T}{d\bar t} = -\beta^{-1}(\bar T - (1 + \alpha\sin (\bar t))),\quad
    \bar T(0)=0{\thinspace .}\]</div>
<p>Let us illustrate another, less effective, scaling.
The temperature scale in
<a class="reference internal" href="#eq-scale-decay-cooling-tbar"><span class="std std-ref">(18)</span></a> looks natural, so we apply this
choice of scale. The characteristic temperature <span class="math">\(T_0-T_s\)</span>
now involves
a time-dependent term <span class="math">\(T_s(t)\)</span>. The mathematical steps become a bit
more technically involved:</p>
<div class="math">
\[T(t) = T_0 + (T_s(t)-T_0)\bar T,\]</div>
<div class="math">
\[\frac{dT}{dt} = \frac{dT_s}{dt}\bar T +
(T_s-T_0)\frac{d\bar T}{d\bar t}\frac{d\bar t}{dt}
{\thinspace .}\]</div>
<p>With <span class="math">\(\bar t = t/t_c = kt\)</span> we get from the differential equation</p>
<div class="math">
\[\frac{dT_s}{dt}\bar T +
(T_s-T_0)\frac{d\bar T}{d\bar t}k
= -k(\bar T - 1)(T_s - T_0),\]</div>
<p>which after dividing by <span class="math">\(k(T_s-T_0)\)</span> results in</p>
<div class="math">
\[\frac{d\bar T}{d\bar t} = -(\bar T - 1) -
\frac{dT_s}{dt}\frac{\bar T}{k(T_s-T_0},\]</div>
<p>or</p>
<div class="math">
\[\frac{d\bar T}{d\bar t} = -(\bar T - 1) -
\frac{a\omega\cos(\omega \bar t/k)}{k(T_m + a\sin(\omega \bar t/k) -T_0)}\bar T
{\thinspace .}\]</div>
<p>The last term is complicated and becomes more tractable if we factor
out dimensionless numbers. To this end, we scale <span class="math">\(T_s\)</span> by (e.g.) <span class="math">\(T_m\)</span>,
which means to factor out <span class="math">\(T_m\)</span> in the denominator. We are then
left with</p>
<div class="math" id="eq-scale-decay-cooling-tbar-eq3">
\[\tag{26}
\frac{d\bar T}{d\bar t} = -(\bar T - 1) -
    \alpha\beta \frac{\cos(\beta \bar t)}{1 + \alpha\sin(\beta\bar t) - \gamma}
    \bar T,\]</div>
<p>where <span class="math">\(\alpha\)</span>, <span class="math">\(\beta\)</span>, and <span class="math">\(\gamma\)</span> are dimensionless numbers
characterizing the relative importance of parameters in the problem:</p>
<div class="math" id="eq-auto6">
\[\tag{27}
\alpha=a/T_m,\quad \beta = \omega/k,\quad \gamma = T_0/T_m
    {\thinspace .}\]</div>
<p>We notice that <a class="reference internal" href="#eq-scale-decay-cooling-tbar-eq3"><span class="std std-ref">(26)</span></a>
is not a special case of the original problem
<a class="reference internal" href="#eq-scale-decay-cooling-model"><span class="std std-ref">(17)</span></a>. Furthermore, the original five
parameters <span class="math">\(k\)</span>, <span class="math">\(T_m\)</span>, <span class="math">\(a\)</span>, <span class="math">\(\omega\)</span>, and
<span class="math">\(T_0\)</span> are reduced to three dimensionless parameters.
We conclude that this scaling is inferior, because
using the temperature scale <span class="math">\(T_0-T_m\)</span> enables reuse of the software
for the unscaled problem and only two dimensionless parameters appear
in the scaled model.</p>
</div>
</div>
<div class="section" id="scaling-a-nonlinear-ode">
<span id="sec-scale-decay-nonlinear"></span><h3>Scaling a nonlinear ODE<a class="headerlink" href="#scaling-a-nonlinear-ode" title="Permalink to this headline">¶</a></h3>
<p id="index-13">Exponential growth models, <span class="math">\(u'=au\)</span>, are not realistic in environments
with limited resources. The idea is then to assume that
the growth rate <span class="math">\(a\)</span> decreases with <span class="math">\(u\)</span> and vanishes when we reach the maximum
value <span class="math">\(M\)</span> of <span class="math">\(u\)</span> the environment can sustain. The initial growth rate
is set to <span class="math">\(r\)</span>: <span class="math">\(a(0)=\varrho\)</span>.
In general, this reasoning gives rise to models</p>
<div class="math" id="eq-sec-scale-decay-nonlinear-model1">
\[\tag{28}
u' = a(u)u,\quad u(0)=I,\]</div>
<p>with the logistic model, corresponding to <span class="math">\(a(u)=\varrho(1-u/M)\)</span>,
as the simplest:</p>
<div class="math" id="eq-sec-scale-decay-nonlinear-model2">
\[\tag{29}
u' = \varrho u(1-u/M),\quad u(0)=I{\thinspace .}\]</div>
<p>A general choice of <span class="math">\(a\)</span> may be <span class="math">\(a(u)=\varrho(1-u/M)^p\)</span> for some exponent <span class="math">\(p\)</span>.</p>
<div class="section" id="scaling-3">
<span id="index-14"></span><h4>Scaling<a class="headerlink" href="#scaling-3" title="Permalink to this headline">¶</a></h4>
<p>Let us scale <a class="reference internal" href="#eq-sec-scale-decay-nonlinear-model1"><span class="std std-ref">(28)</span></a> with
<span class="math">\(a(u)=\varrho (1-u/M)^p\)</span>.
The natural scale for <span class="math">\(u\)</span> is <span class="math">\(M\)</span> (<span class="math">\(u_c=M\)</span>), since we know that
<span class="math">\(0 &lt; u\leq M\)</span>, and this makes the dimensionless <span class="math">\(\bar u = u/M \in (0,1]\)</span>.
The function <span class="math">\(a(u)\)</span> is
typically varying between 0 and <span class="math">\(\varrho\)</span>, so it can be scaled as</p>
<div class="math">
\[\bar a(\bar u) = \frac{a(u)}{\varrho} = (1 - \frac{u}{M})^p =
(1 - \bar u)^p{\thinspace .}\]</div>
<p>Time is scaled as <span class="math">\(\bar t = t/t_c\)</span> for some suitable characteristic time <span class="math">\(t_c\)</span>.
Inserted in <a class="reference internal" href="#eq-sec-scale-decay-nonlinear-model1"><span class="std std-ref">(28)</span></a>, we get</p>
<div class="math">
\[\frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = \varrho\bar a u_c\bar u,\quad u_c\bar u(0)=I,\]</div>
<p>resulting in</p>
<div class="math">
\[\frac{d\bar u}{d\bar t} = t_c \varrho (1 - \bar u)^p \bar u,\quad
\bar u(0) =\frac{I}{M}{\thinspace .}\]</div>
<p>A natural choice is <span class="math">\(t_c =1/\varrho\)</span> as in other exponential growth models
since it leads to the term on the right-hand side to be about unity,
as the left-hand side, if the scaling is physically correct.
Introducing the dimensionless parameter</p>
<div class="math">
\[\alpha = \frac{I}{M},\]</div>
<p>measuring the fraction of the initial population compared to the maximum
one, we get the dimensionless model</p>
<div class="math" id="eq-sec-scale-decay-nonlinear-model1-scaled">
\[\tag{30}
\frac{d\bar u}{d\bar t} = (1 - \bar u)^p \bar u,\quad
    \bar u(0) =\alpha{\thinspace .}\]</div>
<p>Here, we have two dimensionless parameters: <span class="math">\(\alpha\)</span> and <span class="math">\(p\)</span>. A classical
logistic model with <span class="math">\(p=1\)</span> has only one dimensionless variable.</p>
</div>
<div class="section" id="alternative-scaling-2">
<h4>Alternative scaling<a class="headerlink" href="#alternative-scaling-2" title="Permalink to this headline">¶</a></h4>
<p>We could try another scaling of <span class="math">\(u\)</span> where we also translate <span class="math">\(\bar u\)</span>:</p>
<div class="math">
\[\bar u = \frac{u-I}{M}{\thinspace .}\]</div>
<p>This choice of <span class="math">\(\bar u\)</span> results in</p>
<div class="math" id="eq-sec-scale-decay-nonlinear-model1-scaled2">
\[\tag{31}
\frac{d\bar u}{d\bar t} = (1 - \alpha - \bar u)^p \bar u,\quad
    \bar u(0) =0{\thinspace .}\]</div>
<p>The essential difference between <a class="reference internal" href="#eq-sec-scale-decay-nonlinear-model1-scaled"><span class="std std-ref">(30)</span></a>
and <a class="reference internal" href="#eq-sec-scale-decay-nonlinear-model1-scaled2"><span class="std std-ref">(31)</span></a> is that
<span class="math">\(\bar u\in [\alpha, 1]\)</span> in the former and <span class="math">\(\bar u \in [0, 1-\alpha]\)</span> in
the latter. Both models involve the dimensionless numbers <span class="math">\(\alpha\)</span> and <span class="math">\(p\)</span>.
An advantage of <a class="reference internal" href="#eq-sec-scale-decay-nonlinear-model1-scaled"><span class="std std-ref">(30)</span></a>
is that software for the unscaled model can easily be used for the
scaled model by choosing <span class="math">\(I=\alpha\)</span>, <span class="math">\(M=1\)</span>, and <span class="math">\(\varrho=1\)</span>.</p>
</div>
</div>
<div class="section" id="sir-ode-system-for-spreading-of-diseases">
<h3>SIR ODE system for spreading of diseases<a class="headerlink" href="#sir-ode-system-for-spreading-of-diseases" title="Permalink to this headline">¶</a></h3>
<p>The field of epidemiology frequently applies ODE systems to describe
the spreading of diseases, such as smallpox, measles, plague, ordinary
flu, swine flu, and HIV. Different models include different effects,
which are reflected in dimensionless numbers. Most of the effects are
modeled as exponential decay or growth of the dependent variables.</p>
<p>The simplest model has three categories of people: susceptibles (S)
who can get the disease, infectious (I) who are infected and may
infect susceptibles, and recovered (R) who have recovered from the
disease and gained immunity. We introduce <span class="math">\(S(t)\)</span>, <span class="math">\(I(t)\)</span>, and <span class="math">\(R(t)\)</span>
as the number of people in the categories S, I, and R, respectively.
The model, naturally known as the <a class="reference external" href="https://en.wikipedia.org/wiki/Epidemic_model">SIR model</a>, takes the form a
system of ODEs:</p>
<div class="math" id="eq-scale-sir-s">
\[\tag{32}
\frac{dS}{dt} = - \beta SI,\]</div>
<div class="math" id="eq-scale-sir-i">
\[\tag{33}
\frac{dI}{dt} = \beta SI - \nu I,\]</div>
<div class="math" id="eq-scale-sir-r">
\[\tag{34}
\frac{dR}{dt} = \nu I,\]</div>
<p>where <span class="math">\(\beta\)</span> and <span class="math">\(\nu\)</span> are empirical constants. The average time for recovering
from the disease can be shown to be <span class="math">\(\nu^{-1}\)</span>, but <span class="math">\(\beta\)</span> is much harder
to estimate, so working with a scaled model where <span class="math">\(\beta\)</span> is &#8220;scaled away&#8221;
is advantageous.</p>
<p>[<strong>hpl 9</strong>: Geir asked about the background for this model. A link to Wikipedia is now inserted, but in general all models in this book are just listed without further explanations. Do we need more references? The idea was that &#8220;here are the ODEs&#8221; and if understanding of the &#8220;physics&#8221; is necessary, the reader must have the necessary background. Maybe state this in the preface?]</p>
<div class="section" id="scaling-4">
<h4>Scaling<a class="headerlink" href="#scaling-4" title="Permalink to this headline">¶</a></h4>
<p>It is natural to scale <span class="math">\(S\)</span>, <span class="math">\(I\)</span>, and <span class="math">\(R\)</span> by, e.g., <span class="math">\(S(0)\)</span>:</p>
<div class="math">
\[\bar S = \frac{S}{S(0)},\quad \bar I = \frac{I}{S(0)},\quad
\bar R = \frac{R}{S(0)}{\thinspace .}\]</div>
<p>Introducing <span class="math">\(\bar t = t/t_c\)</span>, we arrive at the equations</p>
<div class="math">
\[\begin{split}\frac{d\bar S}{d\bar t} &amp;= - t_c S(0) \beta\bar S\bar I,
\\
\frac{d\bar I}{d\bar t} &amp;= t_c S(0) \beta \bar S\bar I - t_c \nu \bar I,
\\
\frac{d\bar R}{d\bar t} &amp;= t_c \nu I,\end{split}\]</div>
<p>with initial conditions <span class="math">\(\bar S(0)=1\)</span>, <span class="math">\(\bar I(0)=I_0/S(0)=\alpha\)</span>, and
<span class="math">\(\bar R(0)=R(0)/S(0)\)</span>. Normally, <span class="math">\(R(0)=0\)</span>.</p>
<p>Taking <span class="math">\(t_c=1/\nu\)</span>, corresponding to a time unit equal to the time it takes
to recover from the disease, we end up with the scaled model</p>
<div class="math" id="eq-scale-sir-s2">
\[\tag{35}
\frac{d\bar S}{d\bar t} = - R_0\bar S\bar I,\]</div>
<div class="math" id="eq-scale-sir-i2">
\[\tag{36}
\frac{d\bar I}{d\bar t} = R_0 \bar S\bar I - \bar I,\]</div>
<div class="math" id="eq-scale-sir-r2">
\[\tag{37}
\frac{d\bar R}{d\bar t} = I,\]</div>
<p>with <span class="math">\(\bar S(0)=1\)</span>, <span class="math">\(\bar I(0)=\alpha\)</span>, <span class="math">\(\bar R(0)=0\)</span>, and <span class="math">\(R_0\)</span> as
the dimensionless number</p>
<div class="math" id="eq-auto7">
\[\tag{38}
R_0 = \frac{S(0)\beta}{\nu}{\thinspace .}\]</div>
<p>We see from <a class="reference internal" href="#eq-scale-sir-i2"><span class="std std-ref">(36)</span></a> that to make the disease spreading,
<span class="math">\(d\bar I/d\bar t &gt;0\)</span>, and therefore <span class="math">\(R_0 S(0) - 1 &gt; 0\)</span> or <span class="math">\(R_0 &gt; 1\)</span>
since <span class="math">\(S(0)=1\)</span>.
Therefore, <span class="math">\(R_0\)</span> reflects the disease&#8217;s ability to spread and is
consequently an important dimensionless quantity, known as the <a class="reference external" href="https://en.wikipedia.org/wiki/Basic_reproduction_number">basic
reproduction number</a>.
This number reflects the number of infected people caused by one infectious
individual during the time period of the disease.</p>
<p>Looking at <a class="reference internal" href="#eq-scale-sir-i"><span class="std std-ref">(33)</span></a>, we see that to increase <span class="math">\(I\)</span> initially,
we must have <span class="math">\(dI/dt &gt;0\)</span> at <span class="math">\(t=0\)</span>, which implies
<span class="math">\(\beta I(0)S(0) - \nu I(0) &gt;0\)</span>, i.e., <span class="math">\(R_0 &gt; 1\)</span>.</p>
</div>
<div class="section" id="software-4">
<h4>Software<a class="headerlink" href="#software-4" title="Permalink to this headline">¶</a></h4>
<p>Any implementation of the SIR model with dimensions can be reused for
the scaled model by setting <span class="math">\(\beta = R_0\)</span>, <span class="math">\(\nu = 1\)</span>, <span class="math">\(S(0)=1-\alpha\)</span>,
and <span class="math">\(I(0)=\alpha\)</span>. Below is a plot with two cases: <span class="math">\(R_0=2\)</span> and <span class="math">\(R_0=5\)</span>,
both with <span class="math">\(\alpha=0.02\)</span>.</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/SIR1.png"><img alt="_images/SIR1.png" src="_images/SIR1.png" style="width: 800px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="alternative-scaling-3">
<h4>Alternative scaling<a class="headerlink" href="#alternative-scaling-3" title="Permalink to this headline">¶</a></h4>
<p>Adding <a class="reference internal" href="#eq-scale-sir-s"><span class="std std-ref">(32)</span></a>-<a class="reference internal" href="#eq-scale-sir-r"><span class="std std-ref">(34)</span></a> shows that</p>
<div class="math">
\[\frac{dS}{dt}+\frac{dI}{dt}+\frac{dR}{dt}=0\quad\Rightarrow\quad
S+I+R=\hbox{const}=N,\]</div>
<p>where <span class="math">\(N\)</span> is the size of the population.
We can therefore scale <span class="math">\(S\)</span>, <span class="math">\(I\)</span>, and <span class="math">\(R\)</span> by the total
population <span class="math">\(N=S(0)+I(0)+R(0)\)</span>:</p>
<div class="math">
\[\bar S = \frac{S}{N},\quad \bar I = \frac{I}{N},\quad
\bar R = \frac{R}{N)}{\thinspace .}\]</div>
<p>With the same time scale, one gets the system <a class="reference internal" href="#eq-scale-sir-s2"><span class="std std-ref">(35)</span></a>-<a class="reference internal" href="#eq-scale-sir-r2"><span class="std std-ref">(37)</span></a>, but with <span class="math">\(R_0\)</span> replaced by the dimensionless number:</p>
<div class="math" id="eq-auto8">
\[\tag{39}
\tilde R_0 = \frac{N\beta}{\nu}{\thinspace .}\]</div>
<p>The initial conditions become <span class="math">\(\bar S(0)=1-\alpha\)</span>, <span class="math">\(\bar I(0)=\alpha\)</span>,
and <span class="math">\(\bar R(0)=0\)</span>.</p>
<p>For the disease to spread at <span class="math">\(t=0\)</span>, we must have <span class="math">\(\tilde R_0 \bar S(0) &gt; 1\)</span>,
but <span class="math">\(\tilde R_0 \bar S(0) = N\beta/\nu \cdot S(0)/N = R_0\)</span>, so the
criterion is still <span class="math">\(R_0 &gt; 1\)</span>. Since <span class="math">\(R_0\)</span> is a more famous number than
<span class="math">\(\tilde R_0\)</span>, we can write the ODEs with <span class="math">\(R_0/S(0) = R_0/(1-\alpha)\)</span>
instead of <span class="math">\(\tilde R_0\)</span>.</p>
<p>Choosing <span class="math">\(t_c\)</span> to make the <span class="math">\(SI\)</span> terms balance the time derivatives,
<span class="math">\(t_c = (N\beta)^{-1}\)</span>, moves <span class="math">\(\tilde R_0\)</span> (or <span class="math">\(R_0\)</span> if we scale
<span class="math">\(S\)</span>, <span class="math">\(I\)</span>, and <span class="math">\(R\)</span> by <span class="math">\(S(0)\)</span>) to the <span class="math">\(I\)</span> terms:</p>
<div class="math">
\[\begin{split}\frac{d\bar S}{d\bar t} &amp;= - \bar S\bar I,
\\
\frac{d\bar I}{d\bar t} &amp;= \bar S\bar I - \tilde R_0^{-1} \bar I,
\\
\frac{d\bar R}{d\bar t} &amp;= \tilde R_0^{-1} I{\thinspace .}\end{split}\]</div>
</div>
</div>
<div class="section" id="sirv-model-with-finite-immunity">
<h3>SIRV model with finite immunity<a class="headerlink" href="#sirv-model-with-finite-immunity" title="Permalink to this headline">¶</a></h3>
<p>A common extension of the SIR model involves finite immunity: after
some period of time, recovered individuals lose their immunity
and become susceptibles again. This is modeled as
a leakage <span class="math">\(-\mu R\)</span> from the R to the S category, where <span class="math">\(\mu^{-1}\)</span>
is the average time it takes to lose immunity.
Vaccination is another extension: a fraction <span class="math">\(pS\)</span> is removed from the
S category by successful vaccination and brought to a new category V (the
vaccinated). The ODE model reads</p>
<div class="math" id="eq-scale-sirv-s">
\[\tag{40}
\frac{dS}{dt} = - \beta SI - pS + \mu R,\]</div>
<div class="math" id="eq-scale-sirv-i">
\[\tag{41}
\frac{dI}{dt} = \beta SI - \nu I,\]</div>
<div class="math" id="eq-scale-sirv-r">
\[\tag{42}
\frac{dR}{dt} = \nu I -\mu R,\]</div>
<div class="math" id="eq-scale-sirv-v">
\[\tag{43}
\frac{dV}{dt} = p S{\thinspace .}\]</div>
<p>Using <span class="math">\(t_c=1/\nu\)</span> and scaling the unknowns by <span class="math">\(S(0)\)</span>, we arrive at
the dimensionless model</p>
<div class="math" id="eq-scale-sirv-s2">
\[\tag{44}
\frac{d\bar S}{d\bar t} = - R_0 \bar S \bar I - \delta S + \gamma \bar R,\]</div>
<div class="math" id="eq-scale-sirv-i2">
\[\tag{45}
\frac{d\bar I}{d\bar t} = R_0 \bar S \bar I - \bar I,\]</div>
<div class="math" id="eq-scale-sirv-r2">
\[\tag{46}
\frac{d\bar R}{d\bar t} = \bar I -\gamma \bar R,\]</div>
<div class="math" id="eq-scale-sirv-v2">
\[\tag{47}
\frac{d\bar V}{d\bar t} = \delta \bar S,\]</div>
<p>with two new dimensionless parameters:</p>
<div class="math">
\[\gamma = \frac{\mu}{\nu},\quad \delta = \frac{p}{\nu}{\thinspace .}\]</div>
<p>The quantity <span class="math">\(p^{-1}\)</span> can be interpreted as the average time it takes
to vaccinate a susceptible successfully. Writing <span class="math">\(\gamma = \nu^{-1}/\mu^{-1}\)</span>
and <span class="math">\(\delta = \nu^{-1}/p^{-1}\)</span> gives the interpretation that <span class="math">\(\gamma\)</span>
is the ratio of the average time to recover and the average time to
lose immunity, while <span class="math">\(\delta\)</span> is the ratio of the average time to recover
and the average time to successfully vaccinate a susceptible.</p>
<p>The plot in Figure <a class="reference internal" href="#sec-scale-sirv-fig"><span class="std std-ref">Spreading of a disease with loss of immunity (left) and added vaccination (right)</span></a> has <span class="math">\(\gamma = 0.05\)</span>, i.e.,
loss of immunity takes 20 weeks if it takes one week to recover from
the disease. The left plot corresponds to no vaccination, while the
right has <span class="math">\(\delta = 0.5\)</span> for a vaccination campaign that lasts from
day 7 to day 15. The value <span class="math">\(\delta =0.5\)</span> reflects that
it takes two weeks to successfully
vaccinate a susceptible, but the effect of vaccination is still dramatic.</p>
<div class="figure" id="id8">
<span id="sec-scale-sirv-fig"></span><a class="reference internal image-reference" href="_images/SIRV2.png"><img alt="_images/SIRV2.png" src="_images/SIRV2.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Spreading of a disease with loss of immunity (left) and added vaccination (right)</em></span></p>
</div>
</div>
<div class="section" id="michaelis-menten-kinetics-for-biochemical-reactions">
<span id="scale-mmk"></span><h3>Michaelis-Menten kinetics for biochemical reactions<a class="headerlink" href="#michaelis-menten-kinetics-for-biochemical-reactions" title="Permalink to this headline">¶</a></h3>
<p>A classical reaction model in biochemistry describes how a
substrate S is turned into a product P with aid of an enzyme E.
S and E react to form a complex ES in the first stage of the reaction.
In the second stage, ES is turned into E and P.
Introducing the amount of S, E, ES, and P by <span class="math">\([S]\)</span>, <span class="math">\([E]\)</span>, <span class="math">\([ES]\)</span>, and
<span class="math">\([P]\)</span>, the mathematical model (known as <a class="reference external" href="https://en.wikipedia.org/wiki/Michaelis-Menten_kinetics">Michaelis-Menten kinetics</a>) can be written as</p>
<div class="math" id="eq-scale-mmk-es1">
\[\tag{48}
\frac{d[ES]}{dt} = k_+[E][S] - k_v[ES] - k_-[ES],\]</div>
<div class="math" id="eq-scale-mmk-p1">
\[\tag{49}
\frac{d[P]}{dt} = k_v[ES],\]</div>
<div class="math" id="eq-scale-mmk-s1">
\[\tag{50}
\frac{d[S]}{dt} = -k_+[E][S] + k_-[ES],\]</div>
<div class="math" id="eq-scale-mmk-e1">
\[\tag{51}
\frac{d[E]}{dt} = -k_+[E][S] + k_-[ES] + k_v[ES]{\thinspace .}\]</div>
<p>The initial conditions are <span class="math">\([ES](0)=[P](0)=0\)</span>, and <span class="math">\([S]=S_0\)</span>, <span class="math">\([E]=E_0\)</span>.
Three rate constants are involved: <span class="math">\(k_+\)</span>, <span class="math">\(k_-\)</span>, and <span class="math">\(k_v\)</span>.</p>
<p>The amount of substance is measured in the unit <a class="reference external" href="https://en.wikipedia.org/wiki/Mole_(unit)">mole</a> (mol). From the equations we can see that
<span class="math">\(k_+\)</span> is measured in <span class="math">\(\hbox{s}^{-1}\hbox{mol}^{-1}\)</span>, while <span class="math">\(k_-\)</span> and
<span class="math">\(k_v\)</span> are measured in <span class="math">\(\hbox{s}^{-1}\)</span>. It is convenient to get rid of
the mole unit for the amount of a substance. When working with
dimensionless quantities, only ratios of the rate constants and not their
specific values are needed.</p>
<div class="section" id="classical-analysis">
<h4>Classical analysis<a class="headerlink" href="#classical-analysis" title="Permalink to this headline">¶</a></h4>
<p>The typical analysis of the present ODE system is to first observe
two conservation equations, arising from simply adding the ODEs:</p>
<div class="math" id="eq-auto9">
\[\tag{52}
\frac{d[ES]}{dt} + \frac{d[E]}{dt}  =0,\]</div>
<div class="math" id="eq-auto10">
\[\tag{53}
\frac{d[ES]}{dt} + \frac{d[S]}{dt} + \frac{d[P]}{dt} = 0,\]</div>
<p>from which it follows that</p>
<div class="math" id="eq-scale-mmk-cons1">
\[\tag{54}
[ES] + [E] = E_0,\]</div>
<div class="math" id="eq-scale-mmk-cons2">
\[\tag{55}
[ES] + [S] + [P] = S_0{\thinspace .}\]</div>
<p>Using <a class="reference internal" href="#eq-scale-mmk-cons1"><span class="std std-ref">(54)</span></a>, we can eliminate <span class="math">\([E]\)</span> and obtain a
system of only two ODEs,</p>
<div class="math" id="eq-auto11">
\[\tag{56}
\frac{d[ES]}{dt} = k_+([ES]-E_0)[S] - (k_v + k_-)[ES],\]</div>
<div class="math" id="eq-auto12">
\[\tag{57}
\frac{d[S]}{dt} = -k_+([ES]-E_0)[S] + k_-[ES]{\thinspace .}\]</div>
<p>A common assumption is that the formation of <span class="math">\([ES]\)</span> is very fast and that
it reaches an equilibrium state, <span class="math">\([ES]^{\prime}=0\)</span>. This implies</p>
<div class="math">
\[k_+([ES]-E_0)[S] - (k_v + k_-)[ES]=0\quad\Rightarrow\quad
[ES] = \frac{E_0[S]}{[S] - K},\]</div>
<p>where</p>
<div class="math">
\[K = \frac{k_- + k_v}{k_+},\]</div>
<p>is the Michaelis constant. Using the expression for <span class="math">\([ES]\)</span> in the
equation for <span class="math">\([S]\)</span> gives</p>
<div class="math" id="eq-scale-mmk-seq1">
\[\tag{58}
\frac{d[S]}{dt} = \frac{k_vE_0[S]}{[S] + K}{\thinspace .}\]</div>
<p>We see that the parameter <span class="math">\(K\)</span> is central.</p>
</div>
<div class="section" id="dimensionless-ode-system">
<h4>Dimensionless ODE system<a class="headerlink" href="#dimensionless-ode-system" title="Permalink to this headline">¶</a></h4>
<p>Let us reason how to make the original ODE system dimensionless.
Aiming at <span class="math">\([S]\)</span> and <span class="math">\([E]\)</span> of unit size, two obvious dimensionless
unknowns are</p>
<div class="math">
\[\bar S = \frac{[S]}{S_0},\quad
\bar E = \frac{[E]}{E_0}{\thinspace .}\]</div>
<p>For the other two unknowns we just introduce scales to be determined
later:</p>
<div class="math">
\[\bar P = \frac{[P]}{P_c},\quad
\bar{Q} = \frac{[ES]}{Q_c}{\thinspace .}\]</div>
<p>With <span class="math">\(\bar t = t/t_c\)</span> the equations become</p>
<div class="math">
\[\begin{split}\frac{d\bar Q}{d\bar t} &amp;= t_ck_+\frac{E_0S_0}{Q_c}\bar E\bar S
- t_c(k_v + k_-)\bar Q,\\
\frac{d\bar P}{d\bar t} &amp;= t_ck_v\frac{Q_c}{P_c}\bar Q,\\
\frac{d\bar S}{d\bar t} &amp;= -t_ck_+E_0\bar E\bar S
+ t_ck_-\frac{Q_c}{S_0}\bar Q,\\
\frac{d\bar E}{d\bar t} &amp;= -t_ck_+S_0\bar E\bar S
+ t_c(k_- + k_v)\frac{Q_c}{E_0}\bar Q{\thinspace .}\end{split}\]</div>
</div>
<div class="section" id="determining-scales">
<h4>Determining scales<a class="headerlink" href="#determining-scales" title="Permalink to this headline">¶</a></h4>
<p>Choosing the scales is actually a quite complicated matter that requires
extensive analysis of the equations to determine the characteristics of
the solutions. Much literature is written about this, but here we shall
take a simplistic and pragmatic approach.
Besides the Michaelis constant <span class="math">\(K\)</span>, there is another important parameter,</p>
<div class="math">
\[\epsilon = \frac{E_0}{S_0},\]</div>
<p>because most applications will involve a small <span class="math">\(\epsilon\)</span>.
We shall have <span class="math">\(K\)</span> and <span class="math">\(\epsilon\)</span> in mind while choosing scales such that
these symbols appear naturally in the scaled equations.</p>
<p>Looking at the equations, we see that the <span class="math">\(K\)</span> parameter will appear
if <span class="math">\(t_c\sim 1/k_+\)</span>. However, <span class="math">\(1/k_+\)</span> does not have the dimension
<span class="math">\(\hbox{[T]}^{-1}\)</span> as required, so we need to add a factor with dimension
mol. A natural choice is
<span class="math">\(t_c^{-1}=k_+S_0\)</span> or <span class="math">\(t_c^{-1}=k_+E_0\)</span>. Since often <span class="math">\(S_0\gg E_0\)</span>,
the former <span class="math">\(t_c\)</span> is a short time scale and the latter is a long
time scale. If the interest is in the long time scale, we set</p>
<div class="math">
\[t_c = \frac{1}{k_+E_0}{\thinspace .}\]</div>
<p>The equations then take the form</p>
<div class="math">
\[\begin{split}\frac{d\bar Q}{d\bar t} &amp;= \frac{S_0}{Q_c}\bar E\bar S
- KE_0^{-1}\bar Q,\\
\frac{d\bar P}{d\bar t} &amp;= \frac{k_v}{k_+ E_0}\frac{Q_c}{P_c}\bar Q,\\
\frac{d\bar S}{d\bar t} &amp;= -\bar E\bar S
+ \frac{k_-}{k_+E_0}\frac{Q_c}{S_0}\bar Q,\\
\frac{d\bar E}{d\bar t} &amp;= -\epsilon^{-1}\bar E\bar S
+ K\frac{Q_c}{E_0^2}\bar Q{\thinspace .}\end{split}\]</div>
<p>The <span class="math">\([ES]\)</span> variable starts and ends at zero, and its maximum value
can be roughly estimated from the equation for <span class="math">\([ES]^{\prime}\)</span>
by setting <span class="math">\([ES]^{\prime}=0\)</span>, which gives an estimate of</p>
<div class="math">
\[Q_c = \frac{E_0S_0}{K},\]</div>
<p>if we approximate <span class="math">\([E][S]\)</span> by <span class="math">\(E_0S_0\)</span>.</p>
<p>The equation for <span class="math">\(\bar P\)</span> simplifies if we choose <span class="math">\(P_c=Q_c\)</span>.
With these assumptions one gets</p>
<div class="math">
\[\begin{split}\frac{d\bar Q}{d\bar t} &amp;= KE_0^{-1} (\bar E\bar S
- \bar Q),\\
\frac{d\bar P}{d\bar t} &amp;= \frac{k_v}{k_+ E_0}\bar Q,\\
\frac{d\bar S}{d\bar t} &amp;= -\bar E\bar S
+ \frac{k_-}{k_+E_0}\frac{E_0}{K}\bar Q,\\
\frac{d\bar E}{d\bar t} &amp;= -\epsilon^{-1}\bar E\bar S
+ \epsilon^{-1}\bar Q{\thinspace .}\end{split}\]</div>
<p>We can now identify the dimensionless numbers</p>
<div class="math">
\[\alpha = \frac{K}{E_0},\quad \beta = \frac{k_v}{k_+ E_0},
\quad \gamma = \frac{k_-}{k_+E_0},\]</div>
<p>where we see that <span class="math">\(\alpha = \beta + \gamma\)</span>, so <span class="math">\(\gamma\)</span> can be eliminated,
leading to the final set of equations:</p>
<div class="math" id="eq-scale-mmk-q2">
\[\tag{59}
\frac{d\bar Q}{d\bar t} = \alpha (\bar E\bar S
    - \bar Q),\]</div>
<div class="math" id="eq-scale-mmk-p2">
\[\tag{60}
\frac{d\bar P}{d\bar t} = \beta\bar Q,\]</div>
<div class="math" id="eq-scale-mmk-s2">
\[\tag{61}
\frac{d\bar S}{d\bar t} = -\bar E\bar S
    + (1 - \beta\alpha^{-1})\bar Q,\]</div>
<div class="math" id="eq-scale-mmk-e2">
\[\tag{62}
\epsilon\frac{d\bar E}{d\bar t} = -\bar E\bar S + \bar Q{\thinspace .}\]</div>
<p>The five initial parameters (<span class="math">\(S_0\)</span>, <span class="math">\(E_0\)</span>, <span class="math">\(k_+\)</span>, <span class="math">\(k_-\)</span>, and <span class="math">\(k_v\)</span>)
are reduced to three dimensionless constants:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(\alpha\)</span> is the dimensionless Michaelis constant, reflecting the
ratio of the production of P and E (<span class="math">\(k_v+k_-\)</span>) versus the production of
the complex (<span class="math">\(k_+\)</span>), made dimensionless by <span class="math">\(E_0\)</span>,</li>
<li><span class="math">\(\epsilon\)</span> is the initial fraction of enzyme relative to the substrate,</li>
<li><span class="math">\(\beta\)</span> measures the relative importance of production of P (<span class="math">\(k_v\)</span>)
versus production of the complex (<span class="math">\(k_+\)</span>), made dimensionless by <span class="math">\(E_0\)</span>.</li>
</ul>
</div></blockquote>
<p>Observe that software developed for
solving <a class="reference internal" href="#eq-scale-mmk-es1"><span class="std std-ref">(48)</span></a>-<a class="reference internal" href="#eq-scale-mmk-e1"><span class="std std-ref">(51)</span></a> cannot be reused
for solving <a class="reference internal" href="#eq-scale-mmk-q2"><span class="std std-ref">(59)</span></a>-<a class="reference internal" href="#eq-scale-mmk-e2"><span class="std std-ref">(62)</span></a> since the latter
system has a slightly different structure.</p>
</div>
<div class="section" id="analysis-of-the-scaled-system">
<h4>Analysis of the scaled system<a class="headerlink" href="#analysis-of-the-scaled-system" title="Permalink to this headline">¶</a></h4>
<p>In the scaled system, we may assume <span class="math">\(\epsilon\)</span> small, which from
<a class="reference internal" href="#eq-scale-mmk-e2"><span class="std std-ref">(62)</span></a> gives rise to the simplification
<span class="math">\(\epsilon\bar E^{\prime}=0\)</span>, and thereby the relation <span class="math">\(\bar Q = \bar E\bar S\)</span>.
The conservation equation <span class="math">\([ES] + [E]= E_0\)</span> reads <span class="math">\(Q_c\bar Q + E_0\bar E =
E_0\)</span> such that <span class="math">\(\bar E = 1 - Q_c\bar Q/E_0=1- \bar Q S_0/K = 1 - \epsilon^{-1}\alpha^{-1}\bar Q\)</span>. The relation <span class="math">\(\bar Q=\bar E\bar S\)</span> then becomes</p>
<div class="math">
\[\bar Q = (1 - \epsilon^{-1}\alpha^{-1}\bar Q)\bar S,\]</div>
<p>which can be solved for <span class="math">\(\bar Q\)</span>:</p>
<div class="math">
\[\bar Q = \frac{\bar S}{1 + \epsilon^{-1}\alpha^{-1}\bar S}{\thinspace .}\]</div>
<p>The equation <a class="reference internal" href="#eq-scale-mmk-s2"><span class="std std-ref">(61)</span></a> for <span class="math">\(\bar S\)</span> becomes</p>
<div class="math" id="eq-scale-mmk-seq2">
\[\tag{63}
\frac{d\bar S}{d\bar t} = -\beta\alpha^{-1}\bar Q =
    -\frac{\beta\bar S}{\alpha + \epsilon^{-1}\bar S}{\thinspace .}\]</div>
<p>This is a more precise analysis than the one leading to
<a class="reference internal" href="#eq-scale-mmk-seq1"><span class="std std-ref">(58)</span></a> since we now realize that the
mathematical assumption for the simplification is
<span class="math">\(\epsilon\rightarrow 0\)</span>.</p>
<p>Is <a class="reference internal" href="#eq-scale-mmk-seq2"><span class="std std-ref">(63)</span></a> consistent with <a class="reference internal" href="#eq-scale-mmk-seq1"><span class="std std-ref">(58)</span></a>? It is
easy to make algebraic mistakes when deriving scaled equations,
so it is always wise to carry out consistency checks.
Introducing dimensions in <a class="reference internal" href="#eq-scale-mmk-seq2"><span class="std std-ref">(63)</span></a> leads to</p>
<div class="math">
\[\frac{t_c}{S_0}\frac{d S}{dt} =
\frac{d\bar S}{d\bar t}  =
-\frac{\beta\bar S}{\alpha + \epsilon^{-1}\bar S}
= \frac{k_v}{k_+E_0}\frac{S}{KE_0^{-1} + E_0^{-1}S_0\bar S}
= \frac{k_v}{k_+}\frac{\bar S}{K + S},\]</div>
<p>and hence with <span class="math">\(t_c^{-1}=k_+E_0\)</span>,</p>
<div class="math">
\[\frac{dS}{dt} = \frac{k_vE_0 S}{K + S},\]</div>
<p>which is <a class="reference internal" href="#eq-scale-mmk-seq1"><span class="std std-ref">(58)</span></a>.</p>
<p>Figure <a class="reference internal" href="#scale-mmk-fig"><span class="std std-ref">Simulation of a biochemical process</span></a> shows the impact of <span class="math">\(\epsilon\)</span>: with a small
value (0.1) we see that <span class="math">\(\bar Q\approx 0\)</span>, which justifies the
simplifications performed above. We also observe that all the unknowns
vary between 0 and about 1, indicating that the scaling is successful
for the chosen dimensionless numbers.</p>
<div class="figure" id="id9">
<span id="scale-mmk-fig"></span><a class="reference internal image-reference" href="_images/biochem.png"><img alt="_images/biochem.png" src="_images/biochem.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-text"><em>Simulation of a biochemical process</em></span></p>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">ODE models</a><ul>
<li><a class="reference internal" href="#exponential-decay-problems">Exponential decay problems</a><ul>
<li><a class="reference internal" href="#fundamental-ideas">Fundamental ideas</a></li>
<li><a class="reference internal" href="#the-basic-model-problem">The basic model problem</a><ul>
<li><a class="reference internal" href="#example-population-dynamics">Example: Population dynamics</a></li>
<li><a class="reference internal" href="#example-decay-of-pressure-with-altitude">Example: Decay of pressure with altitude</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-technical-steps-of-the-scaling-procedure">The technical steps of the scaling procedure</a><ul>
<li><a class="reference internal" href="#step-1-identify-independent-and-dependent-variables">Step 1: Identify independent and dependent variables</a></li>
<li><a class="reference internal" href="#step-2-make-independent-and-dependent-variables-dimensionless">Step 2: Make independent and dependent variables dimensionless</a></li>
<li><a class="reference internal" href="#step-3-derive-the-model-involving-only-dimensionless-variables">Step 3: Derive the model involving only dimensionless variables</a></li>
<li><a class="reference internal" href="#step-4-make-each-term-dimensionless">Step 4: Make each term dimensionless</a></li>
<li><a class="reference internal" href="#step-5-estimate-the-scales">Step 5: Estimate the scales</a></li>
</ul>
</li>
<li><a class="reference internal" href="#making-software-for-utilizing-the-scaled-model">Making software for utilizing the scaled model</a><ul>
<li><a class="reference internal" href="#software-for-the-original-problem-with-dimensions">Software for the original problem with dimensions</a></li>
<li><a class="reference internal" href="#avoiding-unnecessary-computations">Avoiding unnecessary computations</a></li>
<li><a class="reference internal" href="#implementation-with-joblib">Implementation with joblib</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scaling-a-generalized-problem">Scaling a generalized problem</a><ul>
<li><a class="reference internal" href="#exact-solution-1">Exact solution</a></li>
<li><a class="reference internal" href="#theory">Theory</a></li>
<li><a class="reference internal" href="#software-1">Software</a></li>
</ul>
</li>
<li><a class="reference internal" href="#variable-coefficients">Variable coefficients</a></li>
<li><a class="reference internal" href="#scaling-a-cooling-problem-with-constant-surroundings">Scaling a cooling problem with constant surroundings</a><ul>
<li><a class="reference internal" href="#exact-solution-2">Exact solution</a></li>
<li><a class="reference internal" href="#scaling-1">Scaling</a></li>
<li><a class="reference internal" href="#software-2">Software</a></li>
<li><a class="reference internal" href="#alternative-scaling-1">Alternative scaling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scaling-a-cooling-problem-with-time-dependent-surroundings">Scaling a cooling problem with time-dependent surroundings</a><ul>
<li><a class="reference internal" href="#exact-solution-3">Exact solution</a></li>
<li><a class="reference internal" href="#scaling-2">Scaling</a></li>
<li><a class="reference internal" href="#software-3">Software</a></li>
<li><a class="reference internal" href="#discussion-of-the-time-scale-1">Discussion of the time scale</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scaling-a-nonlinear-ode">Scaling a nonlinear ODE</a><ul>
<li><a class="reference internal" href="#scaling-3">Scaling</a></li>
<li><a class="reference internal" href="#alternative-scaling-2">Alternative scaling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sir-ode-system-for-spreading-of-diseases">SIR ODE system for spreading of diseases</a><ul>
<li><a class="reference internal" href="#scaling-4">Scaling</a></li>
<li><a class="reference internal" href="#software-4">Software</a></li>
<li><a class="reference internal" href="#alternative-scaling-3">Alternative scaling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sirv-model-with-finite-immunity">SIRV model with finite immunity</a></li>
<li><a class="reference internal" href="#michaelis-menten-kinetics-for-biochemical-reactions">Michaelis-Menten kinetics for biochemical reactions</a><ul>
<li><a class="reference internal" href="#classical-analysis">Classical analysis</a></li>
<li><a class="reference internal" href="#dimensionless-ode-system">Dimensionless ODE system</a></li>
<li><a class="reference internal" href="#determining-scales">Determining scales</a></li>
<li><a class="reference internal" href="#analysis-of-the-scaled-system">Analysis of the scaled system</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book003.html"
                        title="previous chapter">Dimensions and units</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book005.html"
                        title="next chapter">Vibration problems</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book004.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book005.html" title="Vibration problems"
             >next</a> |</li>
        <li class="right" >
          <a href="._book003.html" title="Dimensions and units"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Scaling of Differential Equations</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2015, Geir K. Pedersen, Hans Petter Langtangen. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>