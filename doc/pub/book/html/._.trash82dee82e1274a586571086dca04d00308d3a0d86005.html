<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Scaling of Differential Equations">
<meta name="keywords" content="units,base unit,length,mass,time,dimension of physical quantities,units US,units British,units conversion,units software,multiple software runs,web interface (Parampool),graphical web interface,scaling,non-dimensionalization,dimensionless variable,exponential decay,dimensionless variable,characteristic time,e-folding time,memoize function,dimensionless number,dimensionless number,dimensionless number,logistic equation,dimensionless number,frequency,frequency, angular,period (of oscillations),radians,angular frequency,quality factor $Q$,phase shift,dimensionless number,Peclet number,dimensionless number,Reynolds number,thermo-elasticity,Navier-Stokes equations,dimensionless number,Reynolds number,Reynolds number,low Reynolds number flow,Stokes problem,Stokes' flow,Froude number,creeping flow,Strouhal number,vortex shedding,Euler number,Weber number,forced convection,Peclet number,Reynolds number,free convection,Grashof number,Reynolds number,Peclet number,Eckert number,Nusselt number,Lotka-Volterra, predator-pray model,Lotka-Volterra, competing species model">

<title>Scaling of Differential Equations</title>

<!-- Bootstrap style: bootswatch_readable -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/readable/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Preface', 0, 'ch:preface', 'ch:preface'),
              ('Dimensions and units', 0, 'scale:dimunit', 'scale:dimunit'),
              ('Fundamental concepts', 1, None, '___sec2'),
              ('Base units and dimensions', 2, None, '___sec3'),
              ('Dimensions of common physical quantities',
               2,
               'scale:dimunit:tables',
               'scale:dimunit:tables'),
              ('Prefixes for units', 3, None, '___sec5'),
              ('Errors and units', 2, None, '___sec6'),
              ('Unit systems', 2, None, '___sec7'),
              ('PhysicalQuantity: object for computing with units',
               2,
               'scale:PQ',
               'scale:PQ'),
              ('Parampool: user interfaces with automatic unit conversion',
               1,
               'scale:parampool',
               'scale:parampool'),
              ('Example application', 3, None, '___sec10'),
              ('Pool of parameters', 2, None, '___sec11'),
              ('Fetching pool data for computing', 2, None, '___sec12'),
              ('Reading command-line options', 2, None, '___sec13'),
              ('Setting default values in a file', 2, None, '___sec14'),
              ('Specifying multiple values of input parameters',
               2,
               None,
               '___sec15'),
              ('Generating a graphical user interface', 2, None, '___sec16'),
              ('ODE models', 0, None, '___sec17'),
              ('Exponential decay problems',
               1,
               'sec:scale:decay',
               'sec:scale:decay'),
              ('Fundamental ideas', 2, None, '___sec19'),
              ('The basic model problem', 2, None, '___sec20'),
              ('Example: Population dynamics', 3, None, '___sec21'),
              ('Example: Decay of pressure with altitude',
               3,
               None,
               '___sec22'),
              ('The technical steps of the scaling procedure',
               2,
               'sec:scale:decay:steps',
               'sec:scale:decay:steps'),
              ('Step 1: Identify independent and dependent variables',
               3,
               None,
               '___sec24'),
              ('Step 2: Make independent and dependent variables dimensionless',
               3,
               None,
               '___sec25'),
              ('Step 3: Derive the model involving only dimensionless variables',
               3,
               None,
               '___sec26'),
              ('Step 4: Make each term dimensionless', 3, None, '___sec27'),
              ('Step 5: Estimate the scales', 3, None, '___sec28'),
              ('Making software for utilizing the scaled model',
               2,
               'sec:scale:decay:prog',
               'sec:scale:decay:prog'),
              ('Software for the original problem with dimensions',
               3,
               None,
               '___sec30'),
              ('Avoiding unnecessary computations', 3, None, '___sec31'),
              ('Implementation with joblib', 3, None, '___sec32'),
              ('Scaling a generalized problem',
               2,
               'sec:scale:decay:body',
               'sec:scale:decay:body'),
              ('Exact solution', 3, None, '___sec34'),
              ('Theory', 3, None, '___sec35'),
              ('Software', 3, None, '___sec36'),
              ('Variable coefficients',
               2,
               'sec:scale:decay:jump',
               'sec:scale:decay:jump'),
              ('Scaling a cooling problem with constant surroundings',
               2,
               'scale:decay:cooling:const',
               'scale:decay:cooling:const'),
              ('Exact solution', 3, None, '___sec39'),
              ('Scaling', 3, None, '___sec40'),
              ('Software', 3, None, '___sec41'),
              ('Alternative scaling', 3, None, '___sec42'),
              ('Scaling a cooling problem with time-dependent surroundings',
               2,
               'scale:decay:cooling:osc',
               'scale:decay:cooling:osc'),
              ('Exact solution', 3, None, '___sec44'),
              ('Scaling', 3, None, '___sec45'),
              ('Software', 3, None, '___sec46'),
              ('Discussion of the time scale', 3, None, '___sec47'),
              ('Scaling a nonlinear ODE',
               2,
               'sec:scale:decay:nonlinear',
               'sec:scale:decay:nonlinear'),
              ('Scaling', 3, None, '___sec49'),
              ('Alternative scaling', 3, None, '___sec50'),
              ('SIR ODE system for spreading of diseases',
               2,
               None,
               '___sec51'),
              ('Scaling', 3, None, '___sec52'),
              ('Software', 3, None, '___sec53'),
              ('Alternative scaling', 3, None, '___sec54'),
              ('SIRV model with finite immunity', 2, None, '___sec55'),
              ('Michaelis-Menten kinetics for biochemical reactions',
               2,
               'scale:MMK',
               'scale:MMK'),
              ('Classical analysis', 3, None, '___sec57'),
              ('Dimensionless ODE system', 3, None, '___sec58'),
              ('Determining scales', 3, None, '___sec59'),
              ('Analysis of the scaled system', 3, None, '___sec60'),
              ('Vibration problems', 1, 'sec:scale:vib', 'sec:scale:vib'),
              ('Undamped vibrations without forcing',
               2,
               'sec:scale:vib:undamped',
               'sec:scale:vib:undamped'),
              ('The first technical steps of scaling', 3, None, '___sec63'),
              ('The exact solution', 3, None, '___sec64'),
              ('Discussion of the displacement scale', 3, None, '___sec65'),
              ('Discussion of the time scale', 3, None, '___sec66'),
              ('The dimensionless solution', 3, None, '___sec67'),
              ('Alternative displacement scale', 3, None, '___sec68'),
              ('About frequency and dimensions', 3, None, '___sec69'),
              ('Undamped vibrations with constant forcing',
               2,
               'sec:scale:vib:undamped:mg',
               'sec:scale:vib:undamped:mg'),
              ('Undamped vibrations with time-dependent forcing',
               2,
               'sec:scale:vib:undamped:F',
               'sec:scale:vib:undamped:F'),
              ('Investigating scales via analytical solutions',
               3,
               None,
               '___sec72'),
              ('The displacement and time scales', 3, None, '___sec73'),
              ('Finding the displacement scale from the differential equation',
               3,
               None,
               '___sec74'),
              ('Scaling with free vibrations as time scale',
               3,
               None,
               '___sec75'),
              ('Software', 3, None, '___sec76'),
              ('Choice of $u_c$ close to resonance', 3, None, '___sec77'),
              ('Unit size of all terms in the ODE', 3, None, '___sec78'),
              ('Choice of $u_c$ when $\\psi\\gg\\omega$',
               3,
               None,
               '___sec79'),
              ('Displacement scale based on $I$', 3, None, '___sec80'),
              ('Damped vibrations with forcing',
               2,
               'sec:scale:vib:damped:F',
               'sec:scale:vib:damped:F'),
              ('The exact solution', 3, None, '___sec82'),
              ('Choosing scales', 3, None, '___sec83'),
              ('Choice of $u_c$ at resonance', 3, None, '___sec84'),
              ('Choice of $u_c$ when $\\omega\\gg\\psi$',
               3,
               None,
               '___sec85'),
              ('Choice of $u_c$ when $\\omega\\ll\\psi$',
               3,
               None,
               '___sec86'),
              ('Oscillating electric circuits', 2, None, '___sec87'),
              ('Basic PDE models', 0, None, '___sec88'),
              ('The wave equation', 1, 'sec:scale:wave', 'sec:scale:wave'),
              ('Simple homogeneous Dirichlet conditions',
               2,
               None,
               '___sec90'),
              ('Implementation of the scaled wave equation',
               2,
               None,
               '___sec91'),
              ('Waves on a string', 3, None, '___sec92'),
              ('Detecting an already computed case', 3, None, '___sec93'),
              ('Time-dependent Dirichlet condition',
               2,
               'scale:wave:pde2',
               'scale:wave:pde2'),
              ('Scaling', 3, None, '___sec95'),
              ('Software', 3, None, '___sec96'),
              ('Specific case', 3, None, '___sec97'),
              ('Velocity initial condition',
               2,
               'scale:wave:pde2:Vcond',
               'scale:wave:pde2:Vcond'),
              ('Analytical insight', 3, None, '___sec99'),
              ('Scaling', 3, None, '___sec100'),
              ('Nonzero initial shape', 3, None, '___sec101'),
              ('Variable wave velocity and forcing',
               2,
               'scale:wave:pde2:cvar',
               'scale:wave:pde2:cvar'),
              ('Non-dimensionalization', 3, None, '___sec103'),
              ('Choosing the time scale', 3, None, '___sec104'),
              ('Choosing the spatial scale', 3, None, '___sec105'),
              ('Scaling the velocity initial condition',
               3,
               None,
               '___sec106'),
              ('Damped wave equation',
               2,
               'scale:wave:pde2:damped',
               'scale:wave:pde2:damped'),
              ('A three-dimensional wave equation problem',
               2,
               None,
               '___sec108'),
              ('The diffusion equation',
               1,
               'sec:scale:diffu',
               'sec:scale:diffu'),
              ('Homogeneous 1D diffusion equation',
               2,
               'sec:scale:diffu:homo1D',
               'sec:scale:diffu:homo1D'),
              ('Generalized diffusion PDE', 2, None, '___sec111'),
              ('Jump boundary condition', 2, None, '___sec112'),
              ('Oscillating Dirichlet condition', 2, None, '___sec113'),
              ('Scaling', 3, None, '___sec114'),
              ("Fisher's equation",
               2,
               'sec:scale:diffu:Fisher',
               'sec:scale:diffu:Fisher'),
              ('The convection-diffusion equation',
               1,
               'scale:convdiff',
               'scale:convdiff'),
              ('Convection-diffusion without a force term',
               2,
               None,
               '___sec117'),
              ('Stationary PDE', 2, None, '___sec118'),
              ('Convection-diffusion with a force term',
               2,
               'scale:convdiff',
               'scale:convdiff'),
              ('Advanced PDE models', 0, None, '___sec120'),
              ('The equations of linear elasticity',
               1,
               'scale:elasticity',
               'scale:elasticity'),
              ('The general time-dependent elasticity problem',
               2,
               None,
               '___sec122'),
              ('Software', 3, None, '___sec123'),
              ('Dimensionless stress tensor', 2, None, '___sec124'),
              ('When can the acceleration term be neglected?',
               2,
               'scale:elasticity:waves',
               'scale:elasticity:waves'),
              ('S waves', 3, None, '___sec126'),
              ('P waves', 3, None, '___sec127'),
              ('Time-varying load', 3, None, '___sec128'),
              ('The stationary elasticity problem', 2, None, '___sec129'),
              ('Quasi-static thermo-elasticity', 2, None, '___sec130'),
              ('The Navier-Stokes equations',
               1,
               'sec:scale:ns',
               'sec:scale:ns'),
              ('The momentum equation without body forces',
               2,
               None,
               '___sec132'),
              ('The most common dimensionless form of the Navier-Stokes equations',
               2,
               None,
               '___sec133'),
              ('Scaling of time for low Reynolds numbers',
               2,
               None,
               '___sec134'),
              ('Shear stress as pressure scale', 2, None, '___sec135'),
              ('Including the gravity force', 2, None, '___sec136'),
              ('Oscillating boundary conditions', 2, None, '___sec137'),
              ('The Euler number', 2, None, '___sec138'),
              ('Free surface conditions', 2, None, '___sec139'),
              ('Thermal convection', 1, None, '___sec140'),
              ('Forced convection', 2, None, '___sec141'),
              ('Free convection',
               2,
               'scale:fluid:forced_convection',
               'scale:fluid:forced_convection'),
              ('Governing equations', 3, None, '___sec143'),
              ('Heating by viscous effects', 3, None, '___sec144'),
              ('Relation between density and temperature',
               3,
               None,
               '___sec145'),
              ('Comment on the form of the equation of continuity',
               3,
               None,
               '___sec146'),
              ('The Boussinesq approximation', 3, None, '___sec147'),
              ('Scaling', 3, None, '___sec148'),
              ('The Grashof, Prandtl, and Eckert numbers',
               2,
               None,
               '___sec149'),
              ('Heat transfer at boundaries', 2, None, '___sec150'),
              ('The bidomain model in electrophysiology',
               1,
               'scale:bidomain',
               'scale:bidomain'),
              ('Two-phase porous media flow', 1, None, '___sec152'),
              ('The Euler equations of gas dynamics', 1, None, '___sec153'),
              ('Exercises', 1, None, '___sec154'),
              ('Exercise 1: Perform unit conversion',
               2,
               'sec:scale:exer:US2SI1',
               'sec:scale:exer:US2SI1'),
              ('Problem 2: Scale a simple formula',
               2,
               'sec:scale:exer:ball_y',
               'sec:scale:exer:ball_y'),
              ('Exercise 3: Perform alternative scalings',
               2,
               'sec:scale:exer:decay:cooling:osc',
               'sec:scale:exer:decay:cooling:osc'),
              ('Problem 4: Scale a nonlinear ODE',
               2,
               'sec:scale:exer:ball_y_wdrag',
               'sec:scale:exer:ball_y_wdrag'),
              ('Exercise 5: Implement a scaled model with jump',
               2,
               'sec:scale:exer:decay:jump',
               'sec:scale:exer:decay:jump'),
              ('Exercise 6: Implement a scaled model for cooling',
               2,
               'sec:scale:exer:decay:cooling',
               'sec:scale:exer:decay:cooling'),
              ('Problem 7: Scale variable coefficients',
               2,
               'scale:decay:exer:decay:step',
               'scale:decay:exer:decay:step'),
              ('Exercise 8: Alternative scalings of a cooling model',
               2,
               'scale:decay:exer:cooling:Ts',
               'scale:decay:exer:cooling:Ts'),
              ('Exercise 9: Alternative scalings of a cooling model',
               2,
               'scale:decay:exer:nonlin:logistic2',
               'scale:decay:exer:nonlin:logistic2'),
              ('Exercise 10: Scale projectile motion',
               2,
               'scale:vib:exer:projectile',
               'scale:vib:exer:projectile'),
              ('Problem 11: Scale a predator-pray model',
               2,
               'scale:decay:exer:predpray',
               'scale:decay:exer:predpray'),
              ('Problem 12: Scale a model for competing species',
               2,
               'scale:decay:exer:competing_species',
               'scale:decay:exer:competing_species'),
              ('Problem 13: Find the period of sinusoidal signals',
               2,
               'scale:decay:exer:sine',
               'scale:decay:exer:sine'),
              ('Remarks', 3, None, '___sec168'),
              ('Problem 14: Scale the pendulum equation',
               2,
               'sec:scale:exer:pendulum',
               'sec:scale:exer:pendulum'),
              ("Problem 15: Scale Duffing's equation",
               2,
               'scale:vib:exer:Duffing',
               'scale:vib:exer:Duffing'),
              ('Problem 16: Scale a stationary Couette flow',
               2,
               'scale:vib:exer:stationary_Couette',
               'scale:vib:exer:stationary_Couette'),
              ('Remarks', 3, None, '___sec172'),
              ('Problem 17: Scale a starting Couette flow',
               2,
               'scale:vib:exer:starting_Couette',
               'scale:vib:exer:starting_Couette'),
              ('Exercise 18: Scale Couette flow with pressure gradient',
               2,
               'scale:vib:exer:Couette_wpressure',
               'scale:vib:exer:Couette_wpressure'),
              ('Exercise 19: Suggestions...',
               2,
               'scale::exer:suggest',
               'scale::exer:suggest'),
              ('References', 1, None, '___sec176')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href=".trash82dee82e1274a586571086dca04d00308d3a0d86.html">Scaling of Differential Equations</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#ch:preface" style="font-size: 80%;">Preface</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#scale:dimunit" style="font-size: 80%;">Dimensions and units</a></li>
     <!-- navigation toc: --> <li><a href="#___sec17" style="font-size: 80%;">ODE models</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#___sec88" style="font-size: 80%;">Basic PDE models</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#___sec120" style="font-size: 80%;">Advanced PDE models</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0005"></a>
<!-- !split -->

<center><h1 id="___sec17">ODE models </h1></center> <!-- chapter heading -->

<p>
This chapter introduces the basic techniques of scaling and the ways to
reason about scales. The first class of examples targets exponential
decay models, starting with the simple ordinary differential equation (ODE)
for exponential decay processes: \( u^{\prime}=-au \), with constant \( a>0 \).
Then we progress to various generalizations of this ODE, including nonlinear
versions and systems of ODEs. The next class of examples concerns
second-order ODEs for oscillatory systems, where the simplest
ODE reads \( mu^{\prime\prime} + ku=0 \), with \( m \) and \( k \) as positive constants.
Various extensions with damping and force terms are discussed in detail.

<h1 id="sec:scale:decay">Exponential decay problems</h1>

<h2 id="___sec19">Fundamental ideas </h2>

<p>
Scaling is an extremely useful technique in mathematical modeling and
numerical simulation.  The purpose of the technique is three-fold:

<ol>
<li> Make independent and dependent variables dimensionless.</li>
<li> Make the size of independent and dependent variables about unity.</li>
<li> Reduce the number of independent physical parameters in the model.</li>
</ol>

The first and second item mean that for any variable, denote it by
\( q \), we introduce a corresponding dimensionless variable

$$ \bar q = \frac{q-q_0}{q_c},$$

where \( q_0 \) is a reference value of \( q \) (\( q_0=0 \) is a common choice) and
\( q_c \) is a characteristic size of \( |q| \). Since the numerator and denominator
have the same dimension, \( \bar q \) becomes a dimensionless number.

<p>
If \( q_c \) is the maximum value of \( |q-q_0| \), we see that \( 0 < |\bar
q|\leq 1 \). How to find \( q_c \) is sometimes the big challenging of
scaling. Examples will illustrate various approaches to meet this
challenge.

<p>
The forthcoming text has the following goals.

<ul>
 <li> Teach the technical steps of making a mathematical model, based
   on differential equations, dimensionless.</li>
 <li> Describe various techniques for reasoning about the scales, i.e.,
   finding the characteristic sizes of quantities.</li>
 <li> Teach how to identify and interpret dimensionless numbers arising
   from the scaling process.</li>
 <li> Provide a lot of different examples on making models dimensionless
   with physically correct scales.</li>
 <li> Demonstrate software tools for computing with numbers with units,
   including doing unit conversions.</li>
 <li> Introduce software tools for creating user interfaces that
   can automatically perform unit conversion.</li>
 <li> Use symbolic software (SymPy) to derive exact solutions of differential
   equations.</li>
 <li> Explain how to run a dimensionless model with software developed
   for the problem with dimensions.
<!-- Topics not covered --></li>
</ul>

<div class="alert alert-block alert-danger alert-text-normal"><b>Limited scope.</b>
Literature covering scaling and non-dimensionalization often also discuss
topics such as deriving functional relationships based on dimensional
reasoning, as well as dynamic similarity and use of dimensionless groups in
experimental investigations <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#Douglas_et_al_1979">[3]</a> <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#Logan_1987">[4]</a>.
These topics are not covered herein, because our focus is strictly
on making models based on differential equations dimensionless.
</div>


<h2 id="___sec20">The basic model problem </h2>

<p>
Processes undergoing exponential reduction can be modeled by the ODE
problem

$$
\begin{equation}
u'(t) = -au(t),\quad u(0)=I,
\tag{2}
\end{equation}
$$

where \( a,I>0 \) are prescribed constants and \( u(t) \) is the unknown function.
For this particular model, we can easily derive the solution, \( u(t)=Ie^{-at} \),
which is helpful to have in mind during the scaling process.

<h3 id="___sec21">Example: Population dynamics </h3>

<p>
The evolution of a population of humans, animals, cells, etc.,
under unlimited access to resources, can be
modeled by <a href="#mjx-eqn-2">(2)</a>. Then \( u \) is the number of
individuals in the population, strictly speaking an integer, but well
modeled by a real number in large populations.
The parameter \( a \) is the increase in the number of individuals per
time and per individual.

<h3 id="___sec22">Example: Decay of pressure with altitude </h3>

<p>
The simple model <a href="#mjx-eqn-2">(2)</a> also governs the pressure
in the atmosphere (under many assumptions). In this case \( u \) is the
pressure, measured in \( \hbox{Nm}^{-2} \); \( t \) is the hight in meters;
and \( a=M/(R^*T) \), where
\( M \) is the molar mass of the Earth's air (0.029 kg/mol),
\( R^* \) is the universal
gas constant (\( 8.314\,\frac{\hbox{Nm}}{\hbox{mol K}} \)),
and \( T \) is the temperature in Kelvin (K).
The temperature depends on the hight so we have \( a=a(t) \).

<h2 id="sec:scale:decay:steps">The technical steps of the scaling procedure</h2>

<h3 id="___sec24">Step 1: Identify independent and dependent variables </h3>

<p>
There is one independent variable, time \( t \), and one dependent variable,
\( u \).

<h3 id="___sec25">Step 2: Make independent and dependent variables dimensionless </h3>

<p>
We introduce a new dimensionless \( t \), called \( \bar t \), defined by
$$
\begin{equation}
\bar t = \frac{t}{t_c},
\tag{3}
\end{equation}
$$

where \( t_c \) is a <em>characteristic value</em> of \( t \). Similarly,
we introduce a dimensionless \( u \), named \( \bar u \), according to
$$
\begin{equation}
\bar u = \frac{u}{u_c},
\tag{4}
\end{equation}
$$

where \( u_c \) is a constant <em>characteristic size</em> of \( u \). When \( u \) has a specific
interpretation, say when <a href="#mjx-eqn-2">(2)</a> models pressure
in an atmospheric layer, \( u_c \) would be referred to as characteristic pressure.
For a decaying population, \( u \) may be a characteristic number of
members in the population, e.g., the initial population \( I \).

<h3 id="___sec26">Step 3: Derive the model involving only dimensionless variables </h3>

<p>
The next task is to insert the new dimensionless variables in the
governing mathematical model. That is, we replace \( t \) by \( t_c\bar t \)
and \( u \) by \( u_c\bar u \) in <a href="#mjx-eqn-2">(2)</a>. The derivative
with respect to \( \bar t \) is derived as

$$ \frac{du}{dt} = \frac{d (u_c\bar u)}{d\bar t}\frac{d\bar t}{dt}
= u_c\frac{d\bar u}{d\bar t}\frac{1}{t_c} =
\frac{u_c}{t_c}\frac{d\bar u}{d\bar t}\tp
$$

The model <a href="#mjx-eqn-2">(2)</a> now becomes

$$
\begin{equation}
\frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = -au_c\bar u,\quad u_c\bar u(0)=I\tp
\tag{5}
\end{equation}
$$

<h3 id="___sec27">Step 4: Make each term dimensionless </h3>

<p>
Equation <a href="#mjx-eqn-5">(5)</a> still has terms with
dimensions. To make each term dimensionless, we usually divide by
the coefficient in front of the term with the highest time derivative
(but dividing by any coefficient in any term will do). The result is

$$
\begin{equation}
\frac{d\bar u}{d\bar t} = -at_c\bar u,\quad \bar u(0)=u_c^{-1}I
\tp
\tag{6}
\end{equation}
$$

<h3 id="___sec28">Step 5: Estimate the scales </h3>

<p>
A characteristic quantity like \( t_c \) reflects the time scale in the
problem. Estimating such a time scale is certainly
the most challenging part of the scaling procedure. There are different
ways to reason. The first is to aim at a size of \( \bar u \) and its derivatives
that is of order unity. If \( u_c \) is chosen such that \( |\bar u| \) is
of size unity, we see from <a href="#mjx-eqn-6">(6)</a> that
\( d\bar u/d\bar t \) is of the size of \( \bar u \) (i.e., unity)
if we choose \( t_c = 1/a \).

<p>
Alternatively, we may look at a special case of the model where we have
analytical insight. In the present problem we are lucky to know the
exact solution for any value of the input data. For exponential
decay, \( u(t)\sim e^{-at} \), it is common to define a characteristic time
scale \( t_c \) as the time it takes to reduce \( u \) by a factor of \( 1/e \) (also
called the <em>e-folding time</em>):

$$ e^{-at_c} = \frac{1}{e}e^{-a\cdot 0}\quad\Rightarrow\quad e^{-at_c}=e^{-1},
$$

from which it follows that \( t_c = 1/a \).

<p>
In this example, two different, yet common ways of reasoning, lead to the
same value of \( t_c \). However, instead of using the e-folding time we
could use the half-time of the exponential decay as characteristic
time, which is also a very common measure of the time scale in such
processes. The half time is defined as the time it takes to halve \( u \):

$$ e^{-at_c} = \frac{1}{2}e^{-a\cdot 0}
\quad\Rightarrow\quad t_c = a^{-1}\ln 2\tp$$

There is a factor \( \ln 2 =0.69 \) difference from the other \( t_c \) value.
As long as the factor is not an order of magnitude or more different,
we do not pay attention to such small differences.
Although \( t_c = a^{-1}\ln 2 \) is a fine time scale to be used in this
problem, it leads to a scaled differential equation \( u'=-(\ln 2) u \),
which is fine, but an unusual form. People tend to prefer \( u'=-u \),
which arises from \( t_c=1/a \). We shall therefore use the latter
time scale.

<p>
Regarding \( u_c \), we may look at the initial condition
and realize that the choice \( u_c=I \) makes \( \bar u(0)=1 \). For \( \bar t>0 \)
we know that \( \bar u \) is decreasing, so \( u_c=I \)
gives us \( \bar u\leq 1 \), which is always a goal
(alternatively, we may look to analytical insight, \( u(t)=Ie^{-at} \), to
see that \( u\leq I \), such that \( u_c=I \) gives \( \bar u\leq 1 \)).

<p>
With \( t_c=1/a \) and \( u_c=I \), we have the final dimensionless model

$$
\begin{equation}
\frac{d\bar u}{d\bar t} = -\bar u,\quad \bar u(0)=1
\tp
\tag{7}
\end{equation}
$$

This is a remarkable result in the sense that <em>all physical parameters</em>
(\( a \) and \( I \))
are removed from the model! Or more precisely, there are no physical input
parameters to assign
before using the model. In particular, numerical investigations of the original
model <a href="#mjx-eqn-2">(2)</a> would need experiments with different
\( a \) and \( I \) values, while numerical investigations of
<a href="#mjx-eqn-7">(7)</a> can be limited to <em>a single run</em>! As soon
as we have computed the curve \( \bar u(\bar t) \), we can find the
solution \( u(t) \) of <a href="#mjx-eqn-2">(2)</a> by

$$
\begin{equation}
u(t) = u_c\bar u(t/t_c) = I\bar u(at)
\tp
\tag{8}
\end{equation}
$$

This particular transformation actually means stretching the \( \bar t \) and
\( \bar u \) axes in a plot of \( \bar u(\bar t) \) by the factors \( a \) and \( I \),
respectively.

<p>
It is very common to drop the bars when the scaled problem has been
derived and work further with <a href="#mjx-eqn-7">(7)</a> simply
written as

$$
\frac{du}{dt} = -u,\quad u(0)=1
\tp
$$

<h2 id="sec:scale:decay:prog">Making software for utilizing the scaled model</h2>

<p>
Software for solving <a href="#mjx-eqn-2">(2)</a> could take advantage
of the fact that only one simulation of <a href="#mjx-eqn-7">(7)</a>
is necessary. As soon as we have \( \bar u(\bar t) \) accessible,
a simple scaling <a href="#mjx-eqn-8">(8)</a> computes the real \( u(t) \)
for any given input data \( a \) and \( I \). Although the numerical computation of
\( u(t) \) from <a href="#mjx-eqn-2">(2)</a> is very fast in this simple model
problem, using <a href="#mjx-eqn-8">(8)</a> is very much faster than
computing a full numerical solution in more complicated
differential equation problems.

<p>
We can compute with the dimensionless model <a href="#mjx-eqn-7">(7)</a>
in two ways, either make a solver for <a href="#mjx-eqn-7">(7)</a>
or reuse a solver for <a href="#mjx-eqn-2">(2)</a> with the parameters
appropriately set (\( I=1 \), \( a=1 \)).
The latter approach has the advantage of giving us
software that works both with a dimensionless model and a model
with dimensions and all the original physical parameters.

<h3 id="___sec30">Software for the original problem with dimensions </h3>

<p>
We base our solver for
<a href="#mjx-eqn-7">(7)</a> on a solver for <a href="#mjx-eqn-2">(2)</a>.
Assume that we have some module <code>decay.py</code> that offers the following
functions:

<ul>
  <li> <code>solver(I, a, T, dt, theta=0.5)</code> for returning the solution arrays
    <code>u</code> and <code>t</code> for <a href="#mjx-eqn-2">(2)</a> solved by the \( \theta \) rule.</li>
  <li> <code>read_command_line_argparse()</code> for reading parameters in the problem
    from the command line and returning them: <code>I</code>, <code>a</code>, <code>T</code>, <code>theta</code> (\( \theta \)),
    and a list of \( \Delta t \) values for time steps. (We shall only make
    use of the first \( \Delta t \) value.)</li>
</ul>

The basic statements for solving <a href="#mjx-eqn-2">(2)</a> are
then

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">decay</span> <span style="color: #008000; font-weight: bold">import</span> solver, read_command_line_argparse
I, a, T, theta, dt_values <span style="color: #666666">=</span> read_command_line_argparse()
u, t <span style="color: #666666">=</span> solver(I, a, T, dt_values[<span style="color: #666666">0</span>], theta)

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> plot, show
plot(t, u)
show()
</pre></div>
<p>
The module <a href="http://tinyurl.com/o8pb3yy/decay.py" target="_self"><tt>decay.py</tt></a> is developed
and explained in

<p>
Section refaux{softeng1:basic:module} in
the book <a href="http://tinyurl.com/nclmcng/doc/pub/book" target="_self">Finite Difference Computing with Exponential Decay Models</a> <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#Langtangen_decay">[5]</a>.

<p>
To solve the dimensionless problem, just fix \( I=1 \) and \( a=1 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">I, a, T, theta, dt_values <span style="color: #666666">=</span> read_command_line_argparse()
u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=1</span>, T<span style="color: #666666">=</span>T, dt<span style="color: #666666">=</span>dt_values[<span style="color: #666666">0</span>], theta<span style="color: #666666">=</span>theta)
</pre></div>

<h3 id="___sec31">Avoiding unnecessary computations </h3>

<p>
A key observation, as mentioned, is that we need to solve the problem
<a href="#mjx-eqn-7">(7)</a> only once. All solutions
corresponding to different \( I \) and \( a \) values in the original physical
problem can be recovered by scaling this single solution with formula
<a href="#mjx-eqn-8">(8)</a>.  We may therefore want to make software that
takes advantage of this fact. When requesting a solution, we see if it
has already been computed and stored in a file, and if so, the data
can be retrieved from file, otherwise we have to compute a new
solution and store it in a file.

<p>
A very plain solution to the problem is found in the file
<a href="http://tinyurl.com/o8pb3yy/decay_scaled_v1.py" target="_self"><tt>decay_scaled_v1.py</tt></a>.
The <code>np.savetxt</code> function saves a two-dimensional arrays (&quot;table&quot;) to
a text file, and the <code>np.loadtxt</code> function can load the data back
into the program. A better solution to this problem is obtained
by using the <code>joblib</code> package as described next.

<h3 id="___sec32">Implementation with joblib </h3>

<p>
The Python package <code>joblib</code> has functionality that is very convenient
for implementing the <code>solver_scaled</code> function. The first time a
function is called with a set of arguments, the statements in the
function are executed and the return value is saved to file. If the
function is called again with the same set of arguments, the
statements in the function are not executed, but the return value is
read from file. In computer science, one would say that <code>joblib</code> in
this way provides <em>memorization</em> functionality for Python functions.
This functionality is particularly aimed at large-scale computations
with arrays that one would like to avoid being recomputed. We
illustrate the technique here in a very simple mathematical context.

<p>
First we make a <code>solver_scaled</code> function for the scaled
model that just calls up a <code>solver_unscaled</code> for the problem with
dimensions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">decay</span> <span style="color: #008000; font-weight: bold">import</span> solver_unscaled
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_scaled</span>(T, dt, theta):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u&#39;=-u, u(0)=1 for (0,T] with step dt and theta method.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Computing the numerical solution&#39;</span>
    <span style="color: #008000; font-weight: bold">return</span> solver_unscaled(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=1</span>, T<span style="color: #666666">=</span>T, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)
</pre></div>
<p>
Then we create some &quot;computer memory on disk&quot;, i.e., some disk space to
store the result of a call to the <code>solver_scaled</code> function. Thereafter,
we redefine the name <code>solver_scaled</code> to a new function, created
by <code>joblib</code>, which calls our original <code>solver_scaled</code> function
if necessary and otherwise loads data from file:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">joblib</span>
disk_memory <span style="color: #666666">=</span> joblib<span style="color: #666666">.</span>Memory(cachedir<span style="color: #666666">=</span><span style="color: #BA2121">&#39;temp&#39;</span>)
solver_scaled <span style="color: #666666">=</span> disk_memory<span style="color: #666666">.</span>cache(solver_scaled)
</pre></div>
<p>
The solutions are actually stored in files in the cache directory <code>temp</code>.

<p>
A typical use case is to read values from the command line,
solve the unscaled problem (if necessary), scale the solution, and visualize
the solution with dimension:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">decay</span> <span style="color: #008000; font-weight: bold">import</span> unscale, read_command_line_argparse

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    <span style="color: #408080; font-style: italic"># Read parameters, solve and plot</span>
    I, a, T, theta, dt_values <span style="color: #666666">=</span> read_command_line_argparse()
    dt <span style="color: #666666">=</span> dt_values[<span style="color: #666666">0</span>]  <span style="color: #408080; font-style: italic"># use only the first dt value</span>
    u_scaled, t_scaled <span style="color: #666666">=</span> solver_scaled(T, dt, theta)
    u, t <span style="color: #666666">=</span> unscale(u_scaled, t_scaled, I, a)

    plt<span style="color: #666666">.</span>figure()
    plt<span style="color: #666666">.</span>plot(t_scaled, u_scaled)
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;scaled time&#39;</span>); plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;scaled velocity&#39;</span>)
    plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Universial solution of scaled problem&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp1.png&#39;</span>);  plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp1.pdf&#39;</span>)

    plt<span style="color: #666666">.</span>figure()
    plt<span style="color: #666666">.</span>plot(t, u)
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;t&#39;</span>); plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
    plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;I=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, a=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (I, a, theta))
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp2.png&#39;</span>); plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp2.pdf&#39;</span>)
    plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
The complete code resides in the file
<a href="http://tinyurl.com/o8pb3yy/decay_scaled.py" target="_self"><tt>decay_scaled.py</tt></a>.
A plot of the scaled and unscaled solution appears in Figure
<a href="#sec:decay:fig:simplest">2</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Scaled (left) and unscaled (right) exponential decay. <div id="sec:decay:fig:simplest"></div> </p></center>
<p><img src="fig-scaling/decay.png" align="bottom" width=800></p>
</center>

<p>
Note that we write a message <code>Computing the numerical solution</code> inside
the <code>solver_scaled</code> function. We can then easily detect when
the solution is actually computed and when it is simply read from file.
Here is a demo:

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; # Very first run
Terminal&gt; python decay_scaled.py --T 7 --a 1 --I 0.5 --dt 0.2
[Memory] Calling __main__--home-hpl...
solver_scaled-alias(7.0, 0.2, 0.5)
Computing the numerical solution

Terminal&gt; # No change of T, dt, theta - can reuse solution in file
Terminal&gt; python decay_scaled.py --T 7 --a 4 --I 2.5 --dt 0.2

Terminal&gt; # Change of dt, must recompute
Terminal&gt; python decay_scaled.py --T 7 --a 4 --I 2.0 --dt 0.5
[Memory] Calling __main__--home-hpl...
solver_scaled-alias(7.0, 0.5, 0.5)
Computing the numerical solution

Terminal&gt; # Change of dt again, but dt=0.2 is already in a file
Terminal&gt; python decay_scaled.py --T 7 --a 0.5 --I 1 --dt 0.2
</pre></div>
<p>
We realize that <code>joblib</code> has access to all previous runs and does not
recompute unless it is strictly required. Our previous implementation
without <code>joblib</code>
used only one file (for one numerical case)
and will therefore perform many more calls to
<code>solver_unscaled</code>.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>On the implementation of a simple memoize function.</b>
A memoized function recalls
previous results when the same set
of arguments is encountered. That is, the function caches its results.
A simple implementation stores the arguments in a function call and
the returned results in a
dictionary, and if the arguments are seen again, one looks up
in the dictionary and return previously computed results:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Memoize</span>:
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, f):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>f <span style="color: #666666">=</span> f
        <span style="color: #008000">self</span><span style="color: #666666">.</span>memo <span style="color: #666666">=</span> {}  <span style="color: #408080; font-style: italic"># map arguments to results</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__call__</span>(<span style="color: #008000">self</span>, <span style="color: #666666">*</span>args):
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> args <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>memo:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>memo[args] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>f(<span style="color: #666666">*</span>args)
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>memo[args]

<span style="color: #408080; font-style: italic"># Wrap my_compute_function(arg1, arg2, ...)</span>
my_compute_function <span style="color: #666666">=</span> Memoize(my_compute_function)
</pre></div>
<p>
The memoize functionality in <code>joblib.Memory</code> is more sophisticated and
can work very efficiently with large array data structures as arguments.
Note that the simple version above can only be used when all arguments to
the function <code>f</code> are immutable (since the key in a dictionary has to be
immutable).
</div>


<h2 id="sec:scale:decay:body">Scaling a generalized problem</h2>

<p>
Now we consider an extension of the exponential decay ODE to the
form

$$
\begin{equation}
u'(t) = -au(t) + b,\quad u(0)=I
\tag{9}
\tp
\end{equation}
$$

One particular model, with constant \( a \) and \( b \),
is a spherical micro-organism falling in air,

$$
\begin{equation}
u' = - \frac{3\pi d\mu}{\varrho_b V} u + g\left(\frac{\varrho}{\varrho_b} -1\right),
\tag{10}
\end{equation}
$$

where \( d \), \( \mu \), \( \varrho_b \), \( \varrho \), \( V \), and \( g \) are physical
parameters. The function \( u(t) \) represents the vertical velocity,
being positive upwards.
We shall use this model in the following.

<h3 id="___sec34">Exact solution </h3>

<p>
It can be handy to have the exact solution for reference, in case
of constant \( a \) and \( b \):

$$ \uex(t) = \frac{e^{-at}}{a}\left( b(e^{at}-1) + aI\right)
\tp
$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Solving differential equations in SymPy.</b>
It can be very useful to use a symbolic computation tool such as SymPy
to aid us in solving differential equations.
Let us therefore demonstrate how SymPy can be used to find this solution.
First we define the parameters in the problem as symbols
and \( u(t) \) as a function:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> t, a, b, I <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;t a b I&#39;</span>, real<span style="color: #666666">=</span><span style="color: #008000">True</span>, positive<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> u <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;u&#39;</span>, cls<span style="color: #666666">=</span>Function)
</pre></div>
<p>
The next task is to define the differential equation, either as
a symbolic expression that is to equal zero, or as
an equation <code>Eq(lhs, rhs)</code> with <code>lhs</code> and <code>rhs</code> as expressions for
the left- and right-hand side):

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #408080; font-style: italic"># Define differential equation</span>
<span style="color: #666666">&gt;&gt;&gt;</span> eq <span style="color: #666666">=</span> diff(u(t), t) <span style="color: #666666">+</span> a<span style="color: #666666">*</span>u(t) <span style="color: #666666">-</span> b
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #408080; font-style: italic"># or</span>
<span style="color: #666666">&gt;&gt;&gt;</span> eq <span style="color: #666666">=</span> Eq(diff(u(t), t), <span style="color: #666666">-</span>a<span style="color: #666666">*</span>u(t) <span style="color: #666666">+</span> b)
</pre></div>
<p>
The differential equation can be solved by the <code>dsolve</code> function, yielding
an equation of the form <code>u(t) == expression</code>. We want to grab the
expression on the right-hand side as our solution:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> sol <span style="color: #666666">=</span> dsolve(eq, u(t))
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> sol
u(t) <span style="color: #666666">==</span> (b <span style="color: #666666">+</span> exp(a<span style="color: #666666">*</span>(C1 <span style="color: #666666">-</span> t)))<span style="color: #666666">/</span>a
<span style="color: #666666">&gt;&gt;&gt;</span> u <span style="color: #666666">=</span> sol<span style="color: #666666">.</span>rhs                    <span style="color: #408080; font-style: italic"># grab solution</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> u
(b <span style="color: #666666">+</span> exp(a<span style="color: #666666">*</span>(C1 <span style="color: #666666">-</span> t)))<span style="color: #666666">/</span>a
</pre></div>
<p>
The solution contains the unknown integration constant <code>C1</code>, which must
be determined by the initial condition. We form the equation arising
from the initial condition \( u(0)=I \):

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> C1 <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;C1&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> eq <span style="color: #666666">=</span> Eq(u<span style="color: #666666">.</span>subs(t, <span style="color: #666666">0</span>), I)   <span style="color: #408080; font-style: italic"># substitute t by 0 in u</span>
<span style="color: #666666">&gt;&gt;&gt;</span> sol <span style="color: #666666">=</span> solve(eq, C1)
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> sol
[log(I<span style="color: #666666">*</span>a <span style="color: #666666">-</span> b)<span style="color: #666666">/</span>a]
</pre></div>
<p>
The one solution that was found must then be substituted back in the
expression <code>u</code> to yield the final solution:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> u <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(C1, sol[<span style="color: #666666">0</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> u
(b <span style="color: #666666">+</span> exp(a<span style="color: #666666">*</span>(<span style="color: #666666">-</span>t <span style="color: #666666">+</span> log(I<span style="color: #666666">*</span>a <span style="color: #666666">-</span> b)<span style="color: #666666">/</span>a)))<span style="color: #666666">/</span>a
</pre></div>
<p>
As in mathematics with pen and paper, we strive to simplify
expressions also in symbolic computing software.
This frequently requires some trial and error
process with SymPy's simplification functions. A very standard
first try is to expand everything and run simplification algorithms:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> u <span style="color: #666666">=</span> simplify(expand(u))
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> u
(I<span style="color: #666666">*</span>a <span style="color: #666666">+</span> b<span style="color: #666666">*</span>exp(a<span style="color: #666666">*</span>t) <span style="color: #666666">-</span> b)<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t)<span style="color: #666666">/</span>a
</pre></div>
<p>
Doing <code>latex(u)</code> automatically converts the expression to LaTeX syntax
for inclusion in reports.
</div>


<h3 id="___sec35">Theory </h3>

<p>
The challenges in our scaling is to find the right \( u_c \) and \( t_c \)
scales. From <a href="#mjx-eqn-9">(9)</a> we see that if \( u'\rightarrow 0 \)
as \( t\rightarrow\infty \), \( u \) approaches the constant value \( b/a \). It can be
convenient to let the scaled \( \bar u\rightarrow 1 \) as
we approach the \( d\bar u/d\bar t = 0 \) state. This idea points to choosing

$$
\begin{equation}
u_c = \frac{b}{a} = g\left(\frac{\varrho}{\varrho_b} -1\right)\left(\frac{3\pi d\mu}{\varrho_b V}\right)^{-1}
\tp
\tag{11}
\end{equation}
$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>On the sign of the scaled velocity.</b>
A little note on the sign of \( u_c \) is necessary here.
With \( \varrho_b < \varrho \), the buoyancy force upwards wins over the
gravity force downwards, and the body will move upwards. In this case,
the terminal velocity \( u_c > 0 \). When \( \varrho_b > \varrho \), we get
a motion downwards, and \( u_c < 0 \). The corresponding \( u \) is then also
negative, but the scaled velocity \( u/u_c \), becomes positive.
</div>


<p>
Inserting \( u = u_c\bar u = b\bar u/a \) and \( t=t_c\bar t \) in
<a href="#mjx-eqn-9">(9)</a> leads to

$$
\frac{d\bar u}{d\bar t} = -t_c a\bar u + \frac{t_c}{u_c}b,
\quad \bar u(0) = I\frac{a}{b}
\tp
$$

We want the scales such that \( d\bar u/d\bar t \) and \( \bar u \) are
about unity.
To balance the size of \( \bar u \) and \( d\bar u/d\bar t \) we must
therefore choose
\( t_c = 1/a \), resulting in the scaled ODE problem

$$
\begin{equation}
\frac{d\bar u}{d\bar t} = -\bar u + 1,\quad u(0)=\beta,
\tag{12}
\end{equation}
$$

where \( \beta \) is a dimensionless number,
$$
\begin{equation}
\beta = \frac{I}{u_c} = I\frac{a}{b},
\tag{13}
\end{equation}
$$

reflecting the ratio of the initial velocity and the
terminal (\( t\rightarrow \infty \)) velocity \( b/a \).
Scaling normally ends up with one or more dimensionless parameters,
such as \( \beta \) here, containing ratios of physical effects in
the model. Many more examples on dimensionless parameters will appear
in later sections.

<p>
The analytical solution of the scaled model
<a href="#mjx-eqn-12">(12)</a> reads

$$
\begin{equation}
\bar\uex(t) =
e^{-t}\left( e^{t}-1 + \beta\right) = 1 + (\beta -1)e^{-t}\tp
\tag{14}
\end{equation}
$$

<p>
The result <a href="#mjx-eqn-12">(12)</a> with the
solution <a href="#mjx-eqn-14">(14)</a> is actually
astonishing if \( a \) and \( b \) are as in <a href="#mjx-eqn-10">(10)</a>:
the six parameters \( d \), \( \mu \), \( \varrho_b \), \( \varrho \), \( V \), and \( g \)
are conjured to one:
$$ \beta = I\frac{3\pi d\mu}{\varrho_b V}
\frac{1}{g}\left(\frac{\varrho}{\varrho_b} -1\right)^{-1},
$$

which is an enormous simplification of the problem if our aim is to
investigate how \( u \) varies with the physical input parameters in
the model.
In particular, if the motion starts from rest, \( \beta=0 \), and
there are no physical parameters in the scaled model!
We can then perform a single simulation and recover all physical
cases by the unscaling procedure. More precisely,
having computed \( \bar u(\bar t) \) from <a href="#mjx-eqn-12">(12)</a>,
we can use

$$
\begin{equation}
u(t) = \frac{b}{a}\bar u(at),
\tag{15}
\end{equation}
$$

to scale us back to the original
problem again.
We observe that <a href="#mjx-eqn-12">(12)</a> can utilize a solver
for <a href="#mjx-eqn-9">(9)</a> by setting \( a=1 \), \( b=1 \), and \( I=\beta \).
Given some implementation of a solver for <a href="#mjx-eqn-9">(9)</a>,
say <code>solver(I, a, b, T, dt, theta)</code>,
the scaled model is run by <code>solver(beta, 1, 1, T, dt, theta)</code>.

<h3 id="___sec36">Software </h3>

<p>
We may develop a solver for the scaled problem that uses <code>joblib</code>
to cache solutions with the same \( \beta \), \( \Delta t \), and \( T \).
For now we fix \( \theta=0.5 \).
The module <a href="http://tinyurl.com/o8pb3yy/decay_vc.py" target="_self"><tt>decay_vc.py</tt></a>
(see ref[the section ref{decay:general}][ in <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#Langtangen_decay">[5]</a>[the
section <a href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book006.html#implementation-of-the-generalized-model-problem" target="_self">Implementation of the generalized model problem</a>
<a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#Langtangen_decay">[5]</a>] for details)
has a function
<code>solver(I, a, b, T, dt, theta)</code> for solving \( u'(t)=-a(t)u(t)+b(t) \) for
\( t\in (0,T] \), \( u(0)=I \), with time step <code>dt</code>.
We reuse this function and call it with \( a=b=1 \) and \( I=\beta \) to solve
the scaled problem:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">decay_vc</span> <span style="color: #008000; font-weight: bold">import</span> solver <span style="color: #008000; font-weight: bold">as</span> solver_unscaled

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_scaled</span>(beta, T, dt, theta<span style="color: #666666">=0.5</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u&#39;=-u+1, u(0)=beta for (0,T]</span>
<span style="color: #BA2121; font-style: italic">    with step dt and theta method.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Computing the numerical solution&#39;</span>
    <span style="color: #008000; font-weight: bold">return</span> solver_unscaled(
        I<span style="color: #666666">=</span>beta, a<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> t: <span style="color: #666666">1</span>, b<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> t: <span style="color: #666666">1</span>,
        T<span style="color: #666666">=</span>T, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">joblib</span>
disk_memory <span style="color: #666666">=</span> joblib<span style="color: #666666">.</span>Memory(cachedir<span style="color: #666666">=</span><span style="color: #BA2121">&#39;temp&#39;</span>)
solver_scaled <span style="color: #666666">=</span> disk_memory<span style="color: #666666">.</span>cache(solver_scaled)
</pre></div>
<p>
If we want to plot the physical solution, we need an <code>unscale</code> function,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">unscale</span>(u_scaled, t_scaled, d, mu, rho, rho_b, V):
    a, b <span style="color: #666666">=</span> ab(d, mu, rho, rho_b, V)
    <span style="color: #008000; font-weight: bold">return</span> (b<span style="color: #666666">/</span>a)<span style="color: #666666">*</span>u_scaled, a<span style="color: #666666">*</span>t_scaled

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ab</span>(d, mu, rho, rho_b, V):
    g <span style="color: #666666">=</span> <span style="color: #666666">9.81</span>
    a <span style="color: #666666">=</span> <span style="color: #666666">3*</span>pi<span style="color: #666666">*</span>d<span style="color: #666666">*</span>mu<span style="color: #666666">/</span>(rho_b<span style="color: #666666">*</span>V)
    b <span style="color: #666666">=</span> g<span style="color: #666666">*</span>(rho<span style="color: #666666">/</span>rho_b <span style="color: #666666">-</span> <span style="color: #666666">1</span>)
    <span style="color: #008000; font-weight: bold">return</span> a, b
</pre></div>
<p>
Looking at droplets of water in air, we can fix some of the parameters
and let the size parameter \( d \) be the one for experimentation.
The following function sets physical parameters, computes \( \beta \),
runs the solver for the scaled problem (<code>joblib</code> detects
if it is necessary), and finally plots the scaled curve
\( \bar u(\bar t) \) and the unscaled curve \( u(t) \).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>(dt<span style="color: #666666">=0.075</span>, <span style="color: #408080; font-style: italic"># Time step, scaled problem</span>
         T<span style="color: #666666">=7.5</span>,    <span style="color: #408080; font-style: italic"># Final time, scaled problem</span>
         d<span style="color: #666666">=0.001</span>,  <span style="color: #408080; font-style: italic"># Diameter (unscaled problem)</span>
         I<span style="color: #666666">=0</span>,      <span style="color: #408080; font-style: italic"># Initial velocity (unscaled problem)</span>
         ):
    <span style="color: #408080; font-style: italic"># Set parameters, solve and plot</span>
    rho <span style="color: #666666">=</span> <span style="color: #666666">0.00129E+3</span>  <span style="color: #408080; font-style: italic"># air</span>
    rho_b <span style="color: #666666">=</span> <span style="color: #666666">1E+3</span>      <span style="color: #408080; font-style: italic"># density of water</span>
    mu <span style="color: #666666">=</span> <span style="color: #666666">0.001</span>        <span style="color: #408080; font-style: italic"># viscosity of water</span>
    <span style="color: #408080; font-style: italic"># Asumme we have list or similar for d</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">isinstance</span>(d, (<span style="color: #008000">list</span>,<span style="color: #008000">tuple</span>,np<span style="color: #666666">.</span>ndarray)):
        d <span style="color: #666666">=</span> [d]

    legends1 <span style="color: #666666">=</span> []
    legends2 <span style="color: #666666">=</span> []
    plt<span style="color: #666666">.</span>figure(<span style="color: #666666">1</span>)
    plt<span style="color: #666666">.</span>figure(<span style="color: #666666">2</span>)
    betas <span style="color: #666666">=</span> []     <span style="color: #408080; font-style: italic"># beta values already computed (for plot)</span>

    <span style="color: #008000; font-weight: bold">for</span> d_ <span style="color: #AA22FF; font-weight: bold">in</span> d:
        V <span style="color: #666666">=</span> <span style="color: #666666">4*</span>pi<span style="color: #666666">/3*</span>(d_<span style="color: #666666">/2.</span>)<span style="color: #666666">**3</span>  <span style="color: #408080; font-style: italic"># volume</span>
        a, b <span style="color: #666666">=</span> ab(d_, mu, rho, rho_b, V)
        beta <span style="color: #666666">=</span> I<span style="color: #666666">*</span>a<span style="color: #666666">/</span>b
        <span style="color: #408080; font-style: italic"># Restrict to 3 digits in beta</span>
        beta <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(<span style="color: #008000">round</span>(beta, <span style="color: #666666">3</span>))

        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;beta=</span><span style="color: #BB6688; font-weight: bold">%.3f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> beta
        u_scaled, t_scaled <span style="color: #666666">=</span> solver_scaled(beta, T, dt)

        <span style="color: #408080; font-style: italic"># Avoid plotting curves with the same beta value</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> beta <span style="color: #AA22FF; font-weight: bold">in</span> betas:
            plt<span style="color: #666666">.</span>figure(<span style="color: #666666">1</span>)
            plt<span style="color: #666666">.</span>plot(t_scaled, u_scaled)
            plt<span style="color: #666666">.</span>hold(<span style="color: #BA2121">&#39;on&#39;</span>)
            legends1<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;beta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> beta)
        betas<span style="color: #666666">.</span>append(beta)

        plt<span style="color: #666666">.</span>figure(<span style="color: #666666">2</span>)
        u, t <span style="color: #666666">=</span> unscale(u_scaled, t_scaled, d_, mu, rho, rho_b, V)
        plt<span style="color: #666666">.</span>plot(t, u)
        plt<span style="color: #666666">.</span>hold(<span style="color: #BA2121">&#39;on&#39;</span>)
        legends2<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;d=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> [mm]&#39;</span> <span style="color: #666666">%</span> (d_<span style="color: #666666">*1000</span>))
    plt<span style="color: #666666">.</span>figure(<span style="color: #666666">1</span>)
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;scaled time&#39;</span>); plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;scaled velocity&#39;</span>)
    plt<span style="color: #666666">.</span>legend(legends1, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;lower right&#39;</span>)
</pre></div>
<p>
The most complicated part of the code is related to plotting, but
this part can be skipped when trying to understand how we work with
a scaled model to perform the computations.
The complete program is found in the file
<a href="http://tinyurl.com/o8pb3yy/falling_body.py" target="_self"><tt>falling_body.py</tt></a>.

<p>
Since \( I=0 \) implies \( \beta=0 \), we can run different \( d \) values without
any need to recompute \( \bar u(\bar t) \) as long as we assume the particle
starts from rest.

<p>
From the scaling, we see that \( u_c = b/a\sim d^{-2} \) and
also that \( t_c=1/a \sim d^{-2} \), so plotting of \( u(t) \) with dimensions
for various \( d \) values will involve significant variations in the time
and velocity scales. Figure <a href="#sec:scale:decay:body:fig">3</a>
has an example with \( d=1,2,3 \) mm, where we clearly see the different
time and velocity scales in the figure with unscaled variables.
Note that the scaled velocity is positive because of the sign of \( u_c \)
(see the box above).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Velocity of falling body: scaled (left) and with dimensions (right). <div id="sec:scale:decay:body:fig"></div> </p></center>
<p><img src="fig-scaling/falling_body.png" align="bottom" width=800></p>
</center>

<h2 id="sec:scale:decay:jump">Variable coefficients</h2>

<p>
When a prescribed coefficient like \( a(t) \) in \( u'(t) = -a(t)u(t) \)
varies with time one usually also
performs a scaling of this \( a \),

$$ \bar a(\bar t) = \frac{a(t) - a_0}{a_c}, $$

where the goal is to have the scaled \( \bar a \)
of size unity: \( |\bar a|\leq 1 \).
This property is obtained by choosing \( a_c \) as the maximum value
of \( |a(t)-a_0| \) for \( t\in [0,T] \), which is usually a quantity that
can be estimated since \( a(t) \) is known as a function of \( t \). The \( a_0 \)
parameter can be chosen as 0 here. (It could be tempting to
choose \( a_0=\min_t a(t) \) so that \( 0\leq \bar a\leq 1 \), but then there
is at least one point where \( \bar a = 0 \) and
the differential equation collapses to \( u'=0 \).)

<p>
As an example, imagine a decaying cell culture where we at time \( t_1 \)
change the environment such that the death rate increases: \( a(t) = d \) for
\( t < t_1 \) and \( a(t)=5d \) for \( t\geq t_1 \). The model reads \( u'=-a(t)u \), \( u(0)=I \).

<p>
The \( a(t) \) function is scaled by letting the characteristic size be
\( a_c=d \) (and \( a_0=0 \)):

$$ \bar a (\bar t) = \left\lbrace\begin{array}{ll}
1, & \bar t < t_1/t_c\\ 
5, & \bar t \geq t_1/t_c
\end{array}\right.
$$

<p>
The scaled equation becomes

$$ \frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = a_c\bar a(\bar t) u_c\bar u,\quad
u_c\bar u(0) = I\tp$$

The characteristic time, previously taken as \( t_c=1/a \), can now be
taken as \( t_c=t_1 \) or \( t_c=1/d \). The natural choice of \( u_c \) is \( I \).
With \( t_c=1/d \) we get

$$
\begin{equation}
\bar u'(\bar t)=-\bar a\bar u,\quad \bar u(0)=1,\quad
\bar a = \left\lbrace\begin{array}{ll}
1, & \bar t < \gamma\\ 
5, & \bar t \geq \gamma
\end{array}\right.
\tag{16}
\end{equation}
$$

where

$$ \gamma = t_1 d$$

is a dimensionless number in the problem. With \( t_c=t_1 \), we get

$$ \bar u'(\bar t)=-\gamma\bar a\bar u,\quad \bar u(0)=1,\quad
\bar a = \left\lbrace\begin{array}{ll}
1, & \bar t < 1\\ 
5, & \bar t \geq 1
\end{array}\right.$$

The dimensionless parameter \( \gamma \) is now in the equation rather than in
the definition of \( \bar a \). Both problems involve \( \gamma \), which
is the ratio between the time when the environmental change happens
and the typical time for the decay (\( 1/d \)).

<p>
A computation with the scaled model <a href="#mjx-eqn-16">(16)</a>
and the original model with dimensions appears in
Figure <a href="#sec:scale:decay:jump:fig">4</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Exponential decay with jump: scaled model (left) and unscaled model (right). <div id="sec:scale:decay:jump:fig"></div> </p></center>
<p><img src="fig-scaling/decay_jump.png" align="bottom" width=800></p>
</center>

<h2 id="scale:decay:cooling:const">Scaling a cooling problem with constant surroundings</h2>

<p>
The heat exchange between a body at temperature \( T(t) \) and the
surroundings at \( T_s(t) \) can be modeled by Newton's law of cooling:

$$
\begin{equation}
T'(t) = -k(T-T_s(t)),\quad T(0)=T_0,
\tag{17}
\end{equation}
$$

where \( k \) is a prescribed heat transfer coefficient.

<h3 id="___sec39">Exact solution </h3>

<p>
An analytical solution is always handy to have as a control of the
choice of scales. Here we have
the result \( T(t) = T_s + (T_0 - T_s)e^{-kt} \) when \( T_s \) is constant,
which is also the assumption for now.

<h3 id="___sec40">Scaling </h3>

<p>
Physically, we expect the temperature to start at \( T_0 \) and then
to move toward the surroundings (\( T_s \)). We therefore expect
that \( T \) lies between \( T_0 \) and \( T_s \). This is mathematically
demonstrated by the analytical solution as well. A proper scaling
is therefore to scale and translate \( T \) according to
$$
\begin{equation}
\bar T = \frac{T-T_0}{T_s-T_0}
\tag{18}
\tp
\end{equation}
$$

Now, \( 0\leq \bar T\leq 1 \).

<p>
Scaling time by \( \bar t = t/t_c \) and inserting
\( T= T_0 + (T_s-T_0)\bar T \) and \( t=t_c\bar t \) in the
problem <a href="#mjx-eqn-17">(17)</a> gives

$$ \frac{d\bar T}{d\bar t} = - t_ck(\bar T - 1),\quad \bar T(0) = 0
\tp
$$

A natural choice, as argued in other exponential decay problems,
is to choose \( t_ck=1 \), which leaves us with the scaled problem
$$
\begin{equation}
\frac{d\bar T}{d\bar t} = - (\bar T - 1),\quad \bar T(0)=0
\tag{19}
\tp
\end{equation}
$$

No physical parameter enters this problem!
Our scaling implies that \( \bar T \) starts at
0 and approaches 1 as \( \bar t\rightarrow\infty \), also in the case
\( T_s < T_0 \). The physical temperature is always recovered as
$$
\begin{equation}
T(t) = T_0 + (T_s-T_0)\bar T (k\bar t)
\tag{20}
\tp
\end{equation}
$$

<h3 id="___sec41">Software </h3>

<p>
An implementation for <a href="#mjx-eqn-17">(17)</a> works for
<a href="#mjx-eqn-19">(19)</a> by setting \( k=1 \), \( T_s=1 \), and \( T_0=0 \).

<h3 id="___sec42">Alternative scaling </h3>

<p>
An alternative temperature scaling is to choose
$$
\begin{equation}
\bar T = \frac{T-T_s}{T_0-T_s}
\tag{21}
\tp
\end{equation}
$$

Now \( \bar T=1 \) initially and approaches zero as \( t\rightarrow\infty \).
The resulting scaled ODE problem then becomes

$$
\begin{equation}
\frac{d\bar T}{d\bar t} = - \bar T,\quad \bar T(0)=1
\tag{22}
\tp
\end{equation}
$$

<h2 id="scale:decay:cooling:osc">Scaling a cooling problem with time-dependent surroundings</h2>

<p>
Let us apply the model <a href="#mjx-eqn-17">(17)</a> in
case the surrounding temperature varies in time. Say we have
an oscillating temperature environment according to

$$
\begin{equation}
T_s(t) = T_m + a\sin(\omega t)
\tag{23}
\tp
\end{equation}
$$

<h3 id="___sec44">Exact solution </h3>

<p>
It is possible to solve the differential equation problem analytically,
and such a solution is a good help to see what scales are.
In general, using the method of integrating factors for the
original differential equation, we have

$$ T(t) = T_0e^{-kt} + e^{-kt}k\int_0^t e^{k\tau}T_s(\tau)d\tau\tp$$

With \( T_s(t)=T_m + a\sin (wt) \) we can use SymPy to help us with
integrations:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> t, k, T_m, a, w <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;t k T_m a w&#39;</span>, real<span style="color: #666666">=</span><span style="color: #008000">True</span>, positive<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> T_s <span style="color: #666666">=</span> T_m <span style="color: #666666">+</span> a<span style="color: #666666">*</span>sin(w<span style="color: #666666">*</span>t)
<span style="color: #666666">&gt;&gt;&gt;</span> I <span style="color: #666666">=</span> exp(k<span style="color: #666666">*</span>t)<span style="color: #666666">*</span>T_s
<span style="color: #666666">&gt;&gt;&gt;</span> I <span style="color: #666666">=</span> integrate(I, (t, <span style="color: #666666">0</span>, t))
<span style="color: #666666">&gt;&gt;&gt;</span> Q <span style="color: #666666">=</span> k<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>k<span style="color: #666666">*</span>t)<span style="color: #666666">*</span>I
<span style="color: #666666">&gt;&gt;&gt;</span> Q <span style="color: #666666">=</span> simplify(expand(Q))
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> Q
(<span style="color: #666666">-</span>T_m<span style="color: #666666">*</span>k<span style="color: #666666">**2</span> <span style="color: #666666">-</span> T_m<span style="color: #666666">*</span>w<span style="color: #666666">**2</span> <span style="color: #666666">+</span> a<span style="color: #666666">*</span>k<span style="color: #666666">*</span>w <span style="color: #666666">+</span>
(T_m<span style="color: #666666">*</span>k<span style="color: #666666">**2</span> <span style="color: #666666">+</span> T_m<span style="color: #666666">*</span>w<span style="color: #666666">**2</span> <span style="color: #666666">+</span> a<span style="color: #666666">*</span>k<span style="color: #666666">**2*</span>sin(t<span style="color: #666666">*</span>w) <span style="color: #666666">-</span>
a<span style="color: #666666">*</span>k<span style="color: #666666">*</span>w<span style="color: #666666">*</span>cos(t<span style="color: #666666">*</span>w))<span style="color: #666666">*</span>exp(k<span style="color: #666666">*</span>t))<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>k<span style="color: #666666">*</span>t)<span style="color: #666666">/</span>((k<span style="color: #666666">**2</span> <span style="color: #666666">+</span> w<span style="color: #666666">**2</span>))
</pre></div>
<p>
Reordering the result, we get

$$ T(t) = T_0e^{-kt} + T_m(1- e^{-kt}) +  (k^2 + w^2)^{-1}(akw e^{-kt}
+ ak\sin (wt) - akw\cos(wt))\tp$$

<h3 id="___sec45">Scaling </h3>

<p>
The scaling <a href="#mjx-eqn-18">(18)</a> brings in a time-dependent
characteristic temperature scale \( T_s-T_0 \). Let us start with a
fixed scale, where we take the characteristic temperature variation to
be \( T_m - T_0 \):

$$ \bar T = \frac{T-T_0}{T_m-T_0}\tp$$

We see from the analytical solution, and realize also by physical
reasoning, that \( T \) sets out at \( T_0 \), but with time, it will oscillate
around \( T_m \). The typical average temperature span is therefore
\( |T_m-T_0| \), unless \( a \) is much larger than \( |T_m-T_0| \) or \( T_0 \) is
very close to \( T_m \) (see <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#sec:scale:exer:decay:cooling:osc">Exercise 3: Perform alternative scalings</a> for
a discussion of these cases).

<p>
We get from the differential equation, with \( t_c=1/k \) as in the former
case,

$$ k(T_m-T_0)\frac{d\bar T}{d\bar t} = -k((T_m-T_0)\bar T + T_0 - T_m - a
\sin(wt),$$

resulting in

$$
\begin{equation}
\frac{d\bar T}{d\bar t} = -\bar T + 1 + \alpha\sin (\beta \bar t),\quad
\bar T(0)=0,
\tag{24}
\end{equation}
$$

where we have two dimensionless numbers:

$$ \alpha = \frac{a}{T_m-T_0},\quad \beta = \frac{w}{k}\tp$$

The \( \alpha \) quantity
measures the ratio of temperatures: amplitude of oscillations versus
distance from initial temperature to the average temperature for large times.
The \( \beta \) number is the ratio of the two time scales:
the frequency of the oscillations in \( T_s \) and the inverse
e-folding time of the heat transfer. For clear interpretation of \( \beta \)
we may introduce the period
\( P=2\pi/w \) of the oscillations in \( T_s \) and the e-folding time \( e=1/k \). Then
\( \beta = 2\pi e/P \) and measures the e-folding time versus the period.

<p>
The original problem features five physical parameters: \( k \), \( T_0 \),
\( T_m \), \( a \), and \( w \), but only two dimensionless numbers appear in the
scaled model <a href="#mjx-eqn-24">(24)</a>.

<h3 id="___sec46">Software </h3>

<p>
Implementations of the unscaled problem <a href="#mjx-eqn-17">(17)</a>
can be reused for the scaled model by setting \( k=1 \), \( T_0=0 \), and
\( T_s(t) = 1 + \alpha\sin (\beta \bar t) \) (\( T_m=1 \), \( a=\alpha \), \( w=\beta \)).
The file <a href="http://tinyurl.com/o8pb3yy/osc_cooling.py" target="_self"><tt>osc_cooling.py</tt></a> contains
solvers for the problem with dimensions and
for the scaled problem. The figure below
shows three cases of \( \beta \) values: small, medium, and large.

<p>
<center><p><img src="fig-scaling/osc_cooling.png" align="bottom" width=500></p></center>

<p>
For the small \( \beta \) value, the oscillations in the surrounding
temperature are slow enough compared to \( k \) for the heating and
cooling process to follow the surrounding temperature, with a small
time lag. For larger \( \beta \), the heating and cooling requires more
time, and the oscillations get smaller.

<h3 id="___sec47">Discussion of the time scale </h3>

<p>
Looking at the analytical insight we have, \( T(t) \) has two characteristic
terms in time: \( e^{-kt} \) and \( \sin(wt) \). The former points to a time
scale \( t_c=1/k \), while the latter to \( t_c=1/w \).
Which one should be chosen? Bringing the temperature from \( T_0 \) to
the level of the surroundings, \( T_m \), goes like \( e^{-kt} \), so
in this process \( t_c=1/k \) is the characteristic time. Thereafter,
the body's temperature just responds to the oscillations and the
\( \sin (wt) \) (and \( \cos(wt) \)) term dominates. For these large times,
\( t_c=1/w \) is the appropriate time scale. Choosing \( t_c=1/w \)
results in

$$
\begin{equation}
\frac{d\bar T}{d\bar t} = -\beta^{-1}(\bar T - (1 + \alpha\sin (\bar t))),\quad
\bar T(0)=0\tp
\tag{25}
\end{equation}
$$

<p>
Let us illustrate another, less effective, scaling.
The temperature scale in
<a href="#mjx-eqn-18">(18)</a> looks natural, so we apply this
choice of scale. The characteristic temperature \( T_0-T_s \)
now involves
a time-dependent term \( T_s(t) \). The mathematical steps become a bit
more technically involved:

$$ T(t) = T_0 + (T_s(t)-T_0)\bar T,$$


$$ \frac{dT}{dt} = \frac{dT_s}{dt}\bar T +
(T_s-T_0)\frac{d\bar T}{d\bar t}\frac{d\bar t}{dt}
\tp
$$

With \( \bar t = t/t_c = kt \) we get from the differential equation

$$
\frac{dT_s}{dt}\bar T +
(T_s-T_0)\frac{d\bar T}{d\bar t}k
= -k(\bar T - 1)(T_s - T_0),
$$

which after dividing by \( k(T_s-T_0) \) results in

$$
\frac{d\bar T}{d\bar t} = -(\bar T - 1) -
\frac{dT_s}{dt}\frac{\bar T}{k(T_s-T_0},
$$

or

$$
\frac{d\bar T}{d\bar t} = -(\bar T - 1) -
\frac{a\omega\cos(\omega \bar t/k)}{k(T_m + a\sin(\omega \bar t/k) -T_0)}\bar T
\tp
$$

The last term is complicated and becomes more tractable if we factor
out dimensionless numbers. To this end, we scale \( T_s \) by (e.g.) \( T_m \),
which means to factor out \( T_m \) in the denominator. We are then
left with
$$
\begin{equation}
\frac{d\bar T}{d\bar t} = -(\bar T - 1) -
\alpha\beta \frac{\cos(\beta \bar t)}{1 + \alpha\sin(\beta\bar t) - \gamma}
\bar T,
\tag{26}
\end{equation}
$$

where \( \alpha \), \( \beta \), and \( \gamma \) are dimensionless numbers
characterizing the relative importance of parameters in the problem:
$$
\begin{equation}
\alpha=a/T_m,\quad \beta = \omega/k,\quad \gamma = T_0/T_m
\tp
\tag{27}
\end{equation}
$$

We notice that <a href="#mjx-eqn-26">(26)</a>
is not a special case of the original problem
<a href="#mjx-eqn-17">(17)</a>. Furthermore, the original five
parameters \( k \), \( T_m \), \( a \), \( \omega \), and
\( T_0 \) are reduced to three dimensionless parameters.
We conclude that this scaling is inferior, because
using the temperature scale \( T_0-T_m \) enables reuse of the software
for the unscaled problem and only two dimensionless parameters appear
in the scaled model.

<h2 id="sec:scale:decay:nonlinear">Scaling a nonlinear ODE</h2>

<p>
Exponential growth models, \( u'=au \), are not realistic in environments
with limited resources. The idea is then to assume that
the growth rate \( a \) decreases with \( u \) and vanishes when we reach the maximum
value \( M \) of \( u \) the environment can sustain. The initial growth rate
is set to \( r \): \( a(0)=\varrho \).
In general, this reasoning gives rise to models

$$
\begin{equation}
u' = a(u)u,\quad u(0)=I,
\tag{28}
\end{equation}
$$

with the logistic model, corresponding to \( a(u)=\varrho(1-u/M) \),
as the simplest:

$$
\begin{equation}
u' = \varrho u(1-u/M),\quad u(0)=I\tp
\tag{29}
\end{equation}
$$

A general choice of \( a \) may be \( a(u)=\varrho(1-u/M)^p \) for some exponent \( p \).

<h3 id="___sec49">Scaling </h3>

<p>
Let us scale <a href="#mjx-eqn-28">(28)</a> with
\( a(u)=\varrho (1-u/M)^p \).
The natural scale for \( u \) is \( M \) (\( u_c=M \)), since we know that
\( 0 < u\leq M \), and this makes the dimensionless \( \bar u = u/M \in (0,1] \).
The function \( a(u) \) is
typically varying between 0 and \( \varrho \), so it can be scaled as

$$ \bar a(\bar u) = \frac{a(u)}{\varrho} = (1 - \frac{u}{M})^p =
(1 - \bar u)^p\tp$$

Time is scaled as \( \bar t = t/t_c \) for some suitable characteristic time \( t_c \).
Inserted in <a href="#mjx-eqn-28">(28)</a>, we get

$$ \frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = \varrho\bar a u_c\bar u,\quad u_c\bar u(0)=I,$$

resulting in

$$ \frac{d\bar u}{d\bar t} = t_c \varrho (1 - \bar u)^p \bar u,\quad
\bar u(0) =\frac{I}{M}\tp$$

A natural choice is \( t_c =1/\varrho \) as in other exponential growth models
since it leads to the term on the right-hand side to be about unity,
as the left-hand side, if the scaling is physically correct.
Introducing the dimensionless parameter

$$ \alpha = \frac{I}{M},$$

measuring the fraction of the initial population compared to the maximum
one, we get the dimensionless model

$$
\begin{equation}
\frac{d\bar u}{d\bar t} = (1 - \bar u)^p \bar u,\quad
\bar u(0) =\alpha\tp
\tag{30}
\end{equation}
$$

Here, we have two dimensionless parameters: \( \alpha \) and \( p \). A classical
logistic model with \( p=1 \) has only one dimensionless variable.

<h3 id="___sec50">Alternative scaling </h3>

<p>
We could try another scaling of \( u \) where we also translate \( \bar u \):

$$ \bar u = \frac{u-I}{M}\tp $$

This choice of \( \bar u \) results in

$$
\begin{equation}
\frac{d\bar u}{d\bar t} = (1 - \alpha - \bar u)^p \bar u,\quad
\bar u(0) =0\tp
\tag{31}
\end{equation}
$$

The essential difference between <a href="#mjx-eqn-30">(30)</a>
and <a href="#mjx-eqn-31">(31)</a> is that
\( \bar u\in [\alpha, 1] \) in the former and \( \bar u \in [0, 1-\alpha] \) in
the latter. Both models involve the dimensionless numbers \( \alpha \) and \( p \).
An advantage of <a href="#mjx-eqn-30">(30)</a>
is that software for the unscaled model can easily be used for the
scaled model by choosing \( I=\alpha \), \( M=1 \), and \( \varrho=1 \).

<h2 id="___sec51">SIR ODE system for spreading of diseases </h2>

<p>
The field of epidemiology frequently applies ODE systems to describe
the spreading of diseases, such as smallpox, measles, plague, ordinary
flu, swine flu, and HIV. Different models include different effects,
which are reflected in dimensionless numbers. Most of the effects are
modeled as exponential decay or growth of the dependent variables.

<p>
The simplest model has three categories of people: susceptibles (S)
who can get the disease, infectious (I) who are infected and may
infect susceptibles, and recovered (R) who have recovered from the
disease and gained immunity. We introduce \( S(t) \), \( I(t) \), and \( R(t) \)
as the number of people in the categories S, I, and R, respectively.
The model, naturally known as the SIR model, takes the form a system
of ODEs:

$$
\begin{align}
\frac{dS}{dt} &= - \beta SI,
\tag{32}\\ 
\frac{dI}{dt} &= \beta SI - \nu I,
\tag{33}\\ 
\frac{dR}{dt} &= \nu I,
\tag{34}
\end{align}
$$

where \( \beta \) and \( \nu \) are empirical constants. The average time for recovering
from the disease can be shown to be \( \nu^{-1} \), but \( \beta \) is much harder
to estimate, so working with a scaled model where \( \beta \) is &quot;scaled away&quot;
is advantageous.

<h3 id="___sec52">Scaling </h3>

<p>
It is natural to scale \( S \), \( I \), and \( R \) by, e.g., \( S(0) \):

$$ \bar S = \frac{S}{S(0)},\quad \bar I = \frac{I}{S(0)},\quad
\bar R = \frac{R}{S(0)}\tp
$$

Introducing \( \bar t = t/t_c \), we arrive at the equations

$$
\begin{align*}
\frac{d\bar S}{d\bar t} &= - t_c S(0) \beta\bar S\bar I,
\\ 
\frac{d\bar I}{d\bar t} &= t_c S(0) \beta \bar S\bar I - t_c \nu \bar I,
\\ 
\frac{d\bar R}{d\bar t} &= t_c \nu I,
\end{align*}
$$

with initial conditions \( \bar S(0)=1 \), \( \bar I(0)=I_0/S(0)=\alpha \), and
\( \bar R(0)=R(0)/S(0) \). Normally, \( R(0)=0 \).

<p>
Taking \( t_c=1/\nu \), corresponding to a time unit equal to the time it takes
to recover from the disease, we end up with the scaled model

$$
\begin{align}
\frac{d\bar S}{d\bar t} &= - R_0\bar S\bar I,
\tag{35}\\ 
\frac{d\bar I}{d\bar t} &= R_0 \bar S\bar I - \bar I,
\tag{36}\\ 
\frac{d\bar R}{d\bar t} &= I,
\tag{37}
\end{align}
$$

with \( \bar S(0)=1 \), \( \bar I(0)=\alpha \), \( \bar R(0)=0 \), and \( R_0 \) as
the dimensionless number

$$
\begin{equation}
R_0 = \frac{S(0)\beta}{\nu}\tp
\tag{38}
\end{equation}
$$

We see from <a href="#mjx-eqn-36">(36)</a> that to make the disease spreading,
\( d\bar I/d\bar t >0 \), and therefore \( R_0 S(0) - 1 > 0 \) or \( R_0 > 1 \)
since \( S(0)=1 \).
Therefore, \( R_0 \) reflects the disease's ability to spread and is
consequently an important dimensionless quantity, known as the <a href="https://en.wikipedia.org/wiki/Basic_reproduction_number" target="_self">basic
reproduction number</a>.
This number reflects the number of infected people caused by one infectious
individual during the time period of the disease.

<p>
Looking at <a href="#mjx-eqn-33">(33)</a>, we see that to increase \( I \) initially,
we must have \( dI/dt >0 \) at \( t=0 \), which implies
\( \beta I(0)S(0) - \nu I(0) >0 \), i.e., \( R_0 > 1 \).

<h3 id="___sec53">Software </h3>

<p>
Any implementation of the SIR model with dimensions can be reused for
the scaled model by setting \( \beta = R_0 \), \( \nu = 1 \), \( S(0)=1-\alpha \),
and \( I(0)=\alpha \). Below is a plot with two cases: \( R_0=2 \) and \( R_0=5 \),
both with \( \alpha=0.02 \).

<p>
<br />
<br />

<p>
<center><p><img src="fig-scaling/SIR1.png" align="bottom" width=800></p></center>

<p>
<br />
<br />

<h3 id="___sec54">Alternative scaling </h3>

<p>
Adding <a href="#mjx-eqn-32">(32)</a>-<a href="#mjx-eqn-34">(34)</a> shows that

$$ \frac{dS}{dt}+\frac{dI}{dt}+\frac{dR}{dt}=0\quad\Rightarrow\quad
S+I+R=\hbox{const}=N,$$

where \( N \) is the size of the population.
We can therefore scale \( S \), \( I \), and \( R \) by the total
population \( N=S(0)+I(0)+R(0) \):

$$ \bar S = \frac{S}{N},\quad \bar I = \frac{I}{N},\quad
\bar R = \frac{R}{N)}\tp
$$

With the same time scale, one gets the system <a href="#mjx-eqn-35">(35)</a>-<a href="#mjx-eqn-37">(37)</a>, but with \( R_0 \) replaced by the dimensionless number:

$$
\begin{equation}
\tilde R_0 = \frac{N\beta}{\nu}\tp
\tag{39}
\end{equation}
$$

The initial conditions become \( \bar S(0)=1-\alpha \), \( \bar I(0)=\alpha \),
and \( \bar R(0)=0 \).

<p>
For the disease to spread at \( t=0 \), we must have \( \tilde R_0 \bar S(0) > 1 \),
but \( \tilde R_0 \bar S(0) = N\beta/\nu \cdot S(0)/N = R_0 \), so the
criterion is still \( R_0 > 1 \). Since \( R_0 \) is a more famous number than
\( \tilde R_0 \), we can write the ODEs with \( R_0/S(0) = R_0/(1-\alpha) \)
instead of \( \tilde R_0 \).

<p>
Choosing \( t_c \) to make the \( SI \) terms balance the time derivatives,
\( t_c = (N\beta)^{-1} \), moves \( \tilde R_0 \) (or \( R_0 \) if we scale
\( S \), \( I \), and \( R \) by \( S(0) \)) to the \( I \) terms:

$$
\begin{align*}
\frac{d\bar S}{d\bar t} &= - \bar S\bar I,
\\ 
\frac{d\bar I}{d\bar t} &= \bar S\bar I - \tilde R_0^{-1} \bar I,
\\ 
\frac{d\bar R}{d\bar t} &= \tilde R_0^{-1} I\tp
\end{align*}
$$

<h2 id="___sec55">SIRV model with finite immunity </h2>

<p>
A common extension of the SIR model involves finite immunity: after
some period of time, recovered individuals lose their immunity
and become susceptibles again. This is modeled as
a leakage \( -\mu R \) from the R to the S category, where \( \mu^{-1} \)
is the average time it takes to lose immunity.
Vaccination is another extension: a fraction \( pS \) is removed from the
S category by successful vaccination and brought to a new category V (the
vaccinated). The ODE model reads

$$
\begin{align}
\frac{dS}{dt} &= - \beta SI - pS + \mu R,
\tag{40}\\ 
\frac{dI}{dt} &= \beta SI - \nu I,
\tag{41}\\ 
\frac{dR}{dt} &= \nu I -\mu R,
\tag{42}\\ 
\frac{dV}{dt} &= p S\tp
\tag{43}
\end{align}
$$

Using \( t_c=1/\nu \) and scaling the unknowns by \( S(0) \), we arrive at
the dimensionless model

$$
\begin{align}
\frac{d\bar S}{d\bar t} &= - R_0 \bar S \bar I - \delta S + \gamma \bar R,
\tag{44}\\ 
\frac{d\bar I}{d\bar t} &= R_0 \bar S \bar I - \bar I,
\tag{45}\\ 
\frac{d\bar R}{d\bar t} &= \bar I -\gamma \bar R,
\tag{46}\\ 
\frac{d\bar V}{d\bar t} &= \delta \bar S,
\tag{47}
\end{align}
$$

with two new dimensionless parameters:

$$ \gamma = \frac{\mu}{\nu},\quad \delta = \frac{p}{\nu}\tp $$

The quantity \( p^{-1} \) can be interpreted as the average time it takes
to vaccinate a susceptible successfully. Writing \( \gamma = \nu^{-1}/\mu^{-1} \)
and \( \delta = \nu^{-1}/p^{-1} \) gives the interpretation that \( \gamma \)
is the ratio of the average time to recover and the average time to
lose immunity, while \( \delta \) is the ratio of the average time to recover
and the average time to successfully vaccinate a susceptible.

<p>
The plot in Figure <a href="#sec:scale:SIRV:fig">5</a> has \( \gamma = 0.05 \), i.e.,
loss of immunity takes 20 weeks if it takes one week to recover from
the disease. The left plot corresponds to no vaccination, while the
right has \( \delta = 0.5 \) for a vaccination campaign that lasts from
day 7 to day 15. The value \( \delta =0.5 \) reflects that
it takes two weeks to successfully
vaccinate a susceptible, but the effect of vaccination is still dramatic.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Spreading of a disease with loss of immunity (left) and added vaccination (right). <div id="sec:scale:SIRV:fig"></div> </p></center>
<p><img src="fig-scaling/SIRV2.png" align="bottom" width=800></p>
</center>

<h2 id="scale:MMK">Michaelis-Menten kinetics for biochemical reactions</h2>

<p>
A classical reaction model in biochemistry describes how a
substrate S is turned into a product P with aid of an enzyme E.
S and E react to form a complex ES in the first stage of the reaction.
In the second stage, ES is turned into E and P.
Introducing the amount of S, E, ES, and P by \( [S] \), \( [E] \), \( [ES] \), and
\( [P] \), the mathematical model can be written as

$$
\begin{align}
\frac{d[ES]}{dt} &= k_+[E][S] - k_v[ES] - k_-[ES],
\tag{48}\\ 
\frac{d[P]}{dt} &= k_v[ES],
\tag{49}\\ 
\frac{d[S]}{dt} &= -k_+[E][S] + k_-[ES],
\tag{50}\\ 
\frac{d[E]}{dt} &= -k_+[E][S] + k_-[ES] + k_v[ES]\tp
\tag{51}
\end{align}
$$

The initial conditions are \( [ES](0)=[P](0)=0 \), and \( [S]=S_0 \), \( [E]=E_0 \).
Three rate constants are involved: \( k_+ \), \( k_- \), and \( k_v \).

<p>
The amount of substance is measured in the unit <a href="https://en.wikipedia.org/wiki/Mole_(unit)" target="_self">mole</a> (mol). From the equations we can see that
\( k_+ \) is measured in \( \hbox{s}^{-1}\hbox{mol}^{-1} \), while \( k_- \) and
\( k_v \) are measured in \( \hbox{s}^{-1} \). It is convenient to get rid of
the mole unit for the amount of a substance. When working with
dimensionless quantities, only ratios of the rate constants and not their
specific values are needed.

<h3 id="___sec57">Classical analysis </h3>

<p>
The typical analysis of the present ODE system is to first observe
two conservation equations, arising from simply adding the ODEs:

$$
\begin{align}
\frac{d[ES]}{dt} + \frac{d[E]}{dt} & =0,
\tag{52}\\ 
\frac{d[ES]}{dt} + \frac{d[S]}{dt} + \frac{d[P]}{dt} &= 0,
\tag{53}
\end{align}
$$

from which it follows that

$$
\begin{align}
[ES] + [E] &= E_0,
\tag{54}\\ 
[ES] + [S] + [P] &= S_0\tp
\tag{55}
\end{align}
$$

Using <a href="#mjx-eqn-54">(54)</a>, we can eliminate \( [E] \) and obtain a
system of only two ODEs,

$$
\begin{align}
\frac{d[ES]}{dt} &= k_+([ES]-E_0)[S] - (k_v + k_-)[ES],
\tag{56}\\ 
\frac{d[S]}{dt} &= -k_+([ES]-E_0)[S] + k_-[ES]\tp
\tag{57}
\end{align}
$$

A common assumption is that the formation of \( [ES] \) is very fast and that
it reaches an equilibrium state, \( [ES]^{\prime}=0 \). This implies

$$ k_+([ES]-E_0)[S] - (k_v + k_-)[ES]=0\quad\Rightarrow\quad
[ES] = \frac{E_0[S]}{[S] - K},
$$

where

$$ K = \frac{k_- + k_v}{k_+},$$

is the Michaelis constant. Using the expression for \( [ES] \) in the
equation for \( [S] \) gives

$$
\begin{equation}
\frac{d[S]}{dt} = \frac{k_vE_0[S]}{[S] + K}\tp
\tag{58}
\end{equation}
$$

We see that the parameter \( K \) is central.

<h3 id="___sec58">Dimensionless ODE system </h3>

<p>
Let us reason how to make the original ODE system dimensionless.
Aiming at \( [S] \) and \( [E] \) of unit size, two obvious dimensionless
unknowns are

$$ \bar S = \frac{[S]}{S_0},\quad
\bar E = \frac{[E]}{E_0}\tp$$

For the other two unknowns we just introduce scales to be determined
later:

$$
\bar P = \frac{[P]}{P_c},\quad
\bar{Q} = \frac{[ES]}{Q_c}\tp
$$

With \( \bar t = t/t_c \) the equations become

$$
\begin{align*}
\frac{d\bar Q}{d\bar t} &= t_ck_+\frac{E_0S_0}{Q_c}\bar E\bar S
- t_c(k_v + k_-)\bar Q,\\ 
\frac{d\bar P}{d\bar t} &= t_ck_v\frac{Q_c}{P_c}\bar Q,\\ 
\frac{d\bar S}{d\bar t} &= -t_ck_+E_0\bar E\bar S
+ t_ck_-\frac{Q_c}{S_0}\bar Q,\\ 
\frac{d\bar E}{d\bar t} &= -t_ck_+S_0\bar E\bar S
+ t_c(k_- + k_v)\frac{Q_c}{E_0}\bar Q\tp
\end{align*}
$$

<!-- <a href="http://www.biosym.uzh.ch/modules/models/Michaelis_Menten/michaelis_menten.html" target="_self"><tt>http://www.biosym.uzh.ch/modules/models/Michaelis_Menten/michaelis_menten.html</tt></a> -->
<!-- <a href="http://deepblue.lib.umich.edu/bitstream/handle/2027.42/26960/0000527.pdf" target="_self"><tt>http://deepblue.lib.umich.edu/bitstream/handle/2027.42/26960/0000527.pdf</tt></a>?sequence=1 -->
<!-- <a href="http://www.math.ubc.ca/~keshet/EnzKin.pdf" target="_self"><tt>http://www.math.ubc.ca/~keshet/EnzKin.pdf</tt></a> -->
<!-- Good (but complicated): <a href="https://people.maths.ox.ac.uk/maini/PKM%20publications/9.pdf" target="_self"><tt>https://people.maths.ox.ac.uk/maini/PKM%20publications/9.pdf</tt></a> -->
<!-- <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2932968/" target="_self"><tt>http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2932968/</tt></a> (read this one - it is the best, this one has units for the constants too and typical values of constants) -->
<!-- Murray has S_c=S_0, Q_c=E_0 (that is common) -->
<!-- All use the long time scale with E_0 -->
<!-- Murray has much complicated analysis before selecting scales... -->
<!-- Can find Q_c from Q'=0 which gives Q_c=E_0S_0/K -->

<h3 id="___sec59">Determining scales </h3>

<p>
Choosing the scales is actually a quite complicated matter that requires
extensive analysis of the equations to determine the characteristics of
the solutions. Much literature is written about this, but here we shall
take a simplistic and pragmatic approach.
Besides the Michaelis constant \( K \), there is another important parameter,

$$ \epsilon = \frac{E_0}{S_0},$$

because most applications will involve a small \( \epsilon \).
We shall have \( K \) and \( \epsilon \) in mind while choosing scales such that
these symbols appear naturally in the scaled equations.

<p>
Looking at the equations, we see that the \( K \) parameter will appear
if \( t_c\sim 1/k_+ \). However, \( 1/k_+ \) does not have the dimension
\( \hbox{[T]}^{-1} \) as required, so we need to add a factor with dimension
mol. A natural choice is
\( t_c^{-1}=k_+S_0 \) or \( t_c^{-1}=k_+E_0 \). Since often \( S_0\gg E_0 \),
the former \( t_c \) is a short time scale and the latter is a long
time scale. If the interest is in the long time scale, we set

$$ t_c = \frac{1}{k_+E_0}\tp$$

The equations then take the form

$$
\begin{align*}
\frac{d\bar Q}{d\bar t} &= \frac{S_0}{Q_c}\bar E\bar S
- KE_0^{-1}\bar Q,\\ 
\frac{d\bar P}{d\bar t} &= \frac{k_v}{k_+ E_0}\frac{Q_c}{P_c}\bar Q,\\ 
\frac{d\bar S}{d\bar t} &= -\bar E\bar S
+ \frac{k_-}{k_+E_0}\frac{Q_c}{S_0}\bar Q,\\ 
\frac{d\bar E}{d\bar t} &= -\epsilon^{-1}\bar E\bar S
+ K\frac{Q_c}{E_0^2}\bar Q\tp
\end{align*}
$$

The \( [ES] \) variable starts and ends at zero, and its maximum value
can be roughly estimated from the equation for \( [ES]^{\prime} \)
by setting \( [ES]^{\prime}=0 \), which gives an estimate of

$$ Q_c = \frac{E_0S_0}{K},$$

if we approximate \( [E][S] \) by \( E_0S_0 \).

<p>
The equation for \( \bar P \) simplifies if we choose \( P_c=Q_c \).
With these assumptions one gets

$$
\begin{align*}
\frac{d\bar Q}{d\bar t} &= KE_0^{-1} (\bar E\bar S
- \bar Q),\\ 
\frac{d\bar P}{d\bar t} &= \frac{k_v}{k_+ E_0}\bar Q,\\ 
\frac{d\bar S}{d\bar t} &= -\bar E\bar S
+ \frac{k_-}{k_+E_0}\frac{E_0}{K}\bar Q,\\ 
\frac{d\bar E}{d\bar t} &= -\epsilon^{-1}\bar E\bar S
+ \epsilon^{-1}\bar Q\tp
\end{align*}
$$

We can now identify the dimensionless numbers

$$ \alpha = \frac{K}{E_0},\quad \beta = \frac{k_v}{k_+ E_0},
\quad \gamma = \frac{k_-}{k_+E_0},
$$

where we see that \( \alpha = \beta + \gamma \), so \( \gamma \) can be eliminated,
leading to the final set of equations:

$$
\begin{align}
\frac{d\bar Q}{d\bar t} &= \alpha (\bar E\bar S
- \bar Q),
\tag{59}\\ 
\frac{d\bar P}{d\bar t} &= \beta\bar Q,
\tag{60}\\ 
\frac{d\bar S}{d\bar t} &= -\bar E\bar S
+ (1 - \beta\alpha^{-1})\bar Q,
\tag{61}\\ 
\epsilon\frac{d\bar E}{d\bar t} &= -\bar E\bar S + \bar Q\tp
\tag{62}
\end{align}
$$

The five initial parameters (\( S_0 \), \( E_0 \), \( k_+ \), \( k_- \), and \( k_v \))
are reduced to three dimensionless constants:

<ul>
 <li> \( \alpha \) is the dimensionless Michaelis constant, reflecting the
   ratio of the production of P and E (\( k_v+k_- \)) versus the production of
   the complex (\( k_+ \)), made dimensionless by \( E_0 \),</li>
 <li> \( \epsilon \) is the initial fraction of enzyme relative to the substrate,</li>
 <li> \( \beta \) measures the relative importance of production of P (\( k_v \))
   versus production of the complex (\( k_+ \)), made dimensionless by \( E_0 \).</li>
</ul>

Observe that software developed for
solving <a href="#mjx-eqn-48">(48)</a>-<a href="#mjx-eqn-51">(51)</a> cannot be reused
for solving <a href="#mjx-eqn-59">(59)</a>-<a href="#mjx-eqn-62">(62)</a> since the latter
system has a slightly different structure.

<h3 id="___sec60">Analysis of the scaled system </h3>

<p>
In the scaled system, we may assume \( \epsilon \) small, which from
<a href="#mjx-eqn-62">(62)</a> gives rise to the simplification
\( \epsilon\bar E^{\prime}=0 \), and thereby the relation \( \bar Q = \bar E\bar S \).
The conservation equation \( [ES] + [E]= E_0 \) reads \( Q_c\bar Q + E_0\bar E =
E_0 \) such that \( \bar E = 1 - Q_c\bar Q/E_0=1- \bar Q S_0/K = 1 - \epsilon^{-1}\alpha^{-1}\bar Q \). The relation \( \bar Q=\bar E\bar S \) then becomes

$$ \bar Q = (1 - \epsilon^{-1}\alpha^{-1}\bar Q)\bar S,$$

which can be solved for \( \bar Q \):

$$ \bar Q = \frac{\bar S}{1 + \epsilon^{-1}\alpha^{-1}\bar S}\tp$$

The equation <a href="#mjx-eqn-61">(61)</a> for \( \bar S \) becomes

$$
\begin{equation}
\frac{d\bar S}{d\bar t} = -\beta\alpha^{-1}\bar Q =
-\frac{\beta\bar S}{\alpha + \epsilon^{-1}\bar S}\tp
\tag{63}
\end{equation}
$$

This is a more precise analysis than the one leading to
<a href="#mjx-eqn-58">(58)</a> since we now realize that the
mathematical assumption for the simplification is
\( \epsilon\rightarrow 0 \).

<p>
Is <a href="#mjx-eqn-63">(63)</a> consistent with <a href="#mjx-eqn-58">(58)</a>? It is
easy to make algebraic mistakes when deriving scaled equations,
so it is always wise to carry out consistency checks.
Introducing dimensions in <a href="#mjx-eqn-63">(63)</a> leads to

$$
\frac{t_c}{S_0}\frac{d S}{dt} =
\frac{d\bar S}{d\bar t}  =
-\frac{\beta\bar S}{\alpha + \epsilon^{-1}\bar S}
= \frac{k_v}{k_+E_0}\frac{S}{KE_0^{-1} + E_0^{-1}S_0\bar S}
= \frac{k_v}{k_+}\frac{\bar S}{K + S},$$

and hence with \( t_c^{-1}=k_+E_0 \),

$$ \frac{dS}{dt} = \frac{k_vE_0 S}{K + S},$$

which is <a href="#mjx-eqn-58">(58)</a>.

<p>
Figure <a href="#scale:MMK:fig">6</a> shows the impact of \( \epsilon \): with a small
value (0.1) we see that \( \bar Q\approx 0 \), which justifies the
simplifications performed above. We also observe that all the unknowns
vary between 0 and about 1, indicating that the scaling is successful
for the chosen dimensionless numbers.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  Simulation of a biochemical process. <div id="scale:MMK:fig"></div> </p></center>
<p><img src="fig-scaling/biochem.png" align="bottom" width=700></p>
</center>

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

