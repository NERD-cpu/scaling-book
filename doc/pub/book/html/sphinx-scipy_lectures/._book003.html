<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Ordinary differential equation models</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Scaling of Differential Equations" href="index.html" />
    <link rel="next" title="Basic partial differential equation models" href="._book004.html" />
    <link rel="prev" title="Dimensions and units" href="._book002.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book004.html" title="Basic partial differential equation models"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book002.html" title="Dimensions and units"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Scaling of Differential Equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="ordinary-differential-equation-models">
<h1>Ordinary differential equation models<a class="headerlink" href="#ordinary-differential-equation-models" title="Permalink to this headline">¶</a></h1>
<p>This chapter introduces the basic techniques of scaling and the ways to
reason about scales. The first class of examples targets exponential
decay models, starting with the simple ordinary differential equation (ODE)
for exponential decay processes: <span class="math">\(u^{\prime}=-au\)</span>, with constant <span class="math">\(a&gt;0\)</span>.
Then we progress to various generalizations of this ODE, including nonlinear
versions and systems of ODEs. The next class of examples concerns
second-order ODEs for oscillatory systems, where the simplest
ODE reads <span class="math">\(mu^{\prime\prime} + ku=0\)</span>, with <span class="math">\(m\)</span> and <span class="math">\(k\)</span> as positive constants.
Various extensions with damping and force terms are discussed in detail.</p>
<div class="section" id="exponential-decay-problems">
<span id="sec-scale-decay"></span><h2>Exponential decay problems<a class="headerlink" href="#exponential-decay-problems" title="Permalink to this headline">¶</a></h2>
<div class="section" id="fundamental-ideas-of-scaling">
<h3>Fundamental ideas of scaling<a class="headerlink" href="#fundamental-ideas-of-scaling" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-0"></span><p id="index-1">Scaling is an extremely useful technique in mathematical modeling and
numerical simulation.  The purpose of the technique is three-fold:</p>
<ol class="arabic simple">
<li>Make independent and dependent variables dimensionless.</li>
<li>Make the size of independent and dependent variables about unity.</li>
<li>Reduce the number of independent physical parameters in the model.</li>
</ol>
<p id="index-2">The first two items mean that for any variable, denote it by
<span class="math">\(q\)</span>, we introduce a corresponding dimensionless variable</p>
<div class="math">
\[\bar q = \frac{q-q_0}{q_c},\]</div>
<p>where <span class="math">\(q_0\)</span> is a reference value of <span class="math">\(q\)</span> (<span class="math">\(q_0=0\)</span> is a common choice) and
<span class="math">\(q_c\)</span> is a characteristic size of <span class="math">\(|q|\)</span>, often referred to as &#8220;a scale&#8221;.
Since the numerator and denominator
have the same dimension, <span class="math">\(\bar q\)</span> becomes a dimensionless number.</p>
<p>If <span class="math">\(q_c\)</span> is the maximum value of <span class="math">\(|q-q_0|\)</span>, we see that <span class="math">\(0 &lt; |\bar
q|\leq 1\)</span>. How to find <span class="math">\(q_c\)</span> is sometimes the big challenge of
scaling. Examples will illustrate various approaches to meet this
challenge.</p>
<p>The many coming examples on scaling differential equations contain
the following pedagogical ingredients to meet the desired learning outcomes.</p>
<blockquote>
<div><ul class="simple">
<li>Teach the technical steps of making a mathematical model, based
on differential equations, dimensionless.</li>
<li>Describe various techniques for reasoning about the scales, i.e.,
finding the characteristic sizes of quantities.</li>
<li>Teach how to identify and interpret dimensionless numbers arising
from the scaling process.</li>
<li>Provide a lot of different examples on making models dimensionless
with physically correct scales.</li>
<li>Show how symbolic software (SymPy) can be used
to derive exact solutions of differential equations.</li>
<li>Explain how to run a dimensionless model with software developed
for the problem with dimensions.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="the-basic-model-problem">
<h3>The basic model problem<a class="headerlink" href="#the-basic-model-problem" title="Permalink to this headline">¶</a></h3>
<p id="index-3">Processes undergoing exponential reduction can be modeled by the ODE
problem</p>
<div class="math" id="eq-scale-model">
\[\tag{2}
u'(t) = -au(t),\quad u(0)=I,\]</div>
<p>where <span class="math">\(a,I&gt;0\)</span> are prescribed parameters, and <span class="math">\(u(t)\)</span> is the unknown function.
For the particular model with a constant <span class="math">\(a\)</span>, we can easily derive the exact
solution, <span class="math">\(u(t)=Ie^{-at}\)</span>,
which is helpful to have in mind during the scaling process.</p>
<div class="section" id="example-population-dynamics">
<h4>Example: Population dynamics<a class="headerlink" href="#example-population-dynamics" title="Permalink to this headline">¶</a></h4>
<p>The evolution of a population of humans, animals, cells, etc.,
under unlimited access to resources, can be
modeled by <a class="reference internal" href="#eq-scale-model"><span class="std std-ref">(2)</span></a>. Then <span class="math">\(u\)</span> is the number of
individuals in the population, strictly speaking an integer, but well
modeled by a real number in large populations.
The parameter <span class="math">\(a\)</span> is the increase in the number of individuals per
time and per individual.</p>
</div>
<div class="section" id="example-decay-of-pressure-with-altitude">
<h4>Example: Decay of pressure with altitude<a class="headerlink" href="#example-decay-of-pressure-with-altitude" title="Permalink to this headline">¶</a></h4>
<p>The simple model <a class="reference internal" href="#eq-scale-model"><span class="std std-ref">(2)</span></a> also governs the pressure
in the atmosphere (under many assumptions, such air is an ideal gas in
equilibrium). In this case <span class="math">\(u\)</span> is the
pressure, measured in <span class="math">\(\hbox{Nm}^{-2}\)</span>; <span class="math">\(t\)</span> is the height in meters;
and <span class="math">\(a=M/(R^*T)\)</span>, where
<span class="math">\(M\)</span> is the molar mass of the Earth&#8217;s air (0.029 kg/mol),
<span class="math">\(R^*\)</span> is the universal
gas constant (<span class="math">\(8.314\,\frac{\hbox{Nm}}{\hbox{mol K}}\)</span>),
and <span class="math">\(T\)</span> is the temperature in Kelvin (K).
The temperature depends on the height so we have <span class="math">\(a=a(t)\)</span>.</p>
</div>
</div>
<div class="section" id="the-technical-steps-of-the-scaling-procedure">
<span id="sec-scale-steps"></span><h3>The technical steps of the scaling procedure<a class="headerlink" href="#the-technical-steps-of-the-scaling-procedure" title="Permalink to this headline">¶</a></h3>
<div class="section" id="step-1-identify-independent-and-dependent-variables">
<h4>Step 1: Identify independent and dependent variables<a class="headerlink" href="#step-1-identify-independent-and-dependent-variables" title="Permalink to this headline">¶</a></h4>
<p>There is one independent variable, <span class="math">\(t\)</span>, and one dependent variable,
<span class="math">\(u\)</span>.</p>
<span class="target" id="index-4"></span></div>
<div class="section" id="step-2-make-independent-and-dependent-variables-dimensionless">
<span id="index-5"></span><h4>Step 2: Make independent and dependent variables dimensionless<a class="headerlink" href="#step-2-make-independent-and-dependent-variables-dimensionless" title="Permalink to this headline">¶</a></h4>
<p>We introduce a new dimensionless <span class="math">\(t\)</span>, called <span class="math">\(\bar t\)</span>, defined by</p>
<div class="math" id="eq-auto1">
\[\tag{3}
\bar t = \frac{t}{t_c},\]</div>
<p>where <span class="math">\(t_c\)</span> is a <em>characteristic value</em> of <span class="math">\(t\)</span>. Similarly,
we introduce a dimensionless <span class="math">\(u\)</span>, named <span class="math">\(\bar u\)</span>, according to</p>
<div class="math" id="eq-auto2">
\[\tag{4}
\bar u = \frac{u}{u_c},\]</div>
<p>where <span class="math">\(u_c\)</span> is a constant <em>characteristic size</em> of <span class="math">\(u\)</span>. When <span class="math">\(u\)</span> has a specific
interpretation, say when <a class="reference internal" href="#eq-scale-model"><span class="std std-ref">(2)</span></a> models pressure
in an atmospheric layer, <span class="math">\(u_c\)</span> would be referred to as characteristic pressure.
For a decaying population, <span class="math">\(u_c\)</span> may be a characteristic number of
members in the population, e.g., the initial population <span class="math">\(I\)</span>.</p>
</div>
<div class="section" id="step-3-derive-the-model-involving-only-dimensionless-variables">
<h4>Step 3: Derive the model involving only dimensionless variables<a class="headerlink" href="#step-3-derive-the-model-involving-only-dimensionless-variables" title="Permalink to this headline">¶</a></h4>
<p>The next task is to insert the new dimensionless variables in the
governing mathematical model. That is, we replace <span class="math">\(t\)</span> by <span class="math">\(t_c\bar t\)</span>
and <span class="math">\(u\)</span> by <span class="math">\(u_c\bar u\)</span> in <a class="reference internal" href="#eq-scale-model"><span class="std std-ref">(2)</span></a>. The derivative
with respect to <span class="math">\(\bar t\)</span> is derived through the chain rule as</p>
<div class="math">
\[\frac{du}{dt} = \frac{d (u_c\bar u)}{d\bar t}\frac{d\bar t}{dt}
= u_c\frac{d\bar u}{d\bar t}\frac{1}{t_c} =
\frac{u_c}{t_c}\frac{d\bar u}{d\bar t}{\thinspace .}\]</div>
<p>The model <a class="reference internal" href="#eq-scale-model"><span class="std std-ref">(2)</span></a> now becomes</p>
<div class="math" id="eq-scale-model-scaled0">
\[\tag{5}
\frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = -au_c\bar u,\quad u_c\bar u(0)=I{\thinspace .}\]</div>
</div>
<div class="section" id="step-4-make-each-term-dimensionless">
<h4>Step 4: Make each term dimensionless<a class="headerlink" href="#step-4-make-each-term-dimensionless" title="Permalink to this headline">¶</a></h4>
<p>Equation <a class="reference internal" href="#eq-scale-model-scaled0"><span class="std std-ref">(5)</span></a> still has terms with
dimensions. To make each term dimensionless, we usually divide by
the coefficient in front of the term with the highest time derivative
(but dividing by any coefficient in any term will do). The result is</p>
<div class="math" id="eq-scale-model-dimless0">
\[\tag{6}
\frac{d\bar u}{d\bar t} = -at_c\bar u,\quad \bar u(0)=u_c^{-1}I
    {\thinspace .}\]</div>
</div>
<div class="section" id="step-5-estimate-the-scales">
<h4>Step 5: Estimate the scales<a class="headerlink" href="#step-5-estimate-the-scales" title="Permalink to this headline">¶</a></h4>
<p>A characteristic quantity like <span class="math">\(t_c\)</span> reflects the time scale in the
problem. Estimating such a time scale is certainly
the most challenging part of the scaling procedure. There are different
ways to reason. The first approach
is to aim at a size of <span class="math">\(\bar u\)</span> and its derivatives
that is of order unity. If <span class="math">\(u_c\)</span> is chosen such that <span class="math">\(|\bar u|\)</span> is
of size unity, we see from <a class="reference internal" href="#eq-scale-model-dimless0"><span class="std std-ref">(6)</span></a> that
<span class="math">\(d\bar u/d\bar t\)</span> is of the size of <span class="math">\(\bar u\)</span> (i.e., unity)
if we choose <span class="math">\(t_c = 1/a\)</span>.</p>
<p id="index-6">Alternatively, we may look at a special case of the model where we have
analytical insight that can guide the choice of scales.
In the present problem we are lucky to know the
exact solution for any value of the input data as long as <span class="math">\(a\)</span>
is a constant. For exponential
decay,
<span class="math">\(u(t)\sim e^{-at}\)</span>, it is common to define a characteristic time
scale <span class="math">\(t_c\)</span> as the time it takes to reduce the initial value of
<span class="math">\(u\)</span> by a factor of <span class="math">\(1/e\)</span> (also called the <em>e-folding time</em>):</p>
<div class="math">
\[e^{-at_c} = \frac{1}{e}e^{-a\cdot 0}\quad\Rightarrow\quad e^{-at_c}=e^{-1},\]</div>
<p>from which it follows that <span class="math">\(t_c = 1/a\)</span>.
Note that using an exact solution of the problem to determine
scales is not a requirement, just a useful help in the few cases where
we actually have access to an exact solution.</p>
<p>In this example, two different, yet common ways of reasoning, lead to the
same value of <span class="math">\(t_c\)</span>. However, instead of using the e-folding time we
could use the half-time of the exponential decay as characteristic
time, which is also a very common measure of the time scale in such
processes. The half time is defined as the time it takes to halve <span class="math">\(u\)</span>:</p>
<div class="math">
\[e^{-at_c} = \frac{1}{2}e^{-a\cdot 0}
\quad\Rightarrow\quad t_c = a^{-1}\ln 2{\thinspace .}\]</div>
<p>There is a factor <span class="math">\(\ln 2 =0.69\)</span> difference from the other <span class="math">\(t_c\)</span> value.
As long as the factor is not an order of magnitude or more different,
we do not pay attention factors like <span class="math">\(\ln 2\)</span> and skip them, simply to make
formulas look nicer. Using
<span class="math">\(t_c = a^{-1}\ln 2\)</span> as time scale
leads to a scaled differential equation <span class="math">\(u'=-(\ln 2) u\)</span>,
which is fine, but an unusual form. People tend to prefer the simpler
ODE <span class="math">\(u'=-u\)</span>,
which arises from <span class="math">\(t_c=1/a\)</span>, and we shall therefore use this
time scale.</p>
<p>Regarding <span class="math">\(u_c\)</span>, we may look at the initial condition and realize that
the choice <span class="math">\(u_c=I\)</span> makes <span class="math">\(\bar u(0)=1\)</span>. For <span class="math">\(t&gt;0\)</span>, the differential
equation expresses explicitly that <span class="math">\(u\)</span> decreases, so <span class="math">\(u_c=I\)</span> gives
<span class="math">\(\bar u\in (0, 1]\)</span>. Scaling a variable <span class="math">\(q\)</span> such that <span class="math">\(|\bar q|\in
[0,1]\)</span> is always the ultimate goal, and this goal is in fact obtained
here! Next best result is to ensure that the magnitude of <span class="math">\(|q|\)</span> is not
&#8220;big&#8221; or &#8220;small&#8221;, in the sense that the size is neither as large as
10 or 100, nor as small as
0.1 or 0.01.  (In the
present problem, where we are lucky to have an exact solution
<span class="math">\(u(t)=Ie^{-at}\)</span>, we may look at this to explicitly see that <span class="math">\(u\in
(0,I]\)</span> such that <span class="math">\(u_c=I\)</span> gives <span class="math">\(\bar u\in (0,1]\)</span>).</p>
<p>With <span class="math">\(t_c=1/a\)</span> and <span class="math">\(u_c=I\)</span>, we have the final dimensionless model</p>
<div class="math" id="eq-scale-model-dimless">
\[\tag{7}
\frac{d\bar u}{d\bar t} = -\bar u,\quad \bar u(0)=1
    {\thinspace .}\]</div>
<p>This is a remarkable result in the sense that <em>all physical parameters</em>
(<span class="math">\(a\)</span> and <span class="math">\(I\)</span>)
are removed from the model! Or more precisely, there are no physical input
parameters to assign
before using the model. In particular, numerical investigations of the original
model <a class="reference internal" href="#eq-scale-model"><span class="std std-ref">(2)</span></a> would need experiments with different
<span class="math">\(a\)</span> and <span class="math">\(I\)</span> values, while numerical investigations of
<a class="reference internal" href="#eq-scale-model-dimless"><span class="std std-ref">(7)</span></a> can be limited to <em>a single run</em>! As soon
as we have computed the curve <span class="math">\(\bar u(\bar t)\)</span>, we can find the
solution <span class="math">\(u(t)\)</span> of <a class="reference internal" href="#eq-scale-model"><span class="std std-ref">(2)</span></a> by</p>
<div class="math" id="eq-scale-u-dim">
\[\tag{8}
u(t) = u_c\bar u(t/t_c) = I\bar u(at)
    {\thinspace .}\]</div>
<p>This particular transformation actually means stretching the <span class="math">\(\bar t\)</span> and
<span class="math">\(\bar u\)</span> axes in a plot of <span class="math">\(\bar u(\bar t)\)</span> by the factors <span class="math">\(a\)</span> and <span class="math">\(I\)</span>,
respectively.</p>
<p>It is very common to drop the bars when the scaled problem has been
derived and work further with <a class="reference internal" href="#eq-scale-model-dimless"><span class="std std-ref">(7)</span></a> simply
written as</p>
<div class="math">
\[\frac{du}{dt} = -u,\quad u(0)=1
{\thinspace .}\]</div>
<p>Nevertheless, in this booklet we have decided to stick to bars for all
dimensionless quantities.</p>
</div>
</div>
<div class="section" id="making-software-for-utilizing-the-scaled-model">
<span id="sec-scale-prog"></span><h3>Making software for utilizing the scaled model<a class="headerlink" href="#making-software-for-utilizing-the-scaled-model" title="Permalink to this headline">¶</a></h3>
<p>Software for solving <a class="reference internal" href="#eq-scale-model"><span class="std std-ref">(2)</span></a> could take advantage of
the fact that only one simulation of <a class="reference internal" href="#eq-scale-model-dimless"><span class="std std-ref">(7)</span></a>
is necessary. As soon as we have <span class="math">\(\bar u(\bar t)\)</span> accessible, a simple
scaling <a class="reference internal" href="#eq-scale-u-dim"><span class="std std-ref">(8)</span></a> computes the real <span class="math">\(u(t)\)</span> for any
given input data <span class="math">\(a\)</span> and <span class="math">\(I\)</span>. Although the numerical computation of
<span class="math">\(u(t)\)</span> from <a class="reference internal" href="#eq-scale-model"><span class="std std-ref">(2)</span></a> is very fast in this simple model
problem, using <a class="reference internal" href="#eq-scale-u-dim"><span class="std std-ref">(8)</span></a> is very much faster. In
general, a simple rescaling of a scaled solution is extremely more
computationally efficient than solving a differential equation
problem.</p>
<p>We can compute with the dimensionless model <a class="reference internal" href="#eq-scale-model-dimless"><span class="std std-ref">(7)</span></a>
in two ways, either make a solver for <a class="reference internal" href="#eq-scale-model-dimless"><span class="std std-ref">(7)</span></a>,
or reuse a solver for <a class="reference internal" href="#eq-scale-model"><span class="std std-ref">(2)</span></a> with
<span class="math">\(I=1\)</span> and <span class="math">\(a=1\)</span>.
We will choose the latter approach since it has the advantage of giving us
software that works both with a dimensionless model and a model
with dimensions (and all the original physical parameters).</p>
<div class="section" id="software-for-the-original-unscaled-problem">
<h4>Software for the original unscaled problem<a class="headerlink" href="#software-for-the-original-unscaled-problem" title="Permalink to this headline">¶</a></h4>
<p>Assume that we have some module <code class="docutils literal"><span class="pre">decay.py</span></code> that offers the following functions:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">solver(I,</span> <span class="pre">a,</span> <span class="pre">T,</span> <span class="pre">dt,</span> <span class="pre">theta=0.5)</span></code> for returning the solution arrays
<code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">t</span></code>, over a time interval <span class="math">\([0,T]\)</span>,
for <a class="reference internal" href="#eq-scale-model"><span class="std std-ref">(2)</span></a> solved by the so-called
<span class="math">\(\theta\)</span> rule. This rule includes the Forward Euler scheme (<span class="math">\(\theta=0\)</span>),
the Backward Euler scheme (<span class="math">\(\theta=1\)</span>), or the Crank-Nicolson
(centered midpoint) scheme (<span class="math">\(\theta=\frac{1}{2}\)</span>).</li>
<li><code class="docutils literal"><span class="pre">read_command_line_argparse()</span></code> for reading parameters in the problem
from the command line and returning them: <code class="docutils literal"><span class="pre">I</span></code>, <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">T</span></code>, <code class="docutils literal"><span class="pre">theta</span></code> (<span class="math">\(\theta\)</span>),
and a list of <span class="math">\(\Delta t\)</span> values for time steps. (We shall only make
use of the first <span class="math">\(\Delta t\)</span> value.)</li>
</ul>
</div></blockquote>
<p>The basic statements for solving <a class="reference internal" href="#eq-scale-model"><span class="std std-ref">(2)</span></a> are
then</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decay</span> <span class="kn">import</span> <span class="n">solver</span><span class="p">,</span> <span class="n">read_command_line_argparse</span>
<span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line_argparse</span><span class="p">()</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">plot</span><span class="p">,</span> <span class="n">show</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The module <a class="reference external" href="http://tinyurl.com/o8pb3yy/decay.py">decay.py</a> is developed
and explained in</p>
<p>Section 5.1.7 in
the book <a class="reference external" href="http://tinyurl.com/nclmcng/doc/pub/book">Finite Difference Computing with Exponential Decay Models</a> <a class="reference internal" href="._book005.html#ref07" id="id1">[Ref07]</a>.</p>
<p>To solve the dimensionless problem, just fix <span class="math">\(I=1\)</span> and <span class="math">\(a=1\)</span>,
and choose <span class="math">\(\bar T\)</span> and <span class="math">\(\Delta\bar t\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line_argparse</span><span class="p">()</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
</pre></div>
</div>
<p>The first two variables returned from <code class="docutils literal"><span class="pre">read_command_line_argparse</span></code>
are <code class="docutils literal"><span class="pre">I</span></code> and <code class="docutils literal"><span class="pre">a</span></code>, which are ignored here. To indicate that these
variables are not to be used, we use a
&#8220;dummy name&#8221;, often taken to be the underscore symbol in
Python. The user can set <code class="docutils literal"><span class="pre">--I</span></code> and <code class="docutils literal"><span class="pre">--a</span></code> on the command line, since
the <code class="docutils literal"><span class="pre">decay</span></code> module allows this, but we hope the code above has a form
that reminds the user that these options are not to be used.
Also note that <code class="docutils literal"><span class="pre">T</span></code> and <code class="docutils literal"><span class="pre">dt_values[0]</span></code> set on the command line are
the desired parameters for solving the <em>scaled</em> problem.</p>
</div>
<div class="section" id="software-for-the-scaled-problem">
<h4>Software for the scaled problem<a class="headerlink" href="#software-for-the-scaled-problem" title="Permalink to this headline">¶</a></h4>
<p>Turning now to the scaled problem, the solver function (originally
designed for the unscaled problem) will be reused, but it will only
be run if it is strictly necessary. That is, when the user requests
a solution, our code should first check whether that solution can be provided
by simply scaling a solution already computed and available in a file.
If not, we will compute an appropriate scaled solution, find the
requested unscaled solution for the user, and also save the new scaled
solution to file for possible later use.</p>
<p>A very plain solution to the problem is found in the file
<a class="reference external" href="http://tinyurl.com/o8pb3yy/decay_scaled_v1.py">decay_scaled_v1.py</a>.
The <code class="docutils literal"><span class="pre">np.savetxt</span></code> function saves a two-dimensional array (&#8220;table&#8221;) to
a text file, and the <code class="docutils literal"><span class="pre">np.loadtxt</span></code> function can load the data back
into the program. A better solution to this problem is obtained
by using the <code class="docutils literal"><span class="pre">joblib</span></code> package as described next.</p>
<span class="target" id="index-7"></span></div>
<div class="section" id="implementation-with-joblib">
<span id="index-8"></span><h4>Implementation with joblib<a class="headerlink" href="#implementation-with-joblib" title="Permalink to this headline">¶</a></h4>
<p>The Python package <code class="docutils literal"><span class="pre">joblib</span></code> has functionality that is very convenient
for implementing the <code class="docutils literal"><span class="pre">solver_scaled</span></code> function. The first time a
function is called with a set of arguments, the statements in the
function are executed and the return value is saved to file. If the
function is called again with the same set of arguments, the
statements in the function are not executed, but the return value is
read from file (of course, many files may be stored, one for each
combination of parameter values).  In computer science, one would say
that <code class="docutils literal"><span class="pre">joblib</span></code> in this way provides <em>memorization</em> functionality for
Python functions.  This functionality is particularly aimed at
large-scale computations with arrays that one would hesitate to
recompute. We illustrate the technique here in a very simple
mathematical context.</p>
<p>First we make a <code class="docutils literal"><span class="pre">solver_scaled</span></code> function for the scaled
model that just calls up a <code class="docutils literal"><span class="pre">solver_unscaled</span></code> (with <span class="math">\(I=a=1\)</span>) for the problem with
dimensions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decay</span> <span class="kn">import</span> <span class="n">solver</span> <span class="k">as</span> <span class="n">solver_unscaled</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">solver_scaled</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-u, u(0)=1 for (0,T] with step dt and theta method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s1">&#39;Computing the numerical solution&#39;</span>
    <span class="k">return</span> <span class="n">solver_unscaled</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we create some &#8220;computer memory on disk&#8221;, i.e., some disk space to
store the result of a call to the <code class="docutils literal"><span class="pre">solver_scaled</span></code> function. Thereafter,
we redefine the name <code class="docutils literal"><span class="pre">solver_scaled</span></code> to a new function, created
by <code class="docutils literal"><span class="pre">joblib</span></code>, which calls our original <code class="docutils literal"><span class="pre">solver_scaled</span></code> function
if necessary and otherwise loads data from file:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">joblib</span>
<span class="n">disk_memory</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">Memory</span><span class="p">(</span><span class="n">cachedir</span><span class="o">=</span><span class="s1">&#39;temp&#39;</span><span class="p">)</span>
<span class="n">solver_scaled</span> <span class="o">=</span> <span class="n">disk_memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">solver_scaled</span><span class="p">)</span>
</pre></div>
</div>
<p>The solutions are actually stored in files in the cache directory <code class="docutils literal"><span class="pre">temp</span></code>.</p>
<p>A typical use case is to read values from the command line,
solve the scaled problem (if necessary), unscale the solution, and visualize
the solution with dimension:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">unscale</span><span class="p">(</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">t_scaled</span>

<span class="kn">from</span> <span class="nn">decay</span> <span class="kn">import</span> <span class="n">read_command_line_argparse</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Read unscaled parameters, solve and plot</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line_argparse</span><span class="p">()</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># use only the first dt value</span>
    <span class="n">T_bar</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">T</span>
    <span class="n">dt_bar</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">dt</span>
    <span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span> <span class="o">=</span> <span class="n">solver_scaled</span><span class="p">(</span><span class="n">T_bar</span><span class="p">,</span> <span class="n">dt_bar</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">unscale</span><span class="p">(</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_scaled</span><span class="p">,</span> <span class="n">u_scaled</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;scaled time&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;scaled velocity&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Universial solution of scaled problem&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp1.png&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp1.pdf&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;I=</span><span class="si">%g</span><span class="s1">, a=</span><span class="si">%g</span><span class="s1">, theta=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp2.png&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp2.pdf&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The complete code resides in the file
<a class="reference external" href="http://tinyurl.com/o8pb3yy/decay_scaled.py">decay_scaled.py</a>.
Note from the code above that <code class="docutils literal"><span class="pre">read_command_line_argparse</span></code> is supposed
to read parameters with dimensions (but technically, we solve the
scaled problem, if strictly necessary, and unscale the solution).
Let us run</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; python decay_scaled.py --I 8 --a 0.1 --dt 0.01 --T 50
</pre></div>
</div>
<p>A plot of the scaled and unscaled solution appears in Figure
<a class="reference internal" href="#sec-decay-fig-simplest"><span class="std std-ref">Scaled (left) and unscaled (right) exponential decay</span></a>.</p>
<div class="figure" id="id5">
<span id="sec-decay-fig-simplest"></span><a class="reference internal image-reference" href="_images/decay.png"><img alt="_images/decay.png" src="_images/decay.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Scaled (left) and unscaled (right) exponential decay</em></span></p>
</div>
<p>Note that we write a message <code class="docutils literal"><span class="pre">Computing</span> <span class="pre">the</span> <span class="pre">numerical</span> <span class="pre">solution</span></code> inside
the <code class="docutils literal"><span class="pre">solver_scaled</span></code> function. We can then easily detect when
the solution is actually computed from scratch
and when it is simply read from file (followed by the unscaling procedure).
Here is a demo:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; # Very first run
Terminal&gt; python decay_scaled.py --T 7 --a 1 --I 0.5 --dt 0.2
[Memory] Calling __main__--home-hpl...
solver_scaled-alias(7.0, 0.2, 0.5)
Computing the numerical solution

Terminal&gt; # No change of T, dt, theta - can reuse solution in file
Terminal&gt; python decay_scaled.py --T 7 --a 4 --I 2.5 --dt 0.2

Terminal&gt; # Change of dt, must recompute
Terminal&gt; python decay_scaled.py --T 7 --a 4 --I 2.0 --dt 0.5
[Memory] Calling __main__--home-hpl...
solver_scaled-alias(7.0, 0.5, 0.5)
Computing the numerical solution

Terminal&gt; # Change of dt again, but dt=0.2 is already in a file
Terminal&gt; python decay_scaled.py --T 7 --a 0.5 --I 1 --dt 0.2
</pre></div>
</div>
<p>We realize that <code class="docutils literal"><span class="pre">joblib</span></code> has access to all previous runs and does not
recompute unless it is strictly required. Our previous implementation
without <code class="docutils literal"><span class="pre">joblib</span></code> (in <code class="docutils literal"><span class="pre">decay_scaled_v1.py</span></code>)
used only one file (for one numerical case)
and will therefore perform many more calls to
<code class="docutils literal"><span class="pre">solver_unscaled</span></code>.</p>
<div class="admonition-on-the-implementation-of-a-simple-memoize-function admonition">
<p class="first admonition-title">On the implementation of a simple memoize function</p>
<p>A memoized function recalls
previous results when the same set
of arguments is encountered. That is, the function caches its results.
A simple implementation stores the arguments in a function call and
the returned results in a
dictionary, and if the arguments are seen again, one looks up
in the dictionary and returns previously computed results:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Memoize</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># map arguments to results</span>

<span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">args</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">args</span><span class="p">]</span>

<span class="c1"># Wrap my_compute_function(arg1, arg2, ...)</span>
<span class="n">my_compute_function</span> <span class="o">=</span> <span class="n">Memoize</span><span class="p">(</span><span class="n">my_compute_function</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">The memoize functionality in <code class="docutils literal"><span class="pre">joblib.Memory</span></code> is more sophisticated and
can work very efficiently with large array data structures as arguments.
Note that the simple version above can only be used when all arguments to
the function <code class="docutils literal"><span class="pre">f</span></code> are immutable (since the key in a dictionary has to be
immutable).</p>
</div>
</div>
</div>
<div class="section" id="scaling-a-generalized-problem">
<span id="sec-scale-body"></span><h3>Scaling a generalized problem<a class="headerlink" href="#scaling-a-generalized-problem" title="Permalink to this headline">¶</a></h3>
<p>Now we consider an extension of the exponential decay ODE to the
form</p>
<div class="math" id="eq-scale-model-g">
\[ \begin{align}\begin{aligned}\tag{9}
u'(t) = -au(t) + b,\quad u(0)=I\\    {\thinspace .}\end{aligned}\end{align} \]</div>
<p>One particular model, with constant <span class="math">\(a\)</span> and <span class="math">\(b\)</span>,
is a spherical small-sized organism falling in air,</p>
<div class="math" id="eq-scale-model-g-spec">
\[\tag{10}
u' = - \frac{3\pi d\mu}{\varrho_b V} u + g\left(\frac{\varrho}{\varrho_b} -1\right),\]</div>
<p>where <span class="math">\(d\)</span>, <span class="math">\(\mu\)</span>, <span class="math">\(\varrho_b\)</span>, <span class="math">\(\varrho\)</span>, <span class="math">\(V\)</span>, and <span class="math">\(g\)</span> are physical
parameters. The function <span class="math">\(u(t)\)</span> represents the vertical velocity,
being positive upwards.
We shall use this model in the following.</p>
<div class="section" id="exact-solution-1">
<h4>Exact solution<a class="headerlink" href="#exact-solution-1" title="Permalink to this headline">¶</a></h4>
<p>It can be handy to have the exact solution for reference, in case
of constant <span class="math">\(a\)</span> and <span class="math">\(b\)</span>:</p>
<div class="math">
\[{u_{\small\mbox{e}}}(t) = \frac{e^{-at}}{a}\left( b(e^{at}-1) + aI\right)
{\thinspace .}\]</div>
<div class="admonition-solving-differential-equations-in-sympy admonition">
<p class="first admonition-title">Solving differential equations in SymPy</p>
<p>It can be very useful to use a symbolic computation tool such as SymPy
to aid us in solving differential equations.
Let us therefore demonstrate how SymPy can be used to find this solution.
First we define the parameters in the problem as symbols
and <span class="math">\(u(t)\)</span> as a function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t a b I&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
</pre></div>
</div>
<p>The next task is to define the differential equation, either as
a symbolic expression that is to equal zero, or as
an equation <code class="docutils literal"><span class="pre">Eq(lhs,</span> <span class="pre">rhs)</span></code> with <code class="docutils literal"><span class="pre">lhs</span></code> and <code class="docutils literal"><span class="pre">rhs</span></code> as expressions for
the left- and right-hand side):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define differential equation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">),</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The differential equation can be solved by the <code class="docutils literal"><span class="pre">dsolve</span></code> function, yielding
an equation of the form <code class="docutils literal"><span class="pre">u(t)</span> <span class="pre">==</span> <span class="pre">expression</span></code>. We want to grab the
expression on the right-hand side as our solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sol</span>
<span class="go">u(t) == (b + exp(a*(C1 - t)))/a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span>                    <span class="c1"># grab solution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">u</span>
<span class="go">(b + exp(a*(C1 - t)))/a</span>
</pre></div>
</div>
<p>The solution contains the unknown integration constant <code class="docutils literal"><span class="pre">C1</span></code>, which must
be determined by the initial condition. We form the equation arising
from the initial condition <span class="math">\(u(0)=I\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">I</span><span class="p">)</span>   <span class="c1"># substitute t by 0 in u</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">C1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sol</span>
<span class="go">[log(I*a - b)/a]</span>
</pre></div>
</div>
<p>The one solution that was found (stored in a list!)
must then be substituted back in the
expression <code class="docutils literal"><span class="pre">u</span></code> to yield the final solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">u</span>
<span class="go">(b + exp(a*(-t + log(I*a - b)/a)))/a</span>
</pre></div>
</div>
<p>As in mathematics with pen and paper, we strive to simplify
expressions also in symbolic computing software.
This frequently requires some trial and error
process with SymPy&#8217;s simplification functions. A very standard
first try is to expand everything and run simplification algorithms:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">u</span>
<span class="go">(I*a + b*exp(a*t) - b)*exp(-a*t)/a</span>
</pre></div>
</div>
<p class="last">Doing <code class="docutils literal"><span class="pre">latex(u)</span></code> automatically converts the expression to LaTeX syntax
for inclusion in reports.</p>
</div>
<p>The reader may wonder why we bother with scaling of differential
equations if SymPy can solved the problem in a nice, closed
formula. This is true in the present introductory problem, but in a
more general problem setting, we have some differential equation where
SymPy perhaps can help with finding an exact solution only in a
special case. We can use this special-case solution to control our
reasoning about scales in the more general setting.</p>
</div>
<div class="section" id="theory">
<h4>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h4>
<p>The challenges in our scaling is to find the right <span class="math">\(u_c\)</span> and <span class="math">\(t_c\)</span>
scales. From <a class="reference internal" href="#eq-scale-model-g"><span class="std std-ref">(9)</span></a> we see that if <span class="math">\(u'\rightarrow 0\)</span>
as <span class="math">\(t\rightarrow\infty\)</span>, <span class="math">\(u\)</span> approaches the constant value <span class="math">\(b/a\)</span>. It can be
convenient to let the scaled <span class="math">\(\bar u\rightarrow 1\)</span> as
we approach the <span class="math">\(d\bar u/d\bar t = 0\)</span> state. This idea points to choosing</p>
<div class="math" id="eq-auto3">
\[\tag{11}
u_c = \frac{b}{a} = g\left(\frac{\varrho}{\varrho_b} -1\right)\left(\frac{3\pi d\mu}{\varrho_b V}\right)^{-1}
    {\thinspace .}\]</div>
<div class="admonition-on-the-sign-of-the-scaled-velocity admonition">
<p class="first admonition-title">On the sign of the scaled velocity</p>
<p class="last">A little note on the sign of <span class="math">\(u_c\)</span> is necessary here.
With <span class="math">\(\varrho_b &lt; \varrho\)</span>, the buoyancy force upwards wins over the
gravity force downwards, and the body will move upwards. In this case,
the terminal velocity <span class="math">\(u_c &gt; 0\)</span>. When <span class="math">\(\varrho_b &gt; \varrho\)</span>, we get
a motion downwards, and <span class="math">\(u_c &lt; 0\)</span>. The corresponding <span class="math">\(u\)</span> is then also
negative, but the scaled velocity <span class="math">\(u/u_c\)</span>, becomes positive.</p>
</div>
<p id="index-9">Inserting <span class="math">\(u = u_c\bar u = b\bar u/a\)</span> and <span class="math">\(t=t_c\bar t\)</span> in
<a class="reference internal" href="#eq-scale-model-g"><span class="std std-ref">(9)</span></a> leads to</p>
<div class="math">
\[\frac{d\bar u}{d\bar t} = -t_c a\bar u + \frac{t_c}{u_c}b,
\quad \bar u(0) = I\frac{a}{b}
{\thinspace .}\]</div>
<p>We want the scales such that <span class="math">\(d\bar u/d\bar t\)</span> and <span class="math">\(\bar u\)</span> are
about unity.
To balance the size of <span class="math">\(\bar u\)</span> and <span class="math">\(d\bar u/d\bar t\)</span> we must
therefore choose
<span class="math">\(t_c = 1/a\)</span>, resulting in the scaled ODE problem</p>
<div class="math" id="eq-scale-model-g-dimless">
\[\tag{12}
\frac{d\bar u}{d\bar t} = -\bar u + 1,\quad \bar u(0)=\beta,\]</div>
<p>where <span class="math">\(\beta\)</span> is a dimensionless number,</p>
<div class="math" id="eq-auto4">
\[\tag{13}
\beta = \frac{I}{u_c} = I\frac{a}{b},\]</div>
<p>reflecting the ratio of the initial velocity and the
terminal (<span class="math">\(t\rightarrow \infty\)</span>) velocity <span class="math">\(b/a\)</span>.
Scaled equations normally end up with one or more dimensionless parameters,
such as <span class="math">\(\beta\)</span> here, containing ratios of physical effects in
the model. Many more examples on dimensionless parameters will appear
in later sections.</p>
<p>The analytical solution of the scaled model
<a class="reference internal" href="#eq-scale-model-g-dimless"><span class="std std-ref">(12)</span></a> reads</p>
<div class="math" id="eq-scale-model-g-exact-scaled">
\[\tag{14}
\bar{u_{\small\mbox{e}}}(t) =
    e^{-t}\left( e^{t}-1 + \beta\right) = 1 + (\beta -1)e^{-t}{\thinspace .}\]</div>
<p>The result <a class="reference internal" href="#eq-scale-model-g-dimless"><span class="std std-ref">(12)</span></a> with the
solution <a class="reference internal" href="#eq-scale-model-g-exact-scaled"><span class="std std-ref">(14)</span></a> is actually
astonishing if <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are as in <a class="reference internal" href="#eq-scale-model-g-spec"><span class="std std-ref">(10)</span></a>:
the six parameters <span class="math">\(d\)</span>, <span class="math">\(\mu\)</span>, <span class="math">\(\varrho_b\)</span>, <span class="math">\(\varrho\)</span>, <span class="math">\(V\)</span>, and <span class="math">\(g\)</span>
are conjured to one:</p>
<div class="math">
\[\beta = I\frac{3\pi d\mu}{\varrho_b V}
\frac{1}{g}\left(\frac{\varrho}{\varrho_b} -1\right)^{-1},\]</div>
<p>which is an enormous simplification of the problem if our aim is to
investigate how <span class="math">\(u\)</span> varies with the physical input parameters in
the model.
In particular, if the motion starts from rest, <span class="math">\(\beta=0\)</span>, and
there are no physical parameters in the scaled model!
We can then perform a single simulation and recover all physical
cases by the unscaling procedure. More precisely,
having computed <span class="math">\(\bar u(\bar t)\)</span> from <a class="reference internal" href="#eq-scale-model-g-dimless"><span class="std std-ref">(12)</span></a>,
we can use</p>
<div class="math" id="eq-auto5">
\[\tag{15}
u(t) = \frac{b}{a}\bar u(at),\]</div>
<p>to scale back to the original
problem again.
We observe that <a class="reference internal" href="#eq-scale-model-g-dimless"><span class="std std-ref">(12)</span></a> can utilize a solver
for <a class="reference internal" href="#eq-scale-model-g"><span class="std std-ref">(9)</span></a> by setting <span class="math">\(a=1\)</span>, <span class="math">\(b=1\)</span>, and <span class="math">\(I=\beta\)</span>.
Given some implementation of a solver for <a class="reference internal" href="#eq-scale-model-g"><span class="std std-ref">(9)</span></a>,
say <code class="docutils literal"><span class="pre">solver(I,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">T,</span> <span class="pre">dt,</span> <span class="pre">theta)</span></code>,
the scaled model is run by <code class="docutils literal"><span class="pre">solver(beta,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">T,</span> <span class="pre">dt,</span> <span class="pre">theta)</span></code>.</p>
</div>
<div class="section" id="software-1">
<span id="index-10"></span><h4>Software<a class="headerlink" href="#software-1" title="Permalink to this headline">¶</a></h4>
<p>We may develop a solver for the scaled problem that uses <code class="docutils literal"><span class="pre">joblib</span></code>
to cache solutions with the same <span class="math">\(\beta\)</span>, <span class="math">\(\Delta t\)</span>, and <span class="math">\(T\)</span>.
For now we fix <span class="math">\(\theta=0.5\)</span>.
The module <a class="reference external" href="http://tinyurl.com/o8pb3yy/decay_vc.py">decay_vc.py</a>
(see the
section <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book006.html#implementation-of-the-generalized-model-problem">Implementation of the generalized model problem</a>
<a class="reference internal" href="._book005.html#ref07" id="id2">[Ref07]</a> for details)
has a function
<code class="docutils literal"><span class="pre">solver(I,</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">T,</span> <span class="pre">dt,</span> <span class="pre">theta)</span></code> for solving <span class="math">\(u'(t)=-a(t)u(t)+b(t)\)</span> for
<span class="math">\(t\in (0,T]\)</span>, <span class="math">\(u(0)=I\)</span>, with time step <code class="docutils literal"><span class="pre">dt</span></code>.
We reuse this function and call it with <span class="math">\(a=b=1\)</span> and <span class="math">\(I=\beta\)</span> to solve
the scaled problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decay_vc</span> <span class="kn">import</span> <span class="n">solver</span> <span class="k">as</span> <span class="n">solver_unscaled</span>

<span class="k">def</span> <span class="nf">solver_scaled</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-u+1, u(0)=beta for (0,T]</span>
<span class="sd">    with step dt and theta method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s1">&#39;Computing the numerical solution&#39;</span>
    <span class="k">return</span> <span class="n">solver_unscaled</span><span class="p">(</span>
        <span class="n">I</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">joblib</span>
<span class="n">disk_memory</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">Memory</span><span class="p">(</span><span class="n">cachedir</span><span class="o">=</span><span class="s1">&#39;temp&#39;</span><span class="p">)</span>
<span class="n">solver_scaled</span> <span class="o">=</span> <span class="n">disk_memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">solver_scaled</span><span class="p">)</span>
</pre></div>
</div>
<p>If we want to plot the physical solution, we need an <code class="docutils literal"><span class="pre">unscale</span></code> function,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">unscale</span><span class="p">(</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ab</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">t_scaled</span>

<span class="k">def</span> <span class="nf">ab</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">mu</span><span class="o">/</span><span class="p">(</span><span class="n">rho_b</span><span class="o">*</span><span class="n">V</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">g</span><span class="o">*</span><span class="p">(</span><span class="n">rho</span><span class="o">/</span><span class="n">rho_b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
</pre></div>
</div>
<p>Looking at droplets of water in air, we can fix some of the parameters
and let the size parameter <span class="math">\(d\)</span> be the one for experimentation.
The following function sets physical parameters, computes <span class="math">\(\beta\)</span>,
runs the solver for the scaled problem (<code class="docutils literal"><span class="pre">joblib</span></code> detects
if it is necessary), and finally plots the scaled curve
<span class="math">\(\bar u(\bar t)\)</span> and the unscaled curve <span class="math">\(u(t)\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.075</span><span class="p">,</span> <span class="c1"># Time step, scaled problem</span>
         <span class="n">T</span><span class="o">=</span><span class="mf">7.5</span><span class="p">,</span>    <span class="c1"># Final time, scaled problem</span>
         <span class="n">d</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>  <span class="c1"># Diameter (unscaled problem)</span>
         <span class="n">I</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>      <span class="c1"># Initial velocity (unscaled problem)</span>
         <span class="p">):</span>
    <span class="c1"># Set parameters, solve and plot</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="mf">0.00129E+3</span>  <span class="c1"># air</span>
    <span class="n">rho_b</span> <span class="o">=</span> <span class="mf">1E+3</span>      <span class="c1"># density of water</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="mf">0.001</span>        <span class="c1"># viscosity of water</span>
    <span class="c1"># Asumme we have list or similar for d</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>

    <span class="n">legends1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">legends2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">betas</span> <span class="o">=</span> <span class="p">[]</span>     <span class="c1"># beta values already computed (for plot)</span>

    <span class="k">for</span> <span class="n">d_</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">d_</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>  <span class="c1"># volume</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ab</span><span class="p">(</span><span class="n">d_</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">a</span><span class="o">/</span><span class="n">b</span>
        <span class="c1"># Restrict to 3 digits in beta</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">print</span> <span class="s1">&#39;beta=</span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">beta</span>
        <span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span> <span class="o">=</span> <span class="n">solver_scaled</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

        <span class="c1"># Avoid plotting curves with the same beta value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">beta</span> <span class="ow">in</span> <span class="n">betas</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_scaled</span><span class="p">,</span> <span class="n">u_scaled</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>
            <span class="n">legends1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;beta=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">beta</span><span class="p">)</span>
        <span class="n">betas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">unscale</span><span class="p">(</span><span class="n">u_scaled</span><span class="p">,</span> <span class="n">t_scaled</span><span class="p">,</span> <span class="n">d_</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rho_b</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>
        <span class="n">legends2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;d=</span><span class="si">%g</span><span class="s1"> [mm]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d_</span><span class="o">*</span><span class="mi">1000</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;scaled time&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;scaled velocity&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The most complicated part of the code is related to plotting, but
this part can be skipped when trying to understand how we work with
a scaled model to perform the computations.
The complete program is found in the file
<a class="reference external" href="http://tinyurl.com/o8pb3yy/falling_body.py">falling_body.py</a>.</p>
<p>Since <span class="math">\(I=0\)</span> implies <span class="math">\(\beta=0\)</span>, we can run different <span class="math">\(d\)</span> values without
any need to recompute <span class="math">\(\bar u(\bar t)\)</span> as long as we assume the particle
starts from rest.</p>
<p>From the scaling, we see that <span class="math">\(u_c = b/a\sim d^{-2}\)</span> and
also that <span class="math">\(t_c=1/a \sim d^{-2}\)</span>, so plotting of <span class="math">\(u(t)\)</span> with dimensions
for various <span class="math">\(d\)</span> values will involve significant variations in the time
and velocity scales. Figure <a class="reference internal" href="#sec-scale-body-fig"><span class="std std-ref">Velocity of falling body: scaled (left) and with dimensions (right)</span></a>
has an example with <span class="math">\(d=1,2,3\)</span> mm, where we clearly see the different
time and velocity scales in the figure with unscaled variables.
Note that the scaled velocity is positive because of the sign of <span class="math">\(u_c\)</span>
(see the box above).</p>
<div class="figure" id="id6">
<span id="sec-scale-body-fig"></span><a class="reference internal image-reference" href="_images/falling_body.png"><img alt="_images/falling_body.png" src="_images/falling_body.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Velocity of falling body: scaled (left) and with dimensions (right)</em></span></p>
</div>
</div>
</div>
<div class="section" id="variable-coefficients">
<span id="sec-scale-jump"></span><h3>Variable coefficients<a class="headerlink" href="#variable-coefficients" title="Permalink to this headline">¶</a></h3>
<p>When a prescribed coefficient like <span class="math">\(a(t)\)</span> in <span class="math">\(u'(t) = -a(t)u(t)\)</span>
varies with time one usually also
performs a scaling of this <span class="math">\(a\)</span>,</p>
<div class="math">
\[\bar a(\bar t) = \frac{a(t) - a_0}{a_c},\]</div>
<p>where the goal is to have the scaled <span class="math">\(\bar a\)</span>
of size unity: <span class="math">\(|\bar a|\leq 1\)</span>.
This property is obtained by choosing <span class="math">\(a_c\)</span> as the maximum value
of <span class="math">\(|a(t)-a_0|\)</span> for <span class="math">\(t\in [0,T]\)</span>, which is usually a quantity that
can be estimated since <span class="math">\(a(t)\)</span> is known as a function of <span class="math">\(t\)</span>. The <span class="math">\(a_0\)</span>
parameter can be chosen as 0 here. (It could be tempting to
choose <span class="math">\(a_0=\min_t a(t)\)</span> so that <span class="math">\(0\leq \bar a\leq 1\)</span>, but then there
is at least one point where <span class="math">\(\bar a = 0\)</span> and
the differential equation collapses to <span class="math">\(u'=0\)</span>.)</p>
<p>As an example, imagine a decaying cell culture where we at time <span class="math">\(t_1\)</span>
change the environment (typically the nutrition)
such that the death rate increases by a factor 5.
Mathematically, <span class="math">\(a(t) = d\)</span> for
<span class="math">\(t &lt; t_1\)</span> and <span class="math">\(a(t)=5d\)</span> for <span class="math">\(t\geq t_1\)</span>. The model reads <span class="math">\(u'=-a(t)u\)</span>, <span class="math">\(u(0)=I\)</span>.</p>
<p>The <span class="math">\(a(t)\)</span> function is scaled by letting the characteristic size be
<span class="math">\(a_c=d\)</span> and <span class="math">\(a_0=0\)</span>:</p>
<div class="math">
\[\begin{split}\bar a (\bar t) = \left\lbrace\begin{array}{ll}
1, &amp; \bar t &lt; t_1/t_c\\
5, &amp; \bar t \geq t_1/t_c
\end{array}\right.\end{split}\]</div>
<p id="index-11">The scaled equation becomes</p>
<div class="math">
\[\frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = a_c\bar a(\bar t) u_c\bar u,\quad
u_c\bar u(0) = I{\thinspace .}\]</div>
<p>The natural choice of <span class="math">\(u_c\)</span> is <span class="math">\(I\)</span>.
The characteristic time, previously taken as <span class="math">\(t_c=1/a\)</span>, can now be
chosen as <span class="math">\(t_c=t_1\)</span> or <span class="math">\(t_c=1/d\)</span>.
With <span class="math">\(t_c=1/d\)</span> we get</p>
<div class="math" id="eq-sec-scale-jump-eq1">
\[\begin{split}\tag{16}
\bar u'(\bar t)=-\bar a\bar u,\quad \bar u(0)=1,\quad
    \bar a = \left\lbrace\begin{array}{ll}
    1, &amp; \bar t &lt; \gamma\\
    5, &amp; \bar t \geq \gamma
    \end{array}\right.\end{split}\]</div>
<p>where</p>
<div class="math">
\[\gamma = t_1 d\]</div>
<p>is a dimensionless number in the problem. With <span class="math">\(t_c=t_1\)</span>, we get</p>
<div class="math">
\[\begin{split}\bar u'(\bar t)=-\gamma\bar a\bar u,\quad \bar u(0)=1,\quad
\bar a = \left\lbrace\begin{array}{ll}
1, &amp; \bar t &lt; 1\\
5, &amp; \bar t \geq 1
\end{array}\right.\end{split}\]</div>
<p>The dimensionless parameter <span class="math">\(\gamma\)</span> is now in the equation rather than in
the definition of <span class="math">\(\bar a\)</span>. Both problems involve <span class="math">\(\gamma\)</span>, which
is the ratio between the time when the environmental change happens
and the typical time for the decay (<span class="math">\(1/d\)</span>).</p>
<p>A computation with the scaled model <a class="reference internal" href="#eq-sec-scale-jump-eq1"><span class="std std-ref">(16)</span></a>
and the original model with dimensions appears in
Figure <a class="reference internal" href="#sec-scale-jump-fig"><span class="std std-ref">Exponential decay with jump: scaled model (left) and unscaled model (right)</span></a>.</p>
<div class="figure" id="id7">
<span id="sec-scale-jump-fig"></span><a class="reference internal image-reference" href="_images/decay_jump.png"><img alt="_images/decay_jump.png" src="_images/decay_jump.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Exponential decay with jump: scaled model (left) and unscaled model (right)</em></span></p>
</div>
</div>
<div class="section" id="scaling-a-cooling-problem-with-constant-temperature-in-the-surroundings">
<span id="scale-cooling-const"></span><h3>Scaling a cooling problem with constant temperature in the surroundings<a class="headerlink" href="#scaling-a-cooling-problem-with-constant-temperature-in-the-surroundings" title="Permalink to this headline">¶</a></h3>
<p>The heat exchange between a body at temperature <span class="math">\(T(t)\)</span> and the
surroundings at constant temperature <span class="math">\(T_s\)</span>
can be modeled by Newton&#8217;s law of cooling:</p>
<div class="math" id="eq-scale-cooling-model">
\[\tag{17}
T'(t) = -k(T-T_s),\quad T(0)=T_0,\]</div>
<p>where <span class="math">\(k\)</span> is a prescribed heat transfer coefficient.</p>
<div class="section" id="exact-solution-2">
<h4>Exact solution<a class="headerlink" href="#exact-solution-2" title="Permalink to this headline">¶</a></h4>
<p>An analytical solution is always handy to have as a control of the
choice of scales. The solution of <a class="reference internal" href="#eq-scale-cooling-model"><span class="std std-ref">(17)</span></a>
is by standard methods for ODEs found to be
<span class="math">\(T(t) = T_s + (T_0 - T_s)e^{-kt}\)</span>.</p>
</div>
<div class="section" id="scaling-1">
<h4>Scaling<a class="headerlink" href="#scaling-1" title="Permalink to this headline">¶</a></h4>
<p>Physically, we expect the temperature to start at <span class="math">\(T_0\)</span> and then to
move toward the temperature of the surroundings (<span class="math">\(T_s\)</span>). We therefore
expect that <span class="math">\(T\)</span> lies between <span class="math">\(T_0\)</span> and <span class="math">\(T_s\)</span>. This is mathematically
demonstrated by the analytical solution as well. A proper scaling is
therefore to scale and translate <span class="math">\(T\)</span> according to</p>
<div class="math" id="eq-scale-cooling-tbar">
\[ \begin{align}\begin{aligned}\tag{18}
\bar T = \frac{T-T_0}{T_s-T_0}\\    {\thinspace .}\end{aligned}\end{align} \]</div>
<p>Now, <span class="math">\(0\leq \bar T\leq 1\)</span>.</p>
<p>Scaling time by <span class="math">\(\bar t = t/t_c\)</span> and inserting
<span class="math">\(T= T_0 + (T_s-T_0)\bar T\)</span> and <span class="math">\(t=t_c\bar t\)</span> in the
problem <a class="reference internal" href="#eq-scale-cooling-model"><span class="std std-ref">(17)</span></a> gives</p>
<div class="math">
\[\frac{d\bar T}{d\bar t} = - t_ck(\bar T - 1),\quad \bar T(0) = 0
{\thinspace .}\]</div>
<p>A natural choice, as argued in other exponential decay problems,
is to choose <span class="math">\(t_ck=1\)</span>, which leaves us with the scaled problem</p>
<div class="math" id="eq-scale-cooling-tbar-eq">
\[ \begin{align}\begin{aligned}\tag{19}
\frac{d\bar T}{d\bar t} = - (\bar T - 1),\quad \bar T(0)=0\\    {\thinspace .}\end{aligned}\end{align} \]</div>
<p>No physical parameter enters this problem!
Our scaling implies that <span class="math">\(\bar T\)</span> starts at
0 and approaches 1 as <span class="math">\(\bar t\rightarrow\infty\)</span>, also in the case
<span class="math">\(T_s &lt; T_0\)</span>. The physical temperature is always recovered as</p>
<div class="math" id="eq-scale-cooling-t">
\[ \begin{align}\begin{aligned}\tag{20}
T(t) = T_0 + (T_s-T_0)\bar T (k\bar t)\\    {\thinspace .}\end{aligned}\end{align} \]</div>
</div>
<div class="section" id="software-2">
<h4>Software<a class="headerlink" href="#software-2" title="Permalink to this headline">¶</a></h4>
<p>An implementation for <a class="reference internal" href="#eq-scale-cooling-model"><span class="std std-ref">(17)</span></a> works for
<a class="reference internal" href="#eq-scale-cooling-tbar-eq"><span class="std std-ref">(19)</span></a> by setting <span class="math">\(k=1\)</span>, <span class="math">\(T_s=1\)</span>, and <span class="math">\(T_0=0\)</span>.</p>
</div>
<div class="section" id="alternative-scaling-1">
<h4>Alternative scaling<a class="headerlink" href="#alternative-scaling-1" title="Permalink to this headline">¶</a></h4>
<p>An alternative temperature scaling is to choose</p>
<div class="math" id="eq-scale-cooling-tbar2">
\[ \begin{align}\begin{aligned}\tag{21}
\bar T = \frac{T-T_s}{T_0-T_s}\\    {\thinspace .}\end{aligned}\end{align} \]</div>
<p>Now <span class="math">\(\bar T=1\)</span> initially and approaches zero as <span class="math">\(t\rightarrow\infty\)</span>.
The resulting scaled ODE problem then becomes</p>
<div class="math" id="eq-scale-cooling-tbar-eq2">
\[ \begin{align}\begin{aligned}\tag{22}
\frac{d\bar T}{d\bar t} = - \bar T,\quad \bar T(0)=1,\\    {\thinspace .}\end{aligned}\end{align} \]</div>
<p>with solution <span class="math">\(\bar T = e^{-\bar t}\)</span>.</p>
</div>
</div>
<div class="section" id="scaling-a-cooling-problem-with-time-dependent-surroundings">
<span id="scale-cooling-osc"></span><h3>Scaling a cooling problem with time-dependent surroundings<a class="headerlink" href="#scaling-a-cooling-problem-with-time-dependent-surroundings" title="Permalink to this headline">¶</a></h3>
<p>Let us apply the model <a class="reference internal" href="#eq-scale-cooling-model"><span class="std std-ref">(17)</span></a> to the case when
the surrounding temperature varies in time. Say we have
an oscillating temperature environment according to</p>
<div class="math" id="eq-scale-cooling-tst">
\[\tag{23}
T_s(t) = T_m + a\sin(\omega t),\]</div>
<p>where <span class="math">\(T_m\)</span> is the mean temperature in the surroundings, <span class="math">\(a\)</span> is
the amplitude of the variations around <span class="math">\(T_m\)</span>, and <span class="math">\(2\pi/\omega\)</span> is
the period of the temperature oscillations.</p>
<div class="section" id="exact-solution-3">
<h4>Exact solution<a class="headerlink" href="#exact-solution-3" title="Permalink to this headline">¶</a></h4>
<p>Also in this relatively simple problem
it is possible to solve the differential equation problem analytically.
Such a solution may be a good help to see what the scales are, and
especially to control other forms for reasoning about the scales.
Using the method of integrating factors for the
original differential equation, we have</p>
<div class="math">
\[T(t) = T_0e^{-kt} + e^{-kt}k\int_0^t e^{k\tau}T_s(\tau)d\tau{\thinspace .}\]</div>
<p>With <span class="math">\(T_s(t)=T_m + a\sin (\omega t)\)</span> we can use SymPy to help us with
integrations (note that we use <code class="docutils literal"><span class="pre">w</span></code> for <span class="math">\(\omega\)</span> in the computer code):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">T_m</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t k T_m a w&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T_s</span> <span class="o">=</span> <span class="n">T_m</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">T_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Q</span>
<span class="go">(-T_m*k**2 - T_m*w**2 + a*k*w +</span>
<span class="go">(T_m*k**2 + T_m*w**2 + a*k**2*sin(t*w) -</span>
<span class="go">a*k*w*cos(t*w))*exp(k*t))*exp(-k*t)/((k**2 + w**2))</span>
</pre></div>
</div>
<p>Reordering the result, we get</p>
<div class="math">
\[T(t) = T_0e^{-kt} + T_m(1- e^{-kt}) +  (k^2 + \omega^2)^{-1}(ak\omega e^{-kt}
+ ak\sin (\omega t) - akw\cos(\omega t)){\thinspace .}\]</div>
</div>
<div class="section" id="scaling-2">
<span id="index-12"></span><h4>Scaling<a class="headerlink" href="#scaling-2" title="Permalink to this headline">¶</a></h4>
<p>The scaling <a class="reference internal" href="#eq-scale-cooling-tbar"><span class="std std-ref">(18)</span></a> brings in a time-dependent
characteristic temperature scale <span class="math">\(T_s-T_0\)</span>. Let us start with a
fixed scale, where we take the characteristic temperature variation to
be <span class="math">\(T_m - T_0\)</span>:</p>
<div class="math">
\[\bar T = \frac{T-T_0}{T_m-T_0}{\thinspace .}\]</div>
<p>We realize by physical
reasoning that <span class="math">\(T\)</span> sets out at <span class="math">\(T_0\)</span>, but with time, it will oscillate
around <span class="math">\(T_m\)</span>. (This reasoning can be controlled by looking at the exact
solution we produced above.)
The typical average temperature span is therefore
<span class="math">\(|T_m-T_0|\)</span>, unless <span class="math">\(a\)</span> is much larger than <span class="math">\(|T_m-T_0|\)</span> or <span class="math">\(T_0\)</span> is
very close to
<span class="math">\(T_m\)</span> (see <a class="reference internal" href="#sec-scale-exer-decay-cooling-osc"><span class="std std-ref">Exercise 2.3: Perform alternative scalings</span></a> for
a discussion of these cases).</p>
<p>We get from the differential equation, with <span class="math">\(t_c=1/k\)</span> as in the former
case,</p>
<div class="math">
\[k(T_m-T_0)\frac{d\bar T}{d\bar t} = -k((T_m-T_0)\bar T + T_0 - T_m - a
\sin(\omega t),\]</div>
<p>resulting in</p>
<div class="math" id="eq-scale-cooling-model-scaled">
\[\tag{24}
\frac{d\bar T}{d\bar t} = -\bar T + 1 + \alpha\sin (\beta \bar t),\quad
    \bar T(0)=0,\]</div>
<p>where we have two dimensionless numbers:</p>
<div class="math">
\[\alpha = \frac{a}{T_m-T_0},\quad \beta = \frac{\omega}{k}{\thinspace .}\]</div>
<p>The <span class="math">\(\alpha\)</span> quantity measures the ratio of temperatures: amplitude of
oscillations versus distance from initial temperature to the average
temperature for large times.  The <span class="math">\(\beta\)</span> number is the ratio of the
two time scales: the frequency of the oscillations in <span class="math">\(T_s\)</span> and the
inverse e-folding time of the heat transfer. For clear interpretation
of <span class="math">\(\beta\)</span> we may introduce the period <span class="math">\(P=2\pi/\omega\)</span> of the
oscillations in <span class="math">\(T_s\)</span> and the e-folding time <span class="math">\(e=1/k\)</span>. Then <span class="math">\(\beta =
2\pi e/P\)</span> and measures the e-folding time versus the period.</p>
<div class="admonition-remark admonition">
<p class="first admonition-title">Remark</p>
<p class="last">The original problem features five physical parameters: <span class="math">\(k\)</span>, <span class="math">\(T_0\)</span>,
<span class="math">\(T_m\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(\omega\)</span>, but only two dimensionless numbers appear in the
scaled model <a class="reference internal" href="#eq-scale-cooling-model-scaled"><span class="std std-ref">(24)</span></a>.
In fact, this is an example where application of the Pi theorem
(see the section <a class="reference internal" href="._book002.html#scale-dimunit-pi"><span class="std std-ref">The Buckingham Pi theorem</span></a>) falls
short. Since, only time and temperature are involved as unit types, the
theorem predicts that the five parameters yields three dimensionless numbers,
not two. Scaling of the differential equations, on the other hand,
shows us that the two parameters
<span class="math">\(T_m\)</span> and <span class="math">\(T_0\)</span> affect the nature of the problem only through their difference.</p>
</div>
</div>
<div class="section" id="software-3">
<h4>Software<a class="headerlink" href="#software-3" title="Permalink to this headline">¶</a></h4>
<p>Implementations of the unscaled problem <a class="reference internal" href="#eq-scale-cooling-model"><span class="std std-ref">(17)</span></a>
can be reused for the scaled model by setting <span class="math">\(k=1\)</span>, <span class="math">\(T_0=0\)</span>, and
<span class="math">\(T_s(t) = 1 + \alpha\sin (\beta \bar t)\)</span> (<span class="math">\(T_m=1\)</span>, <span class="math">\(a=\alpha\)</span>, <span class="math">\(\omega =\beta\)</span>).
The file <a class="reference external" href="http://tinyurl.com/o8pb3yy/osc_cooling.py">osc_cooling.py</a> contains
solvers for the problem with dimensions and
for the scaled problem. The figure below
shows three cases of <span class="math">\(\beta\)</span> values: small, medium, and large.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/osc_cooling.png"><img alt="_images/osc_cooling.png" src="_images/osc_cooling.png" style="width: 500px;" /></a>
</div>
<p>For the small <span class="math">\(\beta\)</span> value, the oscillations in the surrounding
temperature are slow enough compared to <span class="math">\(k\)</span> for the heating and
cooling process to follow the surrounding temperature, with a small
time lag. For larger <span class="math">\(\beta\)</span>, the heating and cooling require more
time, and the oscillations get smaller.</p>
</div>
<div class="section" id="discussion-of-the-time-scale-1">
<h4>Discussion of the time scale<a class="headerlink" href="#discussion-of-the-time-scale-1" title="Permalink to this headline">¶</a></h4>
<p>There are two time variations of importance in the present problem:
heat is transferred to the surroundings at a rate <span class="math">\(k\)</span>, and the
surroundings have a temperature variation with a period that goes like
<span class="math">\(1/\omega\)</span>. (We can, when we are so lucky that we have an analytical
solution at hand, inspect this solution to see that <span class="math">\(k\)</span> impacts the
problem through a decay factor <span class="math">\(e^{-kt}\)</span>, and <span class="math">\(\omega\)</span> impacts the problem
through oscillations <span class="math">\(\sin(\omega t)\)</span>.)  The <span class="math">\(k\)</span> parameter related to
temperature decay points to a time scale <span class="math">\(t_c=1/k\)</span>, while the
temperature oscillations of the surroundings point to a time scale
<span class="math">\(t_c=1/\omega\)</span>.  Which one should be chosen?</p>
<p>Bringing the temperature from <span class="math">\(T_0\)</span> to the level of the surroundings,
<span class="math">\(T_m\)</span>, goes like <span class="math">\(e^{-kt}\)</span>, so in this process <span class="math">\(t_c=1/k\)</span> is the
characteristic time. Thereafter, the body&#8217;s temperature just responds
to the oscillations and the <span class="math">\(\sin (\omega t)\)</span> (and <span class="math">\(\cos(\omega t)\)</span>)
term dominates. For these large times, <span class="math">\(t_c=1/\omega\)</span> is the
appropriate time scale. Choosing <span class="math">\(t_c=1/\omega\)</span> results in</p>
<div class="math" id="eq-scale-cooling-model-scaled2">
\[\tag{25}
\frac{d\bar T}{d\bar t} = -\beta^{-1}(\bar T - (1 + \alpha\sin (\bar t))),\quad
    \bar T(0)=0{\thinspace .}\]</div>
<p>Let us illustrate another, less effective, scaling.
The temperature scale in
<a class="reference internal" href="#eq-scale-cooling-tbar"><span class="std std-ref">(18)</span></a> looks natural, so we apply this
choice of scale. The characteristic temperature <span class="math">\(T_0-T_s\)</span>
now involves
a time-dependent term <span class="math">\(T_s(t)\)</span>. The mathematical steps become a bit
more technically involved:</p>
<div class="math">
\[T(t) = T_0 + (T_s(t)-T_0)\bar T,\]</div>
<div class="math">
\[\frac{dT}{dt} = \frac{dT_s}{dt}\bar T +
(T_s-T_0)\frac{d\bar T}{d\bar t}\frac{d\bar t}{dt}
{\thinspace .}\]</div>
<p>With <span class="math">\(\bar t = t/t_c = kt\)</span> we get from the differential equation</p>
<div class="math">
\[\frac{dT_s}{dt}\bar T +
(T_s-T_0)\frac{d\bar T}{d\bar t}k
= -k(\bar T - 1)(T_s - T_0),\]</div>
<p>which after dividing by <span class="math">\(k(T_s-T_0)\)</span> results in</p>
<div class="math">
\[\frac{d\bar T}{d\bar t} = -(\bar T - 1) -
\frac{dT_s}{dt}\frac{\bar T}{k(T_s-T_0},\]</div>
<p>or</p>
<div class="math">
\[\frac{d\bar T}{d\bar t} = -(\bar T - 1) -
\frac{a\omega\cos(\omega \bar t/k)}{k(T_m + a\sin(\omega \bar t/k) -T_0)}\bar T
{\thinspace .}\]</div>
<p>The last term is complicated and becomes more tractable if we factor
out dimensionless numbers. To this end, we scale <span class="math">\(T_s\)</span> by (e.g.) <span class="math">\(T_m\)</span>,
which means to factor out <span class="math">\(T_m\)</span> in the denominator. We are then
left with</p>
<div class="math" id="eq-scale-cooling-tbar-eq3">
\[\tag{26}
\frac{d\bar T}{d\bar t} = -(\bar T - 1) -
    \alpha\beta \frac{\cos(\beta \bar t)}{1 + \alpha\sin(\beta\bar t) - \gamma}
    \bar T,\]</div>
<p>where <span class="math">\(\alpha\)</span>, <span class="math">\(\beta\)</span>, and <span class="math">\(\gamma\)</span> are dimensionless numbers
characterizing the relative importance of parameters in the problem:</p>
<div class="math" id="eq-auto6">
\[\tag{27}
\alpha=a/T_m,\quad \beta = \omega/k,\quad \gamma = T_0/T_m
    {\thinspace .}\]</div>
<p>We notice that <a class="reference internal" href="#eq-scale-cooling-tbar-eq3"><span class="std std-ref">(26)</span></a>
is not a special case of the original problem
<a class="reference internal" href="#eq-scale-cooling-model"><span class="std std-ref">(17)</span></a>. Furthermore, the original five
parameters <span class="math">\(k\)</span>, <span class="math">\(T_m\)</span>, <span class="math">\(a\)</span>, <span class="math">\(\omega\)</span>, and
<span class="math">\(T_0\)</span> are reduced to three dimensionless parameters.
We conclude that this scaling is inferior, because
using the temperature scale <span class="math">\(T_0-T_m\)</span> enables reuse of the software
for the unscaled problem and only two dimensionless parameters appear
in the scaled model.</p>
<p>Let us briefly mention another possible temperature scaling:
<span class="math">\(\bar T = T/T_m\)</span>, motivated by the fact that as <span class="math">\(t\rightarrow\infty\)</span>,
<span class="math">\(T\)</span> will oscillate around <span class="math">\(T_m\)</span>, so this <span class="math">\(\bar T\)</span> will oscillate around
unity. We get the dimensionless ODE</p>
<div class="math">
\[\frac{d\bar T}{d\bar t} = -(\bar T - (1 + \delta\sin(\beta\bar t))),\]</div>
<p>with a new dimensionless parameter <span class="math">\(\delta = a/T_m\)</span>. However, the initial
condition becomes <span class="math">\(\bar T(0)=T_0/T_m\)</span>, and the ratio <span class="math">\(T_0/T_m\)</span> is
a third dimensionless parameter, so this scaling is also inferior to the
one above with only two parameters.</p>
</div>
</div>
<div class="section" id="scaling-a-nonlinear-ode">
<span id="sec-scale-nonlinear"></span><h3>Scaling a nonlinear ODE<a class="headerlink" href="#scaling-a-nonlinear-ode" title="Permalink to this headline">¶</a></h3>
<p id="index-13">Exponential growth models, <span class="math">\(u'=au\)</span>, are not realistic in environments
with limited resources. However, by letting <span class="math">\(a\)</span> depend on <span class="math">\(u\)</span>, the effect
of limited resources can well be captured by such a simple differential
equation model:</p>
<div class="math" id="eq-sec-scale-nonlinear-model1">
\[\tag{28}
u' = a(u)u,\quad u(0)=I{\thinspace .}\]</div>
<p>If the maximum value of <span class="math">\(u\)</span> is denoted by <span class="math">\(M\)</span>, we have that <span class="math">\(a(M)=0\)</span>.
A simple choice fulfilling this requirement is <span class="math">\(a(u)=\varrho(1-u/M)\)</span>.
The parameter <span class="math">\(\varrho\)</span> can be interpreted as the initial exponential
growth rate if we assume that <span class="math">\(I/M\ll 1\)</span>, since at <span class="math">\(t=0\)</span> the model then
approximates <span class="math">\(u'=\varrho u\)</span>.</p>
<p>The choice <span class="math">\(a(u)=\varrho(1-u/M)\)</span> is known as the logistic model for
population growth:</p>
<div class="math" id="eq-sec-scale-nonlinear-model2">
\[\tag{29}
u' = \varrho u(1-u/M),\quad u(0)=I{\thinspace .}\]</div>
<p>A more complicated choice of <span class="math">\(a\)</span> may be <span class="math">\(a(u)=\varrho(1-u/M)^p\)</span> for
some exponent <span class="math">\(p\)</span> (this function also fulfills <span class="math">\(a(M)=0\)</span> and <span class="math">\(a\approx\varrho\)</span>
for <span class="math">\(t=0\)</span>).</p>
<div class="section" id="scaling-3">
<span id="index-14"></span><h4>Scaling<a class="headerlink" href="#scaling-3" title="Permalink to this headline">¶</a></h4>
<p>Let us scale <a class="reference internal" href="#eq-sec-scale-nonlinear-model1"><span class="std std-ref">(28)</span></a> with
<span class="math">\(a(u)=\varrho (1-u/M)^p\)</span>.
The natural scale for <span class="math">\(u\)</span> is <span class="math">\(M\)</span> (<span class="math">\(u_c=M\)</span>), since we know that
<span class="math">\(0 &lt; u\leq M\)</span>, and this makes the dimensionless <span class="math">\(\bar u = u/M \in (0,1]\)</span>.
The function <span class="math">\(a(u)\)</span> is
typically varying between 0 and <span class="math">\(\varrho\)</span>, so it can be scaled as</p>
<div class="math">
\[\bar a(\bar u) = \frac{a(u)}{\varrho} = (1 - \frac{u}{M})^p =
(1 - \bar u)^p{\thinspace .}\]</div>
<p>Time is scaled as <span class="math">\(\bar t = t/t_c\)</span> for some suitable characteristic time <span class="math">\(t_c\)</span>.
Inserted in <a class="reference internal" href="#eq-sec-scale-nonlinear-model1"><span class="std std-ref">(28)</span></a>, we get</p>
<div class="math">
\[\frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = \varrho\bar a u_c\bar u,\quad u_c\bar u(0)=I,\]</div>
<p>resulting in</p>
<div class="math">
\[\frac{d\bar u}{d\bar t} = t_c \varrho (1 - \bar u)^p \bar u,\quad
\bar u(0) =\frac{I}{M}{\thinspace .}\]</div>
<p>A natural choice is <span class="math">\(t_c =1/\varrho\)</span> as in other exponential growth models
since it leads to the term on the right-hand side to be about unity,
just as the left-hand side. (If the scaling is correct, <span class="math">\(\bar u\)</span> and its
derivatives are of order unity, so the coefficients must also be of order
unity.) Introducing also the dimensionless parameter</p>
<div class="math">
\[\alpha = \frac{I}{M},\]</div>
<p>measuring the fraction of the initial population compared to the maximum
one, we get the dimensionless model</p>
<div class="math" id="eq-sec-scale-nonlinear-model1-scaled">
\[\tag{30}
\frac{d\bar u}{d\bar t} = (1 - \bar u)^p \bar u,\quad
    \bar u(0) =\alpha{\thinspace .}\]</div>
<p>Here, we have two dimensionless parameters: <span class="math">\(\alpha\)</span> and <span class="math">\(p\)</span>. A classical
logistic model with <span class="math">\(p=1\)</span> has only one dimensionless variable.</p>
</div>
<div class="section" id="alternative-scaling-2">
<h4>Alternative scaling<a class="headerlink" href="#alternative-scaling-2" title="Permalink to this headline">¶</a></h4>
<p>We could try another scaling of <span class="math">\(u\)</span> where we also translate <span class="math">\(\bar u\)</span>:</p>
<div class="math">
\[\bar u = \frac{u-I}{M}{\thinspace .}\]</div>
<p>This choice of <span class="math">\(\bar u\)</span> results in</p>
<div class="math" id="eq-sec-scale-nonlinear-model1-scaled2">
\[\tag{31}
\frac{d\bar u}{d\bar t} = (1 - \alpha - \bar u)^p \bar u,\quad
    \bar u(0) =0{\thinspace .}\]</div>
<p>The essential difference between <a class="reference internal" href="#eq-sec-scale-nonlinear-model1-scaled"><span class="std std-ref">(30)</span></a>
and <a class="reference internal" href="#eq-sec-scale-nonlinear-model1-scaled2"><span class="std std-ref">(31)</span></a> is that
<span class="math">\(\bar u\in [\alpha, 1]\)</span> in the former and <span class="math">\(\bar u \in [0, 1-\alpha]\)</span> in
the latter. Both models involve the dimensionless numbers <span class="math">\(\alpha\)</span> and <span class="math">\(p\)</span>.
An advantage of <a class="reference internal" href="#eq-sec-scale-nonlinear-model1-scaled"><span class="std std-ref">(30)</span></a>
is that software for the unscaled model can easily be used for the
scaled model by choosing <span class="math">\(I=\alpha\)</span>, <span class="math">\(M=1\)</span>, and <span class="math">\(\varrho=1\)</span>.</p>
</div>
</div>
<div class="section" id="sir-ode-system-for-spreading-of-diseases">
<h3>SIR ODE system for spreading of diseases<a class="headerlink" href="#sir-ode-system-for-spreading-of-diseases" title="Permalink to this headline">¶</a></h3>
<p>The field of epidemiology frequently applies ODE systems to describe
the spreading of diseases, such as smallpox, measles, plague, ordinary
flu, swine flu, and HIV. Different models include different effects,
which are reflected in dimensionless numbers. Most of the effects are
modeled as exponential decay or growth of the dependent variables.</p>
<p>The simplest model has three categories of people: susceptibles (S)
who can get the disease, infectious (I) who are infected and may
infect susceptibles, and recovered (R) who have recovered from the
disease and gained immunity. We introduce <span class="math">\(S(t)\)</span>, <span class="math">\(I(t)\)</span>, and <span class="math">\(R(t)\)</span>
as the number of people in the categories S, I, and R, respectively.
The model, naturally known as the <a class="reference external" href="https://en.wikipedia.org/wiki/Epidemic_model">SIR model</a>, can be expressed as a
system of three ODEs:</p>
<div class="math" id="eq-scale-sir-s">
\[\tag{32}
\frac{dS}{dt} = - \beta SI,\]</div>
<div class="math" id="eq-scale-sir-i">
\[\tag{33}
\frac{dI}{dt} = \beta SI - \nu I,\]</div>
<div class="math" id="eq-scale-sir-r">
\[\tag{34}
\frac{dR}{dt} = \nu I,\]</div>
<p>where <span class="math">\(\beta\)</span> and <span class="math">\(\nu\)</span> are empirical constants. The average time for recovering
from the disease can be shown to be <span class="math">\(\nu^{-1}\)</span>, but <span class="math">\(\beta\)</span> is much harder
to estimate, so working with a scaled model where <span class="math">\(\beta\)</span> is &#8220;scaled away&#8221;
is advantageous.</p>
<div class="section" id="scaling-4">
<h4>Scaling<a class="headerlink" href="#scaling-4" title="Permalink to this headline">¶</a></h4>
<p>It is natural to scale <span class="math">\(S\)</span>, <span class="math">\(I\)</span>, and <span class="math">\(R\)</span> by, e.g., <span class="math">\(S(0)\)</span>:</p>
<div class="math">
\[\bar S = \frac{S}{S(0)},\quad \bar I = \frac{I}{S(0)},\quad
\bar R = \frac{R}{S(0)}{\thinspace .}\]</div>
<p>Introducing <span class="math">\(\bar t = t/t_c\)</span>, we arrive at the equations</p>
<div class="math">
\[\begin{split}\frac{d\bar S}{d\bar t} &amp;= - t_c S(0) \beta\bar S\bar I,
\\
\frac{d\bar I}{d\bar t} &amp;= t_c S(0) \beta \bar S\bar I - t_c \nu \bar I,
\\
\frac{d\bar R}{d\bar t} &amp;= t_c \nu \bar I,\end{split}\]</div>
<p>with initial conditions <span class="math">\(\bar S(0)=1\)</span>, <span class="math">\(\bar I(0)=I_0/S(0)=\alpha\)</span>, and
<span class="math">\(\bar R(0)=R(0)/S(0)\)</span>. Normally, <span class="math">\(R(0)=0\)</span>.</p>
<p>Taking <span class="math">\(t_c=1/\nu\)</span>, corresponding to a time unit equal to the time it takes
to recover from the disease, we end up with the scaled model</p>
<div class="math" id="eq-scale-sir-s2">
\[\tag{35}
\frac{d\bar S}{d\bar t} = - R_0\bar S\bar I,\]</div>
<div class="math" id="eq-scale-sir-i2">
\[\tag{36}
\frac{d\bar I}{d\bar t} = R_0 \bar S\bar I - \bar I,\]</div>
<div class="math" id="eq-scale-sir-r2">
\[\tag{37}
\frac{d\bar R}{d\bar t} = \bar I,\]</div>
<p>with <span class="math">\(\bar S(0)=1\)</span>, <span class="math">\(\bar I(0)=\alpha\)</span>, <span class="math">\(\bar R(0)=0\)</span>, and <span class="math">\(R_0\)</span> as
the dimensionless number</p>
<div class="math" id="eq-auto7">
\[\tag{38}
R_0 = \frac{S(0)\beta}{\nu}{\thinspace .}\]</div>
<p>We see from <a class="reference internal" href="#eq-scale-sir-i2"><span class="std std-ref">(36)</span></a> that to make the disease spreading,
<span class="math">\(d\bar I/d\bar t &gt;0\)</span>, and therefore <span class="math">\(R_0 \bar S(0) - 1 &gt; 0\)</span> or <span class="math">\(R_0 &gt; 1\)</span>
since <span class="math">\(\bar S(0)=1\)</span>.
Therefore, <span class="math">\(R_0\)</span> reflects the disease&#8217;s ability to spread and is
consequently an important dimensionless quantity, known as the <a class="reference external" href="https://en.wikipedia.org/wiki/Basic_reproduction_number">basic
reproduction number</a>.
This number reflects the number of infected people caused by one infectious
individual during the time period of the disease.</p>
<p>Looking at <a class="reference internal" href="#eq-scale-sir-i"><span class="std std-ref">(33)</span></a>, we see that to increase <span class="math">\(I\)</span> initially,
we must have <span class="math">\(dI/dt &gt;0\)</span> at <span class="math">\(t=0\)</span>, which implies
<span class="math">\(\beta I(0)S(0) - \nu I(0) &gt;0\)</span>, i.e., <span class="math">\(R_0 &gt; 1\)</span>.</p>
</div>
<div class="section" id="software-4">
<h4>Software<a class="headerlink" href="#software-4" title="Permalink to this headline">¶</a></h4>
<p>Any implementation of the SIR model with dimensions can be reused for
the scaled model by setting <span class="math">\(\beta = R_0\)</span>, <span class="math">\(\nu = 1\)</span>, <span class="math">\(S(0)=1-\alpha\)</span>,
and <span class="math">\(I(0)=\alpha\)</span>. Below is a plot with two cases: <span class="math">\(R_0=2\)</span> and <span class="math">\(R_0=5\)</span>,
both with <span class="math">\(\alpha=0.02\)</span>.</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/SIR1.png"><img alt="_images/SIR1.png" src="_images/SIR1.png" style="width: 800px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="alternative-scaling-3">
<h4>Alternative scaling<a class="headerlink" href="#alternative-scaling-3" title="Permalink to this headline">¶</a></h4>
<p>Adding <a class="reference internal" href="#eq-scale-sir-s"><span class="std std-ref">(32)</span></a>-<a class="reference internal" href="#eq-scale-sir-r"><span class="std std-ref">(34)</span></a> shows that</p>
<div class="math">
\[\frac{dS}{dt}+\frac{dI}{dt}+\frac{dR}{dt}=0\quad\Rightarrow\quad
S+I+R=\hbox{const}=N,\]</div>
<p>where <span class="math">\(N\)</span> is the size of the population.
We can therefore scale <span class="math">\(S\)</span>, <span class="math">\(I\)</span>, and <span class="math">\(R\)</span> by the total
population <span class="math">\(N=S(0)+I(0)+R(0)\)</span>:</p>
<div class="math">
\[\bar S = \frac{S}{N},\quad \bar I = \frac{I}{N},\quad
\bar R = \frac{R}{N}{\thinspace .}\]</div>
<p>With the same time scale, one gets the system <a class="reference internal" href="#eq-scale-sir-s2"><span class="std std-ref">(35)</span></a>-<a class="reference internal" href="#eq-scale-sir-r2"><span class="std std-ref">(37)</span></a>, but with <span class="math">\(R_0\)</span> replaced by the dimensionless number:</p>
<div class="math" id="eq-auto8">
\[\tag{39}
\tilde R_0 = \frac{N\beta}{\nu}{\thinspace .}\]</div>
<p>The initial conditions become <span class="math">\(\bar S(0)=1-\alpha\)</span>, <span class="math">\(\bar I(0)=\alpha\)</span>,
and <span class="math">\(\bar R(0)=0\)</span>.</p>
<p>For the disease to spread at <span class="math">\(t=0\)</span>, we must have <span class="math">\(\tilde R_0 \bar S(0) &gt; 1\)</span>,
but <span class="math">\(\tilde R_0 \bar S(0) = N\beta/\nu \cdot S(0)/N = R_0\)</span>, so the
criterion is still <span class="math">\(R_0 &gt; 1\)</span>. Since <span class="math">\(R_0\)</span> is a more famous number than
<span class="math">\(\tilde R_0\)</span>, we can write the ODEs with <span class="math">\(R_0/S(0) = R_0/(1-\alpha)\)</span>
instead of <span class="math">\(\tilde R_0\)</span>.</p>
<p>Choosing <span class="math">\(t_c\)</span> to make the <span class="math">\(SI\)</span> terms balance the time derivatives,
<span class="math">\(t_c = (N\beta)^{-1}\)</span>, moves <span class="math">\(\tilde R_0\)</span> (or <span class="math">\(R_0\)</span> if we scale
<span class="math">\(S\)</span>, <span class="math">\(I\)</span>, and <span class="math">\(R\)</span> by <span class="math">\(S(0)\)</span>) to the <span class="math">\(I\)</span> terms:</p>
<div class="math">
\[\begin{split}\frac{d\bar S}{d\bar t} &amp;= - \bar S\bar I,
\\
\frac{d\bar I}{d\bar t} &amp;= \bar S\bar I - \tilde R_0^{-1} \bar I,
\\
\frac{d\bar R}{d\bar t} &amp;= \tilde R_0^{-1} I{\thinspace .}\end{split}\]</div>
</div>
</div>
<div class="section" id="sirv-model-with-finite-immunity">
<h3>SIRV model with finite immunity<a class="headerlink" href="#sirv-model-with-finite-immunity" title="Permalink to this headline">¶</a></h3>
<p>A common extension of the SIR model involves finite immunity: after
some period of time, recovered individuals lose their immunity
and become susceptibles again. This is modeled as
a leakage <span class="math">\(-\mu R\)</span> from the R to the S category, where <span class="math">\(\mu^{-1}\)</span>
is the average time it takes to lose immunity.
Vaccination is another extension: a fraction <span class="math">\(pS\)</span> is removed from the
S category by successful vaccination and brought to a new category V (the
vaccinated). The ODE model reads</p>
<div class="math" id="eq-scale-sirv-s">
\[\tag{40}
\frac{dS}{dt} = - \beta SI - pS + \mu R,\]</div>
<div class="math" id="eq-scale-sirv-i">
\[\tag{41}
\frac{dI}{dt} = \beta SI - \nu I,\]</div>
<div class="math" id="eq-scale-sirv-r">
\[\tag{42}
\frac{dR}{dt} = \nu I -\mu R,\]</div>
<div class="math" id="eq-scale-sirv-v">
\[\tag{43}
\frac{dV}{dt} = p S{\thinspace .}\]</div>
<p>Using <span class="math">\(t_c=1/\nu\)</span> and scaling the unknowns by <span class="math">\(S(0)\)</span>, we arrive at
the dimensionless model</p>
<div class="math" id="eq-scale-sirv-s2">
\[\tag{44}
\frac{d\bar S}{d\bar t} = - R_0 \bar S \bar I - \delta \bar S + \gamma \bar R,\]</div>
<div class="math" id="eq-scale-sirv-i2">
\[\tag{45}
\frac{d\bar I}{d\bar t} = R_0 \bar S \bar I - \bar I,\]</div>
<div class="math" id="eq-scale-sirv-r2">
\[\tag{46}
\frac{d\bar R}{d\bar t} = \bar I -\gamma \bar R,\]</div>
<div class="math" id="eq-scale-sirv-v2">
\[\tag{47}
\frac{d\bar V}{d\bar t} = \delta \bar S,\]</div>
<p>with two new dimensionless parameters:</p>
<div class="math">
\[\gamma = \frac{\mu}{\nu},\quad \delta = \frac{p}{\nu}{\thinspace .}\]</div>
<p>The quantity <span class="math">\(p^{-1}\)</span> can be interpreted as the average time it takes
to vaccinate a susceptible successfully. Writing <span class="math">\(\gamma = \nu^{-1}/\mu^{-1}\)</span>
and <span class="math">\(\delta = \nu^{-1}/p^{-1}\)</span> gives the interpretation that <span class="math">\(\gamma\)</span>
is the ratio of the average time to recover and the average time to
lose immunity, while <span class="math">\(\delta\)</span> is the ratio of the average time to recover
and the average time to successfully vaccinate a susceptible.</p>
<p>The plot in Figure <a class="reference internal" href="#sec-scale-sirv-fig"><span class="std std-ref">Spreading of a disease with loss of immunity (left) and added vaccination (right)</span></a> has <span class="math">\(\gamma = 0.05\)</span>, i.e.,
loss of immunity takes 20 weeks if it takes one week to recover from
the disease. The left plot corresponds to no vaccination, while the
right has <span class="math">\(\delta = 0.5\)</span> for a vaccination campaign that lasts from
day 7 to day 15. The value <span class="math">\(\delta =0.5\)</span> reflects that
it takes two weeks to successfully
vaccinate a susceptible, but the effect of vaccination is still dramatic.</p>
<div class="figure" id="id8">
<span id="sec-scale-sirv-fig"></span><a class="reference internal image-reference" href="_images/SIRV2.png"><img alt="_images/SIRV2.png" src="_images/SIRV2.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Spreading of a disease with loss of immunity (left) and added vaccination (right)</em></span></p>
</div>
</div>
<div class="section" id="michaelis-menten-kinetics-for-biochemical-reactions">
<span id="scale-mmk"></span><h3>Michaelis-Menten kinetics for biochemical reactions<a class="headerlink" href="#michaelis-menten-kinetics-for-biochemical-reactions" title="Permalink to this headline">¶</a></h3>
<p>A classical reaction model in biochemistry describes how a
substrate S is turned into a product P with aid of an enzyme E.
S and E react to form a complex ES in the first stage of the reaction.
In the second stage, ES is turned into E and P.
Introducing the amount of S, E, ES, and P by <span class="math">\([S]\)</span>, <span class="math">\([E]\)</span>, <span class="math">\([ES]\)</span>, and
<span class="math">\([P]\)</span>, the mathematical model can be written as</p>
<div class="math" id="eq-scale-mmk-es1">
\[\tag{48}
\frac{d[ES]}{dt} = k_+[E][S] - k_v[ES] - k_-[ES],\]</div>
<div class="math" id="eq-scale-mmk-p1">
\[\tag{49}
\frac{d[P]}{dt} = k_v[ES],\]</div>
<div class="math" id="eq-scale-mmk-s1">
\[\tag{50}
\frac{d[S]}{dt} = -k_+[E][S] + k_-[ES],\]</div>
<div class="math" id="eq-scale-mmk-e1">
\[\tag{51}
\frac{d[E]}{dt} = -k_+[E][S] + k_-[ES] + k_v[ES]{\thinspace .}\]</div>
<p>The initial conditions are <span class="math">\([ES](0)=[P](0)=0\)</span>, and <span class="math">\([S]=S_0\)</span>, <span class="math">\([E]=E_0\)</span>.
Three rate constants are involved: <span class="math">\(k_+\)</span>, <span class="math">\(k_-\)</span>, and <span class="math">\(k_v\)</span>.
The above mathematical model is known as <a class="reference external" href="https://en.wikipedia.org/wiki/Michaelis-Menten_kinetics">Michaelis-Menten kinetics</a>.</p>
<p>The amount of substance is measured in the unit <a class="reference external" href="https://en.wikipedia.org/wiki/Mole_(unit)">mole</a> (mol). From the equations we can see that
<span class="math">\(k_+\)</span> is measured in <span class="math">\(\hbox{s}^{-1}\hbox{mol}^{-1}\)</span>, while <span class="math">\(k_-\)</span> and
<span class="math">\(k_v\)</span> are measured in <span class="math">\(\hbox{s}^{-1}\)</span>. It is convenient to get rid of
the mole unit for the amount of a substance. When working with
dimensionless quantities, only ratios of the rate constants and not their
specific values are needed.</p>
<div class="section" id="classical-analysis">
<h4>Classical analysis<a class="headerlink" href="#classical-analysis" title="Permalink to this headline">¶</a></h4>
<p>A common assumption is that the formation of <span class="math">\([ES]\)</span> is very fast and that
it quickly reaches an equilibrium state, <span class="math">\([ES]^{\prime}=0\)</span>. Equation
<a class="reference internal" href="#eq-scale-mmk-es1"><span class="std std-ref">(48)</span></a> then reduces to the algebraic equation</p>
<div class="math">
\[k_+[E][S] - k_v[ES] - k_-[ES] = 0,\]</div>
<p>which leads to</p>
<div class="math" id="eq-scale-mmk-k">
\[\tag{52}
\frac{[E][S]}{[ES]} = \frac{k_- + k_v}{k_+} = K,\]</div>
<p>where <span class="math">\(K\)</span> is the famous Michaelis constant - the equilibrium constant
between <span class="math">\([E][S]\)</span> and <span class="math">\([ES]\)</span>.</p>
<p>Another important observation is that the ODE system implies
two conservation equations, arising from simply adding the ODEs:</p>
<div class="math" id="eq-auto9">
\[\tag{53}
\frac{d[ES]}{dt} + \frac{d[E]}{dt}  =0,\]</div>
<div class="math" id="eq-auto10">
\[\tag{54}
\frac{d[ES]}{dt} + \frac{d[S]}{dt} + \frac{d[P]}{dt} = 0,\]</div>
<p>from which it follows that</p>
<div class="math" id="eq-scale-mmk-cons1">
\[\tag{55}
[ES] + [E] = E_0,\]</div>
<div class="math" id="eq-scale-mmk-cons2">
\[\tag{56}
[ES] + [S] + [P] = S_0{\thinspace .}\]</div>
<p>We can use <a class="reference internal" href="#eq-scale-mmk-cons1"><span class="std std-ref">(55)</span></a> and <a class="reference internal" href="#eq-scale-mmk-k"><span class="std std-ref">(52)</span></a> to
express <span class="math">\([E]\)</span> by <span class="math">\([S]\)</span>:</p>
<div class="math">
\[[E] = E_0 - [ES] = E_0 - \frac{[E][S]}{K}\quad\Rightarrow\quad
[E] = \frac{KE_0}{K + [S]}{\thinspace .}\]</div>
<p>Now <a class="reference internal" href="#eq-scale-mmk-s1"><span class="std std-ref">(50)</span></a> can be developed to an equation involving
<span class="math">\([S]\)</span> only:</p>
<div class="math">
\[\frac{d[S]}{dt} = -k_+[E][S] + k_-[ES]\nonumber\]</div>
<div class="math">
\[= (-k_+ + \frac{k_-}{K})[E][S]\nonumber\]</div>
<div class="math">
\[= (-k_+ + \frac{k_-}{K})[S]\frac{KE_0}{K + [S]}\nonumber\]</div>
<div class="math" id="eq-scale-mmk-seq1">
\[\tag{57}
= - \frac{k_-E_0}{[S] + K}{\thinspace .}\]</div>
<p>We see that the parameter <span class="math">\(K\)</span> is central.</p>
<p>From above expression for <span class="math">\([E]\)</span> and <a class="reference internal" href="#eq-scale-mmk-cons1"><span class="std std-ref">(55)</span></a> it now follows</p>
<div class="math">
\[[E]=\frac{K E_0}{K+[S]},\quad [ES]=\frac{E_0[S]}{K+[S]}.\]</div>
<p>If <span class="math">\(K\)</span> is comparable to <span class="math">\(S_0\)</span> these indicate</p>
<div class="math">
\[[E]\sim E_0,\quad [ES]\sim \frac{E_0 S_0}{K},\]</div>
<p>as is used for scaling <span class="math">\([E]\)</span> and <span class="math">\(Q_c\)</span>, subsequently.
Provided we exclude the case <span class="math">\([S]\gg K\)</span>, we may infer that <span class="math">\([E]\)</span> will be of magnitude <span class="math">\(E_0\)</span>, while <span class="math">\([ES]\)</span> will be of magnitude <span class="math">\(E_0 S_0/K\)</span>.</p>
</div>
<div class="section" id="dimensionless-ode-system">
<h4>Dimensionless ODE system<a class="headerlink" href="#dimensionless-ode-system" title="Permalink to this headline">¶</a></h4>
<p>Let us reason how to make the original ODE system
<a class="reference internal" href="#eq-scale-mmk-es1"><span class="std std-ref">(48)</span></a>-<a class="reference internal" href="#eq-scale-mmk-e1"><span class="std std-ref">(51)</span></a> dimensionless.
Aiming at <span class="math">\([S]\)</span> and <span class="math">\([E]\)</span> of unit size, two obvious dimensionless
unknowns are</p>
<div class="math">
\[\bar S = \frac{[S]}{S_0},\quad
\bar E = \frac{[E]}{E_0}{\thinspace .}\]</div>
<p>For the other two unknowns we just introduce scales to be determined
later:</p>
<div class="math">
\[\bar P = \frac{[P]}{P_c},\quad
\bar{Q} = \frac{[ES]}{Q_c}{\thinspace .}\]</div>
<p>With <span class="math">\(\bar t = t/t_c\)</span> the equations become</p>
<div class="math">
\[\begin{split}\frac{d\bar Q}{d\bar t} &amp;= t_ck_+\frac{E_0S_0}{Q_c}\bar E\bar S
- t_c(k_v + k_-)\bar Q,\\
\frac{d\bar P}{d\bar t} &amp;= t_ck_v\frac{Q_c}{P_c}\bar Q,\\
\frac{d\bar S}{d\bar t} &amp;= -t_ck_+E_0\bar E\bar S
+ t_ck_-\frac{Q_c}{S_0}\bar Q,\\
\frac{d\bar E}{d\bar t} &amp;= -t_ck_+S_0\bar E\bar S
+ t_c(k_- + k_v)\frac{Q_c}{E_0}\bar Q{\thinspace .}\end{split}\]</div>
</div>
<div class="section" id="determining-scales">
<h4>Determining scales<a class="headerlink" href="#determining-scales" title="Permalink to this headline">¶</a></h4>
<p>Choosing the scales is actually a quite complicated matter that requires
extensive analysis of the equations to determine the characteristics of
the solutions. Much literature is written about this, but here we shall
take a simplistic and pragmatic approach.
Besides the Michaelis constant <span class="math">\(K\)</span>, there is another important parameter,</p>
<div class="math">
\[\epsilon = \frac{E_0}{S_0},\]</div>
<p>because most applications will involve a small <span class="math">\(\epsilon\)</span>.
We shall have <span class="math">\(K\)</span> and <span class="math">\(\epsilon\)</span> in mind while choosing scales such that
these symbols appear naturally in the scaled equations.</p>
<p>Looking at the equations, we see that the <span class="math">\(K\)</span> parameter will appear
if <span class="math">\(t_c\sim 1/k_+\)</span>. However, <span class="math">\(1/k_+\)</span> does not have the dimension
<span class="math">\(\hbox{[T]}^{-1}\)</span> as required, so we need to add a factor with dimension
mol. A natural choice is
<span class="math">\(t_c^{-1}=k_+S_0\)</span> or <span class="math">\(t_c^{-1}=k_+E_0\)</span>. Since often <span class="math">\(S_0\gg E_0\)</span>,
the former <span class="math">\(t_c\)</span> is a short time scale and the latter is a long
time scale. If the interest is in the long time scale, we set</p>
<div class="math">
\[t_c = \frac{1}{k_+E_0}{\thinspace .}\]</div>
<p>The equations then take the form</p>
<div class="math">
\[\begin{split}\frac{d\bar Q}{d\bar t} &amp;= \frac{S_0}{Q_c}\bar E\bar S
- KE_0^{-1}\bar Q,\\
\frac{d\bar P}{d\bar t} &amp;= \frac{k_v}{k_+ E_0}\frac{Q_c}{P_c}\bar Q,\\
\frac{d\bar S}{d\bar t} &amp;= -\bar E\bar S
+ \frac{k_-}{k_+E_0}\frac{Q_c}{S_0}\bar Q,\\
\frac{d\bar E}{d\bar t} &amp;= -\epsilon^{-1}\bar E\bar S
+ K\frac{Q_c}{E_0^2}\bar Q{\thinspace .}\end{split}\]</div>
<p>The <span class="math">\([ES]\)</span> variable starts and ends at zero, and its maximum value
can be roughly estimated from the equation for <span class="math">\([ES]^\prime\)</span>
by setting <span class="math">\([ES]^\prime = 0\)</span>, which gives</p>
<div class="math">
\[[ES] = \frac{[E][S]}{K}\sim \frac{E_0S_0}{K},\]</div>
<p>where we have replaced <span class="math">\([E][S]\)</span> by <span class="math">\(E_0S_0\)</span> as an identification
of magnitude. This magnitude of <span class="math">\([ES]\)</span>
at its maximum can be used as the characteristic size <span class="math">\(Q_c\)</span>:</p>
<div class="math">
\[Q_c = \frac{E_0S_0}{K}{\thinspace .}\]</div>
<p>The equation for <span class="math">\(\bar P\)</span> simplifies if we choose <span class="math">\(P_c=Q_c\)</span>.
With these assumptions one gets</p>
<div class="math">
\[\begin{split}\frac{d\bar Q}{d\bar t} &amp;= KE_0^{-1} (\bar E\bar S
- \bar Q),\\
\frac{d\bar P}{d\bar t} &amp;= \frac{k_v}{k_+ E_0}\bar Q,\\
\frac{d\bar S}{d\bar t} &amp;= -\bar E\bar S
+ \frac{k_-}{k_+E_0}\frac{E_0}{K}\bar Q,\\
\frac{d\bar E}{d\bar t} &amp;= -\epsilon^{-1}\bar E\bar S
+ \epsilon^{-1}\bar Q{\thinspace .}\end{split}\]</div>
<p>We can now identify the dimensionless numbers</p>
<div class="math">
\[\alpha = \frac{K}{E_0},\quad \beta = \frac{k_v}{k_+ E_0},
\quad \gamma = \frac{k_-}{k_+E_0},\]</div>
<p>where we see that <span class="math">\(\alpha = \beta + \gamma\)</span>, so <span class="math">\(\gamma\)</span> can be eliminated.
Moreover,</p>
<div class="math">
\[\alpha = \frac{k_-}{k_+E_0} + \beta,\]</div>
<p>implying that <span class="math">\(\alpha &gt; \beta\)</span>.</p>
<p>We arrive at the final set of scaled differential equations:</p>
<div class="math" id="eq-scale-mmk-q2">
\[\tag{58}
\frac{d\bar Q}{d\bar t} = \alpha (\bar E\bar S
    - \bar Q),\]</div>
<div class="math" id="eq-scale-mmk-p2">
\[\tag{59}
\frac{d\bar P}{d\bar t} = \beta\bar Q,\]</div>
<div class="math" id="eq-scale-mmk-s2">
\[\tag{60}
\frac{d\bar S}{d\bar t} = -\bar E\bar S
    + (1 - \beta\alpha^{-1})\bar Q,\]</div>
<div class="math" id="eq-scale-mmk-e2">
\[\tag{61}
\epsilon\frac{d\bar E}{d\bar t} = -\bar E\bar S + \bar Q{\thinspace .}\]</div>
<p>The initial conditions are <span class="math">\(\bar S=\bar E =1\)</span> and <span class="math">\(\bar Q=\bar P=0\)</span>.</p>
<p>The five initial parameters (<span class="math">\(S_0\)</span>, <span class="math">\(E_0\)</span>, <span class="math">\(k_+\)</span>, <span class="math">\(k_-\)</span>, and <span class="math">\(k_v\)</span>)
are reduced to three dimensionless constants:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(\alpha\)</span> is the dimensionless Michaelis constant, reflecting the
ratio of the production of P and E (<span class="math">\(k_v+k_-\)</span>) versus the production of
the complex (<span class="math">\(k_+\)</span>), made dimensionless by <span class="math">\(E_0\)</span>,</li>
<li><span class="math">\(\epsilon\)</span> is the initial fraction of enzyme relative to the substrate,</li>
<li><span class="math">\(\beta\)</span> measures the relative importance of production of P (<span class="math">\(k_v\)</span>)
versus production of the complex (<span class="math">\(k_+\)</span>), made dimensionless by <span class="math">\(E_0\)</span>.</li>
</ul>
</div></blockquote>
<p>Observe that software developed for
solving <a class="reference internal" href="#eq-scale-mmk-es1"><span class="std std-ref">(48)</span></a>-<a class="reference internal" href="#eq-scale-mmk-e1"><span class="std std-ref">(51)</span></a> cannot be reused
for solving <a class="reference internal" href="#eq-scale-mmk-q2"><span class="std std-ref">(58)</span></a>-<a class="reference internal" href="#eq-scale-mmk-e2"><span class="std std-ref">(61)</span></a> since the latter
system has a slightly different structure.</p>
</div>
<div class="section" id="conservation-equations">
<h4>Conservation equations<a class="headerlink" href="#conservation-equations" title="Permalink to this headline">¶</a></h4>
<p>The counterpart to the conservation equations
<a class="reference internal" href="#eq-scale-mmk-cons1"><span class="std std-ref">(55)</span></a>-<a class="reference internal" href="#eq-scale-mmk-cons2"><span class="std std-ref">(56)</span></a> is obtained by
adding <a class="reference internal" href="#eq-scale-mmk-q2"><span class="std std-ref">(58)</span></a> and <span class="math">\(\alpha\)</span> times <a class="reference internal" href="#eq-scale-mmk-e2"><span class="std std-ref">(61)</span></a>,
and adding <a class="reference internal" href="#eq-scale-mmk-q2"><span class="std std-ref">(58)</span></a>, <a class="reference internal" href="#eq-scale-mmk-p2"><span class="std std-ref">(59)</span></a>, and
<span class="math">\(\alpha\)</span> times <a class="reference internal" href="#eq-scale-mmk-s2"><span class="std std-ref">(60)</span></a>:</p>
<div class="math" id="eq-auto11">
\[\tag{62}
\epsilon^{-1}\alpha^{-1}\bar Q + \bar E = 1,\]</div>
<div class="math" id="eq-auto12">
\[\tag{63}
\alpha\bar S + \bar Q + \bar P = \alpha{\thinspace .}\]</div>
<p>The scaled quantities, as well as the original concentrations, must be
positive variables, and <span class="math">\(\bar E\in [0,1]\)</span>, <span class="math">\(\bar S\in [0,1]\)</span>. Such checks
along with the conserved quantities above should be performed at every
time step in a simulation.</p>
</div>
<div class="section" id="analysis-of-the-scaled-system">
<h4>Analysis of the scaled system<a class="headerlink" href="#analysis-of-the-scaled-system" title="Permalink to this headline">¶</a></h4>
<p>In the scaled system, we may assume <span class="math">\(\epsilon\)</span> small, which from
<a class="reference internal" href="#eq-scale-mmk-e2"><span class="std std-ref">(61)</span></a> gives rise to the simplification
<span class="math">\(\epsilon\bar E^{\prime}=0\)</span>, and thereby the relation <span class="math">\(\bar Q = \bar E\bar S\)</span>.
The conservation equation <span class="math">\([ES] + [E]= E_0\)</span> reads <span class="math">\(Q_c\bar Q + E_0\bar E =
E_0\)</span> such that <span class="math">\(\bar E = 1 - Q_c\bar Q/E_0=1- \bar Q S_0/K = 1 - \epsilon^{-1}\alpha^{-1}\bar Q\)</span>. The relation <span class="math">\(\bar Q=\bar E\bar S\)</span> then becomes</p>
<div class="math">
\[\bar Q = (1 - \epsilon^{-1}\alpha^{-1}\bar Q)\bar S,\]</div>
<p>which can be solved for <span class="math">\(\bar Q\)</span>:</p>
<div class="math">
\[\bar Q = \frac{\bar S}{1 + \epsilon^{-1}\alpha^{-1}\bar S}{\thinspace .}\]</div>
<p>The equation <a class="reference internal" href="#eq-scale-mmk-s2"><span class="std std-ref">(60)</span></a> for <span class="math">\(\bar S\)</span> becomes</p>
<div class="math" id="eq-scale-mmk-seq2">
\[\tag{64}
\frac{d\bar S}{d\bar t} = -\beta\alpha^{-1}\bar Q =
    -\frac{\beta\bar S}{\alpha + \epsilon^{-1}\bar S}{\thinspace .}\]</div>
<p>This is a more precise analysis than the one leading to
<a class="reference internal" href="#eq-scale-mmk-seq1"><span class="std std-ref">(57)</span></a> since we now realize that the
mathematical assumption for the simplification is
<span class="math">\(\epsilon\rightarrow 0\)</span>.</p>
<p>Is <a class="reference internal" href="#eq-scale-mmk-seq2"><span class="std std-ref">(64)</span></a> consistent with <a class="reference internal" href="#eq-scale-mmk-seq1"><span class="std std-ref">(57)</span></a>? It is
easy to make algebraic mistakes when deriving scaled equations,
so it is always wise to carry out consistency checks.
Introducing dimensions in <a class="reference internal" href="#eq-scale-mmk-seq2"><span class="std std-ref">(64)</span></a> leads to</p>
<div class="math">
\[\frac{t_c}{S_0}\frac{d S}{dt} =
\frac{d\bar S}{d\bar t}  =
-\frac{\beta\bar S}{\alpha + \epsilon^{-1}\bar S}
= -\frac{k_v}{k_+E_0}\frac{S}{KE_0^{-1} + E_0^{-1}S_0\bar S}
= -\frac{k_v}{k_+}\frac{\bar S}{K + S},\]</div>
<p>and hence with <span class="math">\(t_c^{-1}=k_+E_0\)</span>,</p>
<div class="math">
\[\frac{dS}{dt} = -\frac{k_vE_0 S}{K + S},\]</div>
<p>which is <a class="reference internal" href="#eq-scale-mmk-seq1"><span class="std std-ref">(57)</span></a>.</p>
<p>Figure <a class="reference internal" href="#scale-mmk-fig"><span class="std std-ref">Simulation of a biochemical process</span></a> shows the impact of <span class="math">\(\epsilon\)</span>: with a moderately small
value (0.1) we see that <span class="math">\(\bar Q\approx 0\)</span>, which justifies the
simplifications performed above. We also observe that all the unknowns
vary between 0 and about 1, indicating that the scaling is successful
for the chosen dimensionless numbers. The simulations made use of
a time step <span class="math">\(\Delta\bar t=0.01\)</span> with a 4th-order Runge-Kutta method,
using <span class="math">\(\alpha=1.5\)</span>, <span class="math">\(\beta=1\)</span> (relevant code is in the
<code class="docutils literal"><span class="pre">simulate_biochemical_process</span></code> function in <a class="reference external" href="http://tinyurl.com/o8pb3yy/session.py">session.py</a>).</p>
<div class="figure" id="id9">
<span id="scale-mmk-fig"></span><a class="reference internal image-reference" href="_images/biochem.png"><img alt="_images/biochem.png" src="_images/biochem.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-text"><em>Simulation of a biochemical process</em></span></p>
</div>
<p>However, it is of interest to investigate the limit <span class="math">\(\epsilon\rightarrow 0\)</span>.
Initially, the equation for <span class="math">\(d\bar E/d\bar t\)</span> reads
<span class="math">\(d\bar E/d\bar t = -\epsilon^{-1}\)</span>, which implies a very fast reduction of
<span class="math">\(\bar E\)</span>. Using <span class="math">\(\epsilon=0.005\)</span> and <span class="math">\(\Delta\bar t = 10^{-3}\)</span>, simulation
results show that <span class="math">\(\bar E\)</span> decays to approximately zero at <span class="math">\(t=0.03\)</span> while
<span class="math">\(\bar S\approx 1\)</span> and <span class="math">\(\bar Q \approx \bar P\approx 0\)</span>.
This is reasonable since with
very little enzyme in comparison with the substrate (<span class="math">\(\epsilon\rightarrow 0\)</span>)
very little will happen.</p>
</div>
</div>
</div>
<div class="section" id="vibration-problems">
<span id="sec-scale-vib"></span><h2>Vibration problems<a class="headerlink" href="#vibration-problems" title="Permalink to this headline">¶</a></h2>
<p>We shall in this section
address a range of different second-order ODEs for mechanical
vibrations and demonstrate how to reason about the scaling in
different physical scenarios.</p>
<div class="section" id="undamped-vibrations-without-forcing">
<span id="sec-scale-vib-undamped"></span><h3>Undamped vibrations without forcing<a class="headerlink" href="#undamped-vibrations-without-forcing" title="Permalink to this headline">¶</a></h3>
<p>The simplest differential equation model for mechanical vibrations
reads</p>
<div class="math" id="eq-sec-scale-vib-undamped-model">
\[\tag{65}
mu'' + ku = 0,\quad u(0)=I,\ u'(0)=V,\]</div>
<p>where unknown <span class="math">\(u(t)\)</span> measures the displacement of the body,
This is a common model for a vibrating body  with mass <span class="math">\(m\)</span> attached
to a linear spring with spring constant <span class="math">\(k\)</span> (and force <span class="math">\(-ku\)</span>).
Figure <a class="reference internal" href="#sec-scale-vib-undamped-sketch"><span class="std std-ref">Oscillating body attached to a spring</span></a> shows a typical mechanical
sketch of such a system: some mass can move horizontally without friction
and is connected to a spring that exerts a force <span class="math">\(-ku\)</span> on the body.</p>
<div class="figure" id="id10">
<span id="sec-scale-vib-undamped-sketch"></span><a class="reference internal image-reference" href="_images/oscillator_spring.png"><img alt="_images/oscillator_spring.png" src="_images/oscillator_spring.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Oscillating body attached to a spring</em></span></p>
</div>
<div class="section" id="the-first-technical-steps-of-scaling">
<h4>The first technical steps of scaling<a class="headerlink" href="#the-first-technical-steps-of-scaling" title="Permalink to this headline">¶</a></h4>
<p>The problem <a class="reference internal" href="#eq-sec-scale-vib-undamped-model"><span class="std std-ref">(65)</span></a> has one independent
variable <span class="math">\(t\)</span> and one dependent variable <span class="math">\(u\)</span>. We introduce dimensionless
versions of these variables:</p>
<div class="math">
\[\bar u =\frac{u}{u_c},\quad\bar t = \frac{t}{t_c},\]</div>
<p>where <span class="math">\(u_c\)</span> and <span class="math">\(t_c\)</span> are characteristic values of <span class="math">\(u\)</span> and <span class="math">\(t\)</span>.
Inserted in <a class="reference internal" href="#eq-sec-scale-vib-undamped-model"><span class="std std-ref">(65)</span></a>, we get</p>
<div class="math">
\[m\frac{u_c}{t_c^2}\frac{d^2\bar u}{d\bar t^2} + ku_c\bar u = 0,
\quad u_c\bar u(0)=I,\quad \frac{u_c}{t_c}\frac{d\bar u}{d\bar t}(0)=V,\]</div>
<p>resulting in</p>
<div class="math" id="eq-sec-scale-vib-undamped-model-scaled0">
\[\tag{66}
\frac{d^2\bar u}{d\bar t^2} + \frac{t_c^2 k}{m}\bar u = 0,
    \quad \bar u(0)=\frac{I}{u_c},\ \bar u'(0)=\frac{Vt_c}{u_c}{\thinspace .}\]</div>
<p>What is an appropriate displacement scale <span class="math">\(u_c\)</span>? The initial condition
<span class="math">\(u(0)=I\)</span> is a candidate, i.e., <span class="math">\(u_c=I\)</span>. But how to choose the time scale?
Making the coefficient in front of the <span class="math">\(\bar u\)</span> unity, such that
both terms balance and are of size unity, is a candidate.</p>
</div>
<div class="section" id="the-exact-solution-1">
<h4>The exact solution<a class="headerlink" href="#the-exact-solution-1" title="Permalink to this headline">¶</a></h4>
<p>To better see what the proper scales of <span class="math">\(u\)</span> and <span class="math">\(t\)</span> are, we can look
into the analytical solution of this problem.
Although the exact solution of
<a class="reference internal" href="#eq-sec-scale-vib-undamped-model"><span class="std std-ref">(65)</span></a> is quite straightforward to calculate
by hand, we take the opportunity to make use of SymPy to
find <span class="math">\(u(t)\)</span>. The use of SymPy can later be generalized to vibration
ODEs that are harder to solve by hand.</p>
<p>SymPy requires all mathematical symbols to be explicitly created:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;I V C1 C2&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>To specify the ODE to be solved, we can make a Python function returning
all the terms in the ODE:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Define differential equation: u&#39;&#39; + w**2*u = 0</span>
<span class="k">def</span> <span class="nf">ode</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span>

<span class="n">diffeq</span> <span class="o">=</span> <span class="n">ode</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">diffeq</span></code> variable, defining the ODE, can be passed to the SymPy
function <code class="docutils literal"><span class="pre">dsolve</span></code> to find the symbolic solution of the ODE:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">diffeq</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="c1"># s is an u(t) == expression (Eq obj.), s.rhs grabs the expression</span>
<span class="n">u_sol</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">rhs</span>
<span class="k">print</span> <span class="n">u_sol</span>
</pre></div>
</div>
<p>The solution that gets printed is <code class="docutils literal"><span class="pre">C1*sin(t*w)</span> <span class="pre">+</span> <span class="pre">C2*cos(t*w)</span></code>, indicating
that there are two integration constants <code class="docutils literal"><span class="pre">C1</span></code> and <code class="docutils literal"><span class="pre">C2</span></code> to be determined
by the initial conditions. The result of applying these conditions is
a <span class="math">\(2\times 2\)</span> linear system of algebraic equations that SymPy can solve
by the <code class="docutils literal"><span class="pre">solve</span></code> function. The code goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># The solution u_sol contains integration constants C1 and C2</span>
<span class="c1"># but these are not symbols, substitute them by symbols</span>
<span class="n">u_sol</span> <span class="o">=</span> <span class="n">u_sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="n">C1</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="n">C2</span><span class="p">)</span>

<span class="c1"># Determine C1 and C2 from the initial conditions</span>
<span class="n">ic</span> <span class="o">=</span> <span class="p">[</span><span class="n">u_sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span> <span class="n">u_sol</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">V</span><span class="p">]</span>
<span class="k">print</span> <span class="n">ic</span>   <span class="c1"># 2x2 algebraic system for C1 and C2</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">ic</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">])</span>
<span class="c1"># s is now a dictionary: {C2: I, C1: V/w}</span>
<span class="c1"># substitute solution back in u_sol</span>
<span class="n">u_sol</span> <span class="o">=</span> <span class="n">u_sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">C1</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C2</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">C2</span><span class="p">])</span>
<span class="k">print</span> <span class="n">u_sol</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">u_sol</span></code> variable is now <code class="docutils literal"><span class="pre">I*cos(t*w)</span> <span class="pre">+</span> <span class="pre">V*sin(t*w)/w</span></code>.
Since symbolic software is far from bug-free and can give wrong results,
we should always check the answer. Here, we insert the solution in the ODE
to see if the result is zero, and we insert the solution in the initial
conditions to see that these are fulfilled:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Check that the solution fulfills the ODE and init.cond.</span>
<span class="k">print</span> <span class="n">simplify</span><span class="p">(</span><span class="n">ode</span><span class="p">(</span><span class="n">u_sol</span><span class="p">)),</span>
<span class="k">print</span> <span class="n">u_sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span> <span class="n">diff</span><span class="p">(</span><span class="n">u_sol</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">V</span>
</pre></div>
</div>
<p>There will be many more examples on using SymPy to find exact solutions
of differential equation problems.</p>
<p>The solution of the ODE in mathematical notation is</p>
<div class="math">
\[u(t) = I\cos(\omega t) + \frac{V}{\omega}\sin(\omega t),\quad \omega = \sqrt{\frac{k}{m}}{\thinspace .}\]</div>
<p>More insight arises from rewriting such an expression in the form
<span class="math">\(A\cos(wt - \phi)\)</span>:</p>
<div class="math">
\[u(t) = \sqrt{I^2 + \frac{V^2}{\omega^2}}\cos(wt - \phi),\quad
\phi = \tan^{-1}(V/(\omega I)){\thinspace .}\]</div>
<p>Now we see that the <span class="math">\(u\)</span> corresponds to cosine oscillations with a
frequency shift <span class="math">\(\phi\)</span> and amplitude <span class="math">\(\sqrt{I^2 + (V/\omega)^2}\)</span>.</p>
<p>The forthcoming text relies on a good understanding of concepts
like period, frequency, and amplitude of oscillating signals, so
readers who need to refresh these concepts are recommended to
do <a class="reference internal" href="#scale-exer-sine"><span class="std std-ref">Problem 2.12: Find the period of sinusoidal signals</span></a> before continuing.</p>
</div>
<div class="section" id="discussion-of-the-displacement-scale">
<h4>Discussion of the displacement scale<a class="headerlink" href="#discussion-of-the-displacement-scale" title="Permalink to this headline">¶</a></h4>
<p>The amplitude of <span class="math">\(u\)</span> is <span class="math">\(\sqrt{I^2 + V^2/\omega^2}\)</span>, and this
expression is obviously a candidate for <span class="math">\(u_c\)</span>.  However, the simpler
choice <span class="math">\(u_c=\max (I, V/\omega)\)</span> is also relevant and more attractive
than the square root expression (but potentially a factor 1.4 wrong
compared to the exact amplitude).  It is not very important to have
<span class="math">\(|u|\leq 1\)</span>, the point is to avoid <span class="math">\(|u|\)</span> very small or large.</p>
</div>
<div class="section" id="discussion-of-the-time-scale-2">
<h4>Discussion of the time scale<a class="headerlink" href="#discussion-of-the-time-scale-2" title="Permalink to this headline">¶</a></h4>
<p>What is an appropriate time scale? Looking at
<a class="reference internal" href="#eq-sec-scale-vib-undamped-model-scaled0"><span class="std std-ref">(66)</span></a> and arguing that
<span class="math">\(\bar u''\)</span> and <span class="math">\(\bar u\)</span> both should be around unity in size, the
coefficient <span class="math">\(t_c^2k/m\)</span> must equal unity, implying that <span class="math">\(t_c=\sqrt{m/k}\)</span>.
Also from the analytical solution we see that the solution goes like the
sine or cosine of <span class="math">\(\omega t\)</span>, so <span class="math">\(1/\omega = \sqrt{m/k}\)</span> can be a characteristic
time scale. Likewise, one period of the oscillations, <span class="math">\(P=2\pi/\omega\)</span>, can
be the characteristic time, leading to <span class="math">\(t_c=2\pi/\omega\)</span>.</p>
</div>
<div class="section" id="the-dimensionless-solution">
<h4>The dimensionless solution<a class="headerlink" href="#the-dimensionless-solution" title="Permalink to this headline">¶</a></h4>
<p>With <span class="math">\(u_c=I\)</span> and <span class="math">\(t_c=\sqrt{m/k}\)</span> we get the scaled model</p>
<div class="math" id="eq-sec-scale-vib-undamped-model-scaled1">
\[\tag{67}
\frac{d^2\bar u}{d\bar t^2} + \bar u = 0,
    \quad \bar u(0)=1,\ \bar u'(0)=\alpha,\]</div>
<p>where <span class="math">\(\alpha\)</span> is a dimensionless parameter:</p>
<div class="math">
\[\alpha = \frac{V}{I}\sqrt{\frac{m}{k}}{\thinspace .}\]</div>
<p>Note that in case <span class="math">\(V=0\)</span>, we have &#8220;scaled away&#8221; all physical parameters.
The universal solution without physical parameters is then
<span class="math">\(\bar u(\bar t)=\cos\bar t\)</span>.</p>
<p>The unscaled solution is recovered as</p>
<div class="math" id="eq-auto13">
\[\tag{68}
u(t) = I\bar u(\sqrt{k/m}\bar t){\thinspace .}\]</div>
<p>This expressions shows that the scaling is simply a matter of
<em>stretching or shrinking the axes</em>.</p>
</div>
<div class="section" id="alternative-displacement-scale">
<h4>Alternative displacement scale<a class="headerlink" href="#alternative-displacement-scale" title="Permalink to this headline">¶</a></h4>
<p>Using <span class="math">\(u_c = V/\omega\)</span>, the equation
is not changed, but the initial conditions become</p>
<div class="math">
\[\bar u(0) = \frac{I}{u_c} = \frac{I\omega}{V} =\frac{I}{V}\sqrt{\frac{k}{m}} = \alpha^{-1},\quad \bar u'(0)=1{\thinspace .}\]</div>
<p>With <span class="math">\(u_c=V/\omega\)</span> and one period as time scale,
<span class="math">\(t_c=2\pi\sqrt{m/k}\)</span>,
we get the alternative model</p>
<div class="math" id="eq-sec-scale-vib-undamped-model-scaled2">
\[\tag{69}
\frac{d^2\bar u}{d\bar t^2} + 4\pi^2 \bar u = 0,
    \quad \bar u(0)=\alpha^{-1},\ \bar u'(0)=2\pi{\thinspace .}\]</div>
<p>The unscaled solution is in this case recovered by</p>
<div class="math" id="eq-auto14">
\[\tag{70}
u(t) = V\sqrt{\frac{m}{k}}\bar u(2\pi\sqrt{k/m}\bar t){\thinspace .}\]</div>
<span class="target" id="index-15"></span><span class="target" id="index-16"></span><span class="target" id="index-17"></span><span class="target" id="index-18"></span></div>
<div class="section" id="about-frequency-and-dimensions">
<span id="index-19"></span><h4>About frequency and dimensions<a class="headerlink" href="#about-frequency-and-dimensions" title="Permalink to this headline">¶</a></h4>
<p>The solution goes like <span class="math">\(\cos\omega t\)</span>, where <span class="math">\(\omega =\sqrt{m/k}\)</span>
must have dimension 1/s. Actually, <span class="math">\(\omega\)</span> has dimension <em>radians
per second</em>: rad/s. A radian is dimensionless since it is arc (length)
divided by radius (length), but still regarded as a unit.
The period <span class="math">\(P\)</span> of vibrations is a more intuitive quantity than the frequency
<span class="math">\(\omega\)</span>. The relation between <span class="math">\(P\)</span> and <span class="math">\(\omega\)</span> is <span class="math">\(P=2\pi/\omega\)</span>.
The number of oscillation cycles per period, <span class="math">\(f\)</span>, is a more intuitive
measurement of frequency and also known as <em>frequency</em>. Therefore, to be
precise, <span class="math">\(\omega\)</span> should be named <em>angular frequency</em>. The relation between
<span class="math">\(f\)</span> and <span class="math">\(T\)</span> is <span class="math">\(f=1/T\)</span>, so <span class="math">\(f=2\pi\omega\)</span> and measured in Hz (1/s), which is
the unit for counts per unit time.</p>
</div>
</div>
<div class="section" id="undamped-vibrations-with-constant-forcing">
<span id="sec-scale-vib-undamped-mg"></span><h3>Undamped vibrations with constant forcing<a class="headerlink" href="#undamped-vibrations-with-constant-forcing" title="Permalink to this headline">¶</a></h3>
<p>For vertical vibrations in the gravity field, the model
<a class="reference internal" href="#eq-sec-scale-vib-undamped-model"><span class="std std-ref">(65)</span></a> must also take the gravity force
<span class="math">\(-mg\)</span> into account:</p>
<div class="math">
\[mu'' + ku = -mg{\thinspace .}\]</div>
<p>How does the new term <span class="math">\(-mg\)</span> influence
the scaling? We observe that if there is no movement of the body,
<span class="math">\(u''=0\)</span>, and the spring elongation matches the gravity force:
<span class="math">\(ku = -mg\)</span>, leading to a steady displacement <span class="math">\(u=-mg/k\)</span>. We can then
have oscillations around this equilibrium point. A natural scaling
for <span class="math">\(u\)</span> is therefore</p>
<div class="math">
\[\bar u = \frac{u - (-mg/k)}{u_c}=\frac{uk + mg}{ku_c}{\thinspace .}\]</div>
<p>The scaled differential equation with the same time scale as before
reads</p>
<div class="math">
\[\frac{d^2\bar u}{d\bar t^2} + \bar u - \frac{t_c^2}{u_c}g
= -\frac{t_c^2}{u_c}g,\]</div>
<p>leading to</p>
<div class="math">
\[\frac{d^2\bar u}{d\bar t^2} + \bar u = 0{\thinspace .}\]</div>
<p>The initial conditions <span class="math">\(u(0)=I\)</span> and <span class="math">\(u'(0)=V\)</span> become, with <span class="math">\(u_c=I\)</span>,</p>
<div class="math">
\[\bar u(0) = 1 + \frac{mg}{kI},\quad \frac{d\bar u}{d\bar t}(0)=\sqrt{\frac{m}{k}}\frac{V}{I}{\thinspace .}\]</div>
<p>We see that the oscillations around the equilibrium point in the
gravity field are identical to the horizontal oscillations without
gravity, except for an offset <span class="math">\(mg/(kI)\)</span> in the displacement.</p>
</div>
<div class="section" id="undamped-vibrations-with-time-dependent-forcing">
<span id="sec-scale-vib-undamped-f"></span><h3>Undamped vibrations with time-dependent forcing<a class="headerlink" href="#undamped-vibrations-with-time-dependent-forcing" title="Permalink to this headline">¶</a></h3>
<p>Now we add a transient forcing term <span class="math">\(F(t)\)</span> to the model
<a class="reference internal" href="#eq-sec-scale-vib-undamped-model"><span class="std std-ref">(65)</span></a>:</p>
<div class="math" id="eq-sec-scale-vib-undamped-f-model">
\[\tag{71}
mu'' + ku = F(t),\quad u(0)=I,\ u'(0)=V{\thinspace .}\]</div>
<p>Take the forcing to be oscillating:</p>
<div class="math">
\[F(t) = A\cos(\psi t){\thinspace .}\]</div>
<p>The technical steps of the scaling are still the same, with the
intermediate result</p>
<div class="math" id="eq-sec-scale-vib-undamped-f-model-scaled0">
\[\tag{72}
\frac{d^2\bar u}{d\bar t^2} + \frac{t_c^2 k}{m}\bar u =
    \frac{t_c^2}{mu_c}A\cos(\psi t_c\bar t),
    \quad \bar u(0)=\frac{I}{u_c},\ \bar u'(0)=\frac{Vt_c}{u_c}{\thinspace .}\]</div>
<p>What are typical displacement and time scales? This is not so obvious
without knowing the details of the solution, because there are
three parameters (<span class="math">\(I\)</span>, <span class="math">\(V\)</span>, and <span class="math">\(A\)</span>) that influence the magnitude of <span class="math">\(u\)</span>.
Moreover, there are two time scales, one for the free vibrations of
the systems and one for the forced vibrations <span class="math">\(F(t)\)</span>.</p>
<div class="section" id="investigating-scales-via-analytical-solutions">
<h4>Investigating scales via analytical solutions<a class="headerlink" href="#investigating-scales-via-analytical-solutions" title="Permalink to this headline">¶</a></h4>
<p>As we have seen already several times, having access to
an exact solution is very fortunate as it allows us to directly
examine the scales. Also in the present problem it is possible
to derive an exact solution. We
continue the SymPy session from the previous section and perform much
of the same steps. Note that we use <code class="docutils literal"><span class="pre">w</span></code> for <span class="math">\(\omega = \sqrt{k/m}\)</span>
in the computer code (to obtain a more direct visual counterpart to
<span class="math">\(\omega\)</span>).
SymPy may get confused when coefficients in differential equations
contain several symbols. We therefore rewrite the equation with
at most one symbol in each coefficient (i.e., symbolic software is
in general
more successful when applied to scaled differential equations than the
unscaled counterparts, but right now our task is to solve the unscaled version).
The amplitude <span class="math">\(A/m\)</span> in the forcing term is of this reason
replaced by the symbol <code class="docutils literal"><span class="pre">A1</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;A A1 m psi&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ode</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span> <span class="o">-</span> <span class="n">A1</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">diffeq</span> <span class="o">=</span> <span class="n">ode</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="n">u_sol</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">diffeq</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="n">u_sol</span> <span class="o">=</span> <span class="n">u_sol</span><span class="o">.</span><span class="n">rhs</span>

<span class="c1"># Determine the constants C1 and C2 in u_sol</span>
<span class="c1"># (first substitute our own declared C1 and C2 symbols,</span>
<span class="c1"># then use the initial conditions)</span>
<span class="n">u_sol</span> <span class="o">=</span> <span class="n">u_sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="n">C1</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="n">C2</span><span class="p">)</span>
<span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">u_sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span> <span class="n">u_sol</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">V</span><span class="p">]</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">])</span>
<span class="n">u_sol</span> <span class="o">=</span> <span class="n">u_sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">C1</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C2</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">C2</span><span class="p">])</span>

<span class="c1"># Check that the solution fulfills the equation and init.cond.</span>
<span class="k">print</span> <span class="n">simplify</span><span class="p">(</span><span class="n">ode</span><span class="p">(</span><span class="n">u_sol</span><span class="p">))</span>
<span class="k">print</span> <span class="n">simplify</span><span class="p">(</span><span class="n">u_sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">I</span><span class="p">)</span>
<span class="k">print</span> <span class="n">simplify</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">u_sol</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">V</span><span class="p">)</span>

<span class="n">u_sol</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">u_sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A</span><span class="o">/</span><span class="n">m</span><span class="p">)))</span>
<span class="k">print</span> <span class="n">u_sol</span>
</pre></div>
</div>
<p>The output from the last line is</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>A/m*cos(psi*t)/(-psi**2 + w**2) + V*sin(t*w)/w +
(A/m + I*psi**2 - I*w**2)*cos(t*w)/(psi**2 - w**2)
</pre></div>
</div>
<p>With a bit of rewrite this expression becomes</p>
<div class="math">
\[u(t) = \frac{A/m}{\omega^2 - \psi^2}\cos(\psi t) + \frac{V}{\omega}
   \sin(\omega t) +
\left(\frac{A/m}{\psi^2 - \omega^2} + I\right) \cos (\omega t){\thinspace .}\]</div>
<p>Obviously, this expression is only meaningful for <span class="math">\(\psi\neq\omega\)</span>. The
case <span class="math">\(\psi = \omega\)</span> gives an infinite amplitude in this model, a
phenomenon known as resonance. The amplitude becomes finite when
damping is included,
see the section <a class="reference internal" href="#sec-scale-vib-damped-f"><span class="std std-ref">Damped vibrations with forcing</span></a>.</p>
<p>When the system starts from rest, <span class="math">\(I=V=0\)</span>, and the
forcing is the only driving mechanism, we can simplify:</p>
<div class="math">
\[\begin{split}u(t) &amp;= \frac{A}{m(\omega^2 - \psi^2)}\cos(\psi t)
+
\frac{A}{m(\psi^2 - \omega^2)}\cos (\omega t)\\
&amp;= \frac{A}{m(\omega^2 - \psi^2)}(\cos(\psi t) - \cos(\omega t)){\thinspace .}\end{split}\]</div>
<p>To gain more insight, <span class="math">\(\cos(\psi t) - \cos(\omega t)\)</span> can be
rewritten in terms of the mean frequency <span class="math">\((\psi + \omega)/2\)</span> and
the difference in frequency <span class="math">\((\psi - \omega)/2\)</span>:</p>
<div class="math" id="eq-sec-scale-vib-undamped-f-model-sinsin">
\[\tag{73}
u(t) = \frac{A}{m(\omega^2 - \psi^2)} 2
    \sin\left(\frac{\psi - \omega}{2}t\right)
    \sin\left(\frac{\psi + \omega}{2}t\right),\]</div>
<p>showing that there is a signal with frequency <span class="math">\((\psi + \omega)/2\)</span>
whose amplitude has a (much) slower frequency
<span class="math">\((\psi - \omega)/2\)</span>. Figure <a class="reference internal" href="#sec-scale-vib-fig-envelope"><span class="std std-ref">Signal with frequency 3.1 and envelope frequency 0.2</span></a> shows
an example on such a signal.</p>
<div class="figure" id="id11">
<span id="sec-scale-vib-fig-envelope"></span><a class="reference internal image-reference" href="_images/envelope.png"><img alt="_images/envelope.png" src="_images/envelope.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Signal with frequency 3.1 and envelope frequency 0.2</em></span></p>
</div>
</div>
<div class="section" id="the-displacement-and-time-scales">
<h4>The displacement and time scales<a class="headerlink" href="#the-displacement-and-time-scales" title="Permalink to this headline">¶</a></h4>
<p>A characteristic displacement can in the latter special case
be taken as <span class="math">\(u_c= A/(m(\omega^2 - \psi^2))\)</span>. This is also a relevant choice
in the more general case <span class="math">\(I\neq0, V\neq 0\)</span>, unless <span class="math">\(I\)</span> or <span class="math">\(V\)</span>
is so large that it dominates over the amplitude
caused by the forcing. With <span class="math">\(u_c= A/(m(\omega^2 - \psi^2))\)</span> we also
have three special cases: <span class="math">\(\omega \ll \psi\)</span>, <span class="math">\(\omega \gg\psi\)</span>, and
<span class="math">\(\psi \sim \omega\)</span>. In the latter case we need
<span class="math">\(u_c= A/(m(\omega^2 - \psi^2))\)</span> if we want <span class="math">\(|u|\leq 1\)</span>. When
<span class="math">\(\omega\)</span> and <span class="math">\(\psi\)</span> are significantly different, we may choose one
of them and neglect the smaller. Choosing <span class="math">\(\omega\)</span> means <span class="math">\(u_c=A/k\)</span>,
which is the relevant scale
if <span class="math">\(\omega\gg\psi\)</span>. In the opposite case, <span class="math">\(\omega\ll\psi\)</span>,
<span class="math">\(u_c=A/(m\psi^2)\)</span>.</p>
<p>The time scale is dominated by the fastest oscillations, which are
of frequency <span class="math">\(\psi\)</span> or <span class="math">\(\omega\)</span> when these are close and the largest
of them when they are distant. In any case, we set
<span class="math">\(t_c=1/\max(\psi,\omega)\)</span>.</p>
</div>
<div class="section" id="finding-the-displacement-scale-from-the-differential-equation">
<h4>Finding the displacement scale from the differential equation<a class="headerlink" href="#finding-the-displacement-scale-from-the-differential-equation" title="Permalink to this headline">¶</a></h4>
<p>Going back to <a class="reference internal" href="#eq-sec-scale-vib-undamped-f-model-scaled0"><span class="std std-ref">(72)</span></a>, we
may demand that all the three terms in the differential equation
are of size unity. This leads to <span class="math">\(t_c=\sqrt{m/k}\)</span>
and <span class="math">\(u_c=At_c^2/m = A/k\)</span>. The formula for <span class="math">\(u_c\)</span> is a kind of measure
of the ratio of the
forcing and the spring force (the dimensionless number
<span class="math">\(A/(ku_c)\)</span> would be this ratio).</p>
<p>Looking at <a class="reference internal" href="#eq-sec-scale-vib-undamped-f-model-sinsin"><span class="std std-ref">(73)</span></a>, we see
that if <span class="math">\(\psi\ll\omega\)</span>, the amplitude can be approximated
by <span class="math">\(A/(m\omega^2)=A/k\)</span>, showing that the scale <span class="math">\(u_c=A/k\)</span> is
relevant for an excitation frequency <span class="math">\(\psi\)</span> that is small compared to
the free vibration frequency <span class="math">\(\omega\)</span>.</p>
</div>
<div class="section" id="scaling-with-free-vibrations-as-time-scale">
<h4>Scaling with free vibrations as time scale<a class="headerlink" href="#scaling-with-free-vibrations-as-time-scale" title="Permalink to this headline">¶</a></h4>
<p>The next step is to work out the dimensionless ODE for the chosen scales.
We first select the time scale based on the free oscillations
with frequency <span class="math">\(\omega\)</span>, i.e., <span class="math">\(t_c=1/\omega\)</span>. Inserting the expression in
<a class="reference internal" href="#eq-sec-scale-vib-undamped-f-model-scaled0"><span class="std std-ref">(72)</span></a> results in</p>
<div class="math" id="eq-sec-scale-vib-undamped-f-model-scaled2">
\[\tag{74}
\frac{d^2\bar u}{d\bar t^2} + \bar u =
    \gamma
    \cos(\delta\bar t),
    \quad \bar u(0)=\alpha,\ \bar u'(0)=\beta{\thinspace .}\]</div>
<p>Here we have four dimensionless variables</p>
<div class="math" id="eq-auto15">
\[\tag{75}
\alpha = \frac{I}{u_c},\]</div>
<div class="math" id="eq-auto16">
\[\tag{76}
\beta  = \frac{Vt_c}{u_c} = \frac{V}{\omega u_c},\]</div>
<div class="math" id="eq-auto17">
\[\tag{77}
\gamma = \frac{t_c^2 A}{mu_c} = \frac{A}{ku_c},\]</div>
<div class="math" id="eq-auto18">
\[\tag{78}
\delta = \frac{t_c}{\psi^{-1}} = \frac{\psi}{\omega}{\thinspace .}\]</div>
<p>We remark that the choice of <span class="math">\(u_c\)</span> has so far not been made. Several
different cases will be considered below, and we will see that certain
choices reduce the number of independent dimensionless variables to
three.</p>
<p>The four dimensionless variables above have interpretations as ratios of
physical effects:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(\alpha\)</span>: ratio of the initial displacement and
the characteristic response <span class="math">\(u_c\)</span>,</li>
<li><span class="math">\(\beta\)</span>: ratio of the initial velocity
and the typical velocity measure <span class="math">\(u_c/t_c\)</span>,</li>
<li><span class="math">\(\gamma\)</span>: ratio of
the forcing <span class="math">\(A\)</span> and the mass times acceleration <span class="math">\(mu_c/t_c^2\)</span> <em>or</em>
the ratio of the forcing and the spring force <span class="math">\(ku_c\)</span></li>
<li><span class="math">\(\delta\)</span>: ratio of the
frequencies or the time scales of the forcing and the free vibrations.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="software-5">
<h4>Software<a class="headerlink" href="#software-5" title="Permalink to this headline">¶</a></h4>
<p>Any solver for <a class="reference internal" href="#eq-sec-scale-vib-undamped-f-model-scaled0"><span class="std std-ref">(72)</span></a>
can be used for <a class="reference internal" href="#eq-sec-scale-vib-undamped-f-model-scaled2"><span class="std std-ref">(74)</span></a>.
More details are provided at the end of
the section <a class="reference internal" href="#sec-scale-vib-damped-f"><span class="std std-ref">Damped vibrations with forcing</span></a>.</p>
</div>
<div class="section" id="choice-of-close-to-resonance">
<h4>Choice of <span class="math">\(u_c\)</span> close to resonance<a class="headerlink" href="#choice-of-close-to-resonance" title="Permalink to this headline">¶</a></h4>
<p>Now we shall discuss various choices of <span class="math">\(u_c\)</span>.
Close to resonance, when <span class="math">\(\psi\sim\omega\)</span>, we may set
<span class="math">\(u_c=A/(m(\omega^2 - \psi^2))\)</span>. The dimensionless numbers
become in this case</p>
<div class="math">
\[\begin{split}\alpha &amp;= \frac{I}{u_c} = \frac{I}{A/k}(1-\delta^2),\\
\beta  &amp;= \frac{V}{\omega u_c} = \frac{V\sqrt{km}}{A}(1-\delta^2),\\
\gamma &amp;= \frac{A}{ku_c} = 1-\delta^2,\\
\delta &amp;= \frac{\psi}{\omega}{\thinspace .}\end{split}\]</div>
<p>With <span class="math">\(\psi = 0.99\omega\)</span>, <span class="math">\(\delta =0.99\)</span>, <span class="math">\(V=0\)</span>,
<span class="math">\(\alpha = \gamma = 1-\delta^2 = 0.02\)</span>, we have the problem</p>
<div class="math">
\[\frac{d^2\bar u}{d\bar t^2} + \bar u =
0.02 \cos(0.99\bar t),
\quad \bar u(0)=0.02,\ \bar u'(0)=0{\thinspace .}\]</div>
<p>This is a problem with a very small initial condition and a very small
forcing, but the state close to resonance brings the amplitude up to
about unity, see the result of numerical simulations with <span class="math">\(\delta=0.99\)</span> in
Figure <a class="reference internal" href="#sec-scale-vib-fig-fcos-b0-1"><span class="std std-ref">Forced undamped vibrations close to resonance</span></a>.
Neglecting <span class="math">\(\alpha\)</span>,
the solution is given by <a class="reference internal" href="#eq-sec-scale-vib-undamped-f-model-sinsin"><span class="std std-ref">(73)</span></a>,
which here means <span class="math">\(A=1-\delta^2\)</span>, <span class="math">\(m=1\)</span>, <span class="math">\(\omega=1\)</span>, <span class="math">\(\psi=\delta\)</span>:</p>
<div class="math">
\[\bar u(\bar t) = 2\sin(-0.005\bar t)\sin(0.995\bar t){\thinspace .}\]</div>
<p>Note that this is a problem which demands very high accuracy in the
numerical calculations. Using 20 time steps per period gives a
significant angular frequency error and an amplitude of about 1.4. We used
160 steps per period for the results in
Figure <a class="reference internal" href="#sec-scale-vib-fig-fcos-b0-1"><span class="std std-ref">Forced undamped vibrations close to resonance</span></a>.</p>
<div class="figure" id="id12">
<span id="sec-scale-vib-fig-fcos-b0-1"></span><a class="reference internal image-reference" href="_images/vib_delta099_b0_Fcos.png"><img alt="_images/vib_delta099_b0_Fcos.png" src="_images/vib_delta099_b0_Fcos.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Forced undamped vibrations close to resonance</em></span></p>
</div>
</div>
<div class="section" id="unit-size-of-all-terms-in-the-ode">
<h4>Unit size of all terms in the ODE<a class="headerlink" href="#unit-size-of-all-terms-in-the-ode" title="Permalink to this headline">¶</a></h4>
<p>Using the displacement scale <span class="math">\(u_c=A/k\)</span> leads to
<a class="reference internal" href="#eq-sec-scale-vib-undamped-f-model-scaled2"><span class="std std-ref">(74)</span></a> with</p>
<div class="math">
\[\begin{split}\alpha &amp;= \frac{I}{u_c} = \frac{I}{A/k},\\
\beta  &amp;= \frac{V}{\omega u_c} = \frac{V k}{A\omega},\\
\gamma &amp;= \frac{A}{ku_c} = 1,\\
\delta &amp;= \frac{\psi}{\omega}{\thinspace .}\end{split}\]</div>
<p>Simulating a case with <span class="math">\(\delta=0.5\)</span>, <span class="math">\(\alpha=1\)</span>, and <span class="math">\(\beta=0\)</span> gives
the oscillations in Figure <a class="reference internal" href="#sec-scale-vib-fig-fcos-b0-2"><span class="std std-ref">Forced undamped vibrations away from resonance</span></a>, which is
a case away from resonance, and the amplitude is about unity. However,
choosing <span class="math">\(\delta =0.99\)</span> (close to resonance) results in a figure
similar to Figure <a class="reference internal" href="#sec-scale-vib-fig-fcos-b0-1"><span class="std std-ref">Forced undamped vibrations close to resonance</span></a>, except that the
amplitude is about <span class="math">\(10^2\)</span> because of the moderate size of <span class="math">\(u_c\)</span>.
The present scaling is therefore most suitable away from resonance,
and when the terms containing <span class="math">\(\cos\omega t\)</span> and <span class="math">\(\sin\omega t\)</span>
are important (e.g., <span class="math">\(\omega\gg\psi\)</span>).</p>
<div class="figure" id="id13">
<span id="sec-scale-vib-fig-fcos-b0-2"></span><a class="reference internal image-reference" href="_images/vib_delta05_b0_Fcos.png"><img alt="_images/vib_delta05_b0_Fcos.png" src="_images/vib_delta05_b0_Fcos.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Forced undamped vibrations away from resonance</em></span></p>
</div>
</div>
<div class="section" id="choice-of-when">
<h4>Choice of <span class="math">\(u_c\)</span> when <span class="math">\(\psi\gg\omega\)</span><a class="headerlink" href="#choice-of-when" title="Permalink to this headline">¶</a></h4>
<p>Finally, we may look at the case where <span class="math">\(\psi\gg\omega\)</span> such that
<span class="math">\(u_c=A/(m\psi^2)\)</span> is a relevant scale (i.e., omitting <span class="math">\(\omega^2\)</span> compared to
<span class="math">\(\psi^2\)</span> in the denominator), but in this case we should
use <span class="math">\(t_c=1/\psi\)</span> since the force varies much faster than the
free vibrations of the system.
This choice of <span class="math">\(t_c\)</span> changes the scaled ODE to</p>
<div class="math" id="eq-sec-scale-vib-undamped-f-model-scaled6">
\[\tag{79}
\frac{d^2\bar u}{d\bar t^2} + \delta^{-2}\bar u =
    \gamma
    \cos(\bar t),
    \quad \bar u(0)=\alpha,\ \bar u'(0)=\beta,\]</div>
<p>where</p>
<div class="math">
\[\begin{split}\alpha &amp;= \frac{I}{u_c} = \frac{I}{A/k}\delta^2,\\
\beta  &amp;= \frac{Vt_c}{u_c} = \frac{V\sqrt{km}}{A}\delta,\\
\gamma &amp;= \frac{t_c^2 A}{mu_c} = 1,\\
\delta &amp;= \frac{t_c}{\psi^{-1}} = \frac{\psi}{\omega}{\thinspace .}\end{split}\]</div>
<p>In the regime <span class="math">\(\psi\gg\omega\)</span>, <span class="math">\(\delta\gg 1\)</span>, thus making <span class="math">\(\alpha\)</span> and
<span class="math">\(\beta\)</span> large.
However, if <span class="math">\(\alpha\)</span> and/or <span class="math">\(\beta\)</span> is large,
the initial condition dominates over the forcing, and will also dominate
the amplitude of <span class="math">\(u\)</span>, thereby making the scaling of <span class="math">\(u\)</span> inappropriate.
In case <span class="math">\(I=V=0\)</span> so that <span class="math">\(\alpha=\beta=0\)</span>,
<a class="reference internal" href="#eq-sec-scale-vib-undamped-f-model-sinsin"><span class="std std-ref">(73)</span></a> predicts
(<span class="math">\(A=m=1\)</span>, <span class="math">\(\omega=\delta^{-1}\)</span>, <span class="math">\(\psi=1\)</span>)</p>
<div class="math">
\[\bar u(\bar t) = (\delta^{-2}-1)^{-1}2
\sin\left(\frac{1}{2}(1 -\delta^{-1})\bar t\right)
\sin\left(\frac{1}{2}(1 +\delta^{-1})\bar t\right),\]</div>
<p>which has an amplitude about <span class="math">\(2\)</span> for <span class="math">\(\delta\gg 1\)</span>.
Figure <a class="reference internal" href="#sec-scale-vib-fig-fcos-b0-3"><span class="std std-ref">Forced undamped vibrations with rapid forcing</span></a> shows a case.</p>
<div class="figure" id="id14">
<span id="sec-scale-vib-fig-fcos-b0-3"></span><a class="reference internal image-reference" href="_images/vib_delta10_b0_Fcos.png"><img alt="_images/vib_delta10_b0_Fcos.png" src="_images/vib_delta10_b0_Fcos.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Forced undamped vibrations with rapid forcing</em></span></p>
</div>
<p>With <span class="math">\(\alpha=0.05\delta^2=5\)</span>, we get a significant contribution from
the free vibrations (the homogeneous solution of the ODE) as
shown in Figure <a class="reference internal" href="#sec-scale-vib-fig-fcos-b0-4"><span class="std std-ref">Forced undamped vibrations with rapid forcing and initial displacement of 5</span></a>. For larger <span class="math">\(\alpha\)</span>
values, one must base <span class="math">\(u_c\)</span> on <span class="math">\(I\)</span> instead.
(The graphs in Figure <a class="reference internal" href="#sec-scale-vib-fig-fcos-b0-3"><span class="std std-ref">Forced undamped vibrations with rapid forcing</span></a> and
<a class="reference internal" href="#sec-scale-vib-fig-fcos-b0-4"><span class="std std-ref">Forced undamped vibrations with rapid forcing and initial displacement of 5</span></a> were
produced by
numerical simulations with 160 time steps per period of the forcing.)</p>
<div class="figure" id="id15">
<span id="sec-scale-vib-fig-fcos-b0-4"></span><a class="reference internal image-reference" href="_images/vib_delta10_b0_a5_Fcos.png"><img alt="_images/vib_delta10_b0_a5_Fcos.png" src="_images/vib_delta10_b0_a5_Fcos.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Forced undamped vibrations with rapid forcing and initial displacement of 5</em></span></p>
</div>
</div>
<div class="section" id="displacement-scale-based-on">
<h4>Displacement scale based on <span class="math">\(I\)</span><a class="headerlink" href="#displacement-scale-based-on" title="Permalink to this headline">¶</a></h4>
<p>Choosing <span class="math">\(u_c=I\)</span> gives</p>
<div class="math" id="eq-sec-scale-vib-undamped-f-model-scaled5">
\[\tag{80}
\frac{d^2\bar u}{d\bar t^2} + \bar u =
    \gamma\cos(\delta\bar t),
    \quad \bar u(0)=1,\ \bar u'(0)=\beta,\]</div>
<p>with</p>
<div class="math" id="eq-auto19">
\[\tag{81}
\beta  = \frac{Vt_c}{u_c} = \frac{V}{I}\sqrt{\frac{m}{k}},\]</div>
<div class="math" id="eq-auto20">
\[\tag{82}
\gamma  = \frac{tc^2A}{mu_c} = \frac{A}{ku_c} = \frac{A}{kI} {\thinspace .}\]</div>
<p>This scaling is not relevant close to resonance since then <span class="math">\(u_c\gg I\)</span>.</p>
</div>
</div>
<div class="section" id="damped-vibrations-with-forcing">
<span id="sec-scale-vib-damped-f"></span><h3>Damped vibrations with forcing<a class="headerlink" href="#damped-vibrations-with-forcing" title="Permalink to this headline">¶</a></h3>
<p>We now introduce a linear damping force <span class="math">\(bu'(t)\)</span> in the equation of motion:</p>
<div class="math" id="eq-sec-scale-vib-damped-f-model">
\[\tag{83}
mu'' + bu' + ku = A\cos(\psi t),\quad u(0)=I,\ u'(0)=V{\thinspace .}\]</div>
<p>Figure <a class="reference internal" href="#sec-scale-vib-damped-sketch"><span class="std std-ref">Oscillating body with external force, attached to a spring and damper</span></a> shows a typical
one-degree-of-freedom mechanical system with a linear dashpot, representing
the damper (<span class="math">\(bu'\)</span>), a linear spring (<span class="math">\(ku\)</span>), and an external force (<span class="math">\(F\)</span>).</p>
<div class="figure" id="id16">
<span id="sec-scale-vib-damped-sketch"></span><a class="reference internal image-reference" href="_images/oscillator.png"><img alt="_images/oscillator.png" src="_images/oscillator.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Oscillating body with external force, attached to a spring and damper</em></span></p>
</div>
<p>The standard scaling procedure results in</p>
<div class="math" id="eq-sec-scale-vib-damped-f-model-scaled0">
\[\tag{84}
\frac{d^2\bar u}{d\bar t^2} + \frac{t_c b}{m}\frac{d\bar u}{d\bar t}
    + \frac{t_c^2 k}{m}\bar u =
    \frac{t_c^2}{mu_c}A\cos(\psi t_c\bar t),
    \quad \bar u(0)=\frac{I}{u_c},\ \bar u'(0)=\frac{Vt_c}{u_c}{\thinspace .}\]</div>
<div class="section" id="the-exact-solution-2">
<h4>The exact solution<a class="headerlink" href="#the-exact-solution-2" title="Permalink to this headline">¶</a></h4>
<p>As always, it is
a great advantage to look into exact solutions for controlling our
choice of scales.
Using SymPy to solve <a class="reference internal" href="#eq-sec-scale-vib-damped-f-model"><span class="std std-ref">(83)</span></a> is, in principle,
very straightforward:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">diffeq</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="o">/</span><span class="n">m</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">diffeq</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">rhs</span>
<span class="go">C1*exp(t*(-b - sqrt(b - 2*m*w)*sqrt(b + 2*m*w))/(2*m)) +</span>
<span class="go">C2*exp(t*(-b + sqrt(b - 2*m*w)*sqrt(b + 2*m*w))/(2*m))</span>
</pre></div>
</div>
<p>This is indeed the correct solution, but it is on a complex
exponential function form, valid for all <span class="math">\(b\)</span>, <span class="math">\(m\)</span>, and <span class="math">\(\omega\)</span>. We are
interested in the case with <em>small damping</em>, <span class="math">\(b &lt; 2m\omega\)</span>, where the solution
is an exponentially damped sinusoidal function. Rewriting the expression
in the right form is tricky with SymPy commands. Instead, we demonstrate
a common technique when doing symbolic computing: general procedures like
<code class="docutils literal"><span class="pre">dsolve</span></code> are replaced by manual steps. That is, we solve the ODE &#8220;by hand&#8221;,
but use SymPy to assist the calculations.</p>
<p>The solution is composed of a homogeneous
solution <span class="math">\(u_h\)</span> of <span class="math">\(mu'' + bu' + ku=0\)</span> and one particular solution <span class="math">\(u_p\)</span>
of the nonhomogeneous equation
<span class="math">\(mu'' + bu' + ku=A\cos(\psi t)\)</span>. The homogeneous solution with
damped oscillations (requiring <span class="math">\(b &lt; 2\sqrt{mk}\)</span>) can be
found by the following code. We have divided the differential equation
by <span class="math">\(m\)</span> and introduced <span class="math">\(B=\frac{1}{2}b/m\)</span> and let <code class="docutils literal"><span class="pre">A1</span></code> represent
<span class="math">\(A/m\)</span> to simplify expressions and
help SymPy with less symbols in the equation. Without these simplifications,
SymPy stalls in the computations due to too many symbols in the equation.
The problem is actually a solid argument for scaling differential equations
before asking SymPy to solve them since scaling effectively reduces the
number of parameters in the equations!</p>
<p>The following SymPy steps derives the solution of the homogeneous ODE:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
<span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t w B A A1 m psi&#39;</span><span class="p">,</span>
                                 <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ode</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">homogeneous</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">A1</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">h</span> <span class="k">if</span> <span class="n">homogeneous</span> <span class="k">else</span> <span class="n">h</span> <span class="o">-</span> <span class="n">f</span>

<span class="c1"># Find coefficients in polynomial (in r) for exp(r*t) ansatz</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">ansatz</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">poly</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">ode</span><span class="p">(</span><span class="n">ansatz</span><span class="p">)</span><span class="o">/</span><span class="n">ansatz</span><span class="p">)</span>

<span class="c1"># Convert to polynomial to extract coefficients</span>
<span class="n">poly</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="c1"># Extract coefficients in poly: a_*t**2 + b_*t + c_</span>
<span class="n">a_</span><span class="p">,</span> <span class="n">b_</span><span class="p">,</span> <span class="n">c_</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">coeffs</span><span class="p">()</span>
<span class="c1"># Assume b_**2 - 4*a_*c_ &lt; 0</span>
<span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">b_</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a_</span><span class="p">)</span>
<span class="k">if</span> <span class="n">a_</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">c_</span> <span class="o">-</span> <span class="p">(</span><span class="n">b_</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># nicer formula</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">a_</span><span class="o">*</span><span class="n">c_</span> <span class="o">-</span> <span class="n">b_</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a_</span><span class="p">)</span>

<span class="c1"># The homogeneous solution is a linear combination of a</span>
<span class="c1"># cos term (u1) and a sin term (u2)</span>
<span class="n">u1</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">u2</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;C1 C2 V I&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">u_h</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">C1</span><span class="o">*</span><span class="n">u1</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="n">u2</span><span class="p">)</span>
<span class="k">print</span> <span class="s1">&#39;u_h:&#39;</span><span class="p">,</span> <span class="n">u_h</span>
</pre></div>
</div>
<p>The print out shows</p>
<div class="math">
\[u_h = e^{-Bt}\left(C_1 \cos(\sqrt{\omega^2 - B^2}t) +
C_2 \sin(\sqrt{\omega^2 - B^2}t)\right),\]</div>
<p>where <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> must be determined by the initial conditions later.
It is wise to check that <span class="math">\(u_h\)</span> is indeed a solution of the homogeneous
differential equation:</p>
<div class="highlight-python" id="index-20"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">simplify</span><span class="p">(</span><span class="n">ode</span><span class="p">(</span><span class="n">u_h</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
<p>We have previously just printed the residuals of the ODE and initial
conditions after inserting the solution, but it is better in a code to
let the programming language test that the residuals are symbolically zero.
This is achieved using the <code class="docutils literal"><span class="pre">assert</span></code> statement in Python. The argument is
a boolean expression, and if the expression evaluates to <code class="docutils literal"><span class="pre">False</span></code>,
an <code class="docutils literal"><span class="pre">AssertionError</span></code> is raised and the program aborts (otherwise <code class="docutils literal"><span class="pre">assert</span></code>
runs silently for a <code class="docutils literal"><span class="pre">True</span></code> boolean expression). Hereafter, we will use
<code class="docutils literal"><span class="pre">assert</span></code> for consistency checks in computer code.</p>
<p>The ansatz for the particular solution <span class="math">\(u_p\)</span> is</p>
<div class="math">
\[u_p= C_3\cos(\psi t) + C_4\sin(\psi t),\]</div>
<p>which inserted in the ODE gives two equations
for <span class="math">\(C_3\)</span> and <span class="math">\(C_4\)</span>. The relevant SymPy statements are</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Particular solution</span>
<span class="n">C3</span><span class="p">,</span> <span class="n">C4</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;C3 C4&#39;</span><span class="p">)</span>
<span class="n">u_p</span> <span class="o">=</span> <span class="n">C3</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">C4</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">eqs</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">ode</span><span class="p">(</span><span class="n">u_p</span><span class="p">,</span> <span class="n">homogeneous</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>

<span class="c1"># Collect cos(omega*t) terms</span>
<span class="k">print</span> <span class="s1">&#39;eqs:&#39;</span><span class="p">,</span> <span class="n">eqs</span>
<span class="n">eq_cos</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">eqs</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="o">*</span><span class="n">t</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="o">*</span><span class="n">t</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">eq_sin</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">eqs</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="o">*</span><span class="n">t</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="o">*</span><span class="n">t</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">solve</span><span class="p">([</span><span class="n">eq_cos</span><span class="p">,</span> <span class="n">eq_sin</span><span class="p">],</span> <span class="p">[</span><span class="n">C3</span><span class="p">,</span> <span class="n">C4</span><span class="p">])</span>
<span class="n">u_p</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">u_p</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C3</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">C3</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C4</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">C4</span><span class="p">]))</span>

<span class="c1"># Check that the solution is correct</span>
<span class="k">assert</span> <span class="n">simplify</span><span class="p">(</span><span class="n">ode</span><span class="p">(</span><span class="n">u_p</span><span class="p">,</span> <span class="n">homogeneous</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Using the initial conditions for the complete solution <span class="math">\(u=u_h+u_p\)</span>
determines <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_sol</span> <span class="o">=</span> <span class="n">u_h</span> <span class="o">+</span> <span class="n">u_p</span>  <span class="c1"># total solution</span>
<span class="c1"># Initial conditions</span>
<span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">u_sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span> <span class="n">u_sol</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">V</span><span class="p">]</span>
<span class="c1"># Determine C1 and C2 from the initial conditions</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">])</span>
<span class="n">u_sol</span> <span class="o">=</span> <span class="n">u_sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">C1</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C2</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">C2</span><span class="p">])</span>
</pre></div>
</div>
<p>Finally, we should check that <code class="docutils literal"><span class="pre">u_sol</span></code> is indeed the correct solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">checks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">ODE</span><span class="o">=</span><span class="n">simplify</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">ode</span><span class="p">(</span><span class="n">u_sol</span><span class="p">,</span> <span class="n">homogeneous</span><span class="o">=</span><span class="bp">False</span><span class="p">))),</span>
    <span class="n">IC1</span><span class="o">=</span><span class="n">simplify</span><span class="p">(</span><span class="n">u_sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">I</span><span class="p">),</span>
    <span class="n">IC2</span><span class="o">=</span><span class="n">simplify</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">u_sol</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">V</span><span class="p">))</span>
<span class="k">for</span> <span class="n">check</span> <span class="ow">in</span> <span class="n">checks</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> residual: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">check</span><span class="p">,</span> <span class="n">checks</span><span class="p">[</span><span class="n">check</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">checks</span><span class="p">[</span><span class="n">check</span><span class="p">]</span> <span class="o">==</span> <span class="n">sympify</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">msg</span>
</pre></div>
</div>
<p>Finally, we may take <code class="docutils literal"><span class="pre">u_sol</span> <span class="pre">=</span> <span class="pre">u_sol.subs(A,</span> <span class="pre">A/m)</span></code> to get the right
expression for the solution.
Using <code class="docutils literal"><span class="pre">latex(u_sol)</span></code> results in a huge expression, which should be
manually ordered to something like the following:</p>
<div class="math">
\[\begin{split}u = &amp;
\frac{Am^{-1}}{4 B^{2} \psi^{2} +
\Omega^{2}} \left(2 B \psi
\sin{\left (\psi t \right )} - \Omega\cos{\left (\psi t \right )}\right) + \\
&amp;
{e^{-B t}} \biggl(
C_1 \cos{\left( t \sqrt{\omega^{2}- B^{2}}\right)} +
C_2 \sin{\left (t \sqrt{\omega^{2}- B^{2}}\right )}\biggr)\\
C_1 &amp;= \frac{Am^{-1} \Omega + 4 I B^{2} \psi^{2} +
I\Omega^2}{
4 B^{2} \psi^{2} + \Omega^2}\\
C_2 &amp;=
\frac{- Am^{-1} B\Omega + 4 I B^{3} \psi^{2} +
I B\Omega^2 + 4 V B^{2}\psi^{2} +
V\Omega^2}{
\sqrt{\omega^{2} - B^{2}}
\left(4 B^{2} \psi^{2} + \Omega^2\right)},\\
\Omega &amp;= \psi^2 - \omega^2{\thinspace .}\end{split}\]</div>
<span class="target" id="index-21"></span><p id="index-22">The most important feature of this solution is that there are
two time scales with frequencies <span class="math">\(\psi\)</span> and <span class="math">\(\sqrt{\omega^2 - B^2}\)</span>,
respectively,
but the latter appears in terms that decay as <span class="math">\(e^{-Bt}\)</span> in time.
The attention is usually on longer periods of time, so in that
case the solution simplifies to</p>
<div class="math">
\[u = \frac{Am^{-1}}{4 B^{2} \psi^{2} +
\Omega^{2}} \left(2 B \psi
\sin{\left (\psi t \right )} - \Omega\cos{\left (\psi t \right )}\right)
\nonumber\]</div>
<div class="math">
\[= \frac{A}{m}\frac{1}{\sqrt{4B^2\psi^2 + \Omega^2}}\cos(\psi t + \phi)
\frac{(\psi\omega)^{-1}}{(\psi\omega)^{-1}}
\nonumber\]</div>
<div class="math" id="eq-sec-scale-vib-damped-f-model-u-forced0">
\[\tag{85}
= \frac{A}{k} Q\delta^{-1}\left(1 + Q^2(\delta - \delta^{-1})\right)^{-
    \frac{1}{2}}\cos(\psi t + \phi),\]</div>
<p>where we have introduced the dimensionless numbers</p>
<div class="math">
\[Q = \frac{\omega}{2B},\quad\delta = \frac{\psi}{\omega},\]</div>
<p>and</p>
<div class="math">
\[\phi = \tan^{-1}\left(-\frac{2B}{\omega^2 - \psi^2}\right)
= \tan^{-1}\left(\frac{Q^{-1}}{\delta^2 - 1}\right){\thinspace .}\]</div>
<p><span class="math">\(Q\)</span> is commonly called <em>quality factor</em> and <span class="math">\(\phi\)</span> is the
<em>phase shift</em>. Dividing
<a class="reference internal" href="#eq-sec-scale-vib-damped-f-model-u-forced0"><span class="std std-ref">(85)</span></a> by <span class="math">\(A/k\)</span>, which is a common
scale for <span class="math">\(u\)</span>, gives the dimensionless relation</p>
<div class="math" id="eq-sec-scale-vib-damped-f-model-u-forced">
\[\tag{86}
\frac{u}{A/k} = \frac{Q}{\delta} R(Q,\delta)^{\frac{1}{2}}\cos(\psi t + \phi),
    \quad
    R(Q,\delta) = \left(1 + Q^2(\delta - \delta^{-1})\right)^{-1}{\thinspace .}\]</div>
</div>
<div class="section" id="choosing-scales">
<h4>Choosing scales<a class="headerlink" href="#choosing-scales" title="Permalink to this headline">¶</a></h4>
<p>Much of the discussion about scales in the previous sections are
relevant also when damping is included.  Although the oscillations
with frequency <span class="math">\(\sqrt{\omega^2-B^2}\)</span> die out for <span class="math">\(t\gg B^{-1}\)</span>, we
start with using this frequency for the time scale.  A highly relevant
assumption for engineering applications of
<a class="reference internal" href="#eq-sec-scale-vib-damped-f-model"><span class="std std-ref">(83)</span></a> is that the damping is small.
Therefore, <span class="math">\(\sqrt{\omega^2-B^2}\)</span> is close to <span class="math">\(\omega\)</span> and we simply
apply <span class="math">\(t_c=1/\omega\)</span> as before (if not the interest in large <span class="math">\(t\)</span> for
which the oscillations with frequency <span class="math">\(\omega\)</span> has died out).</p>
<p>The coefficient in front of the <span class="math">\(\bar u'\)</span> term then becomes</p>
<div class="math">
\[\frac{b}{m\omega} = \frac{2B}{\omega} = Q^{-1}{\thinspace .}\]</div>
<p>The rest of the ODE is given in the previous section, and the particular
formulas depend on the choices of <span class="math">\(t_c\)</span> and <span class="math">\(u_c\)</span>.</p>
</div>
<div class="section" id="choice-of-at-resonance">
<h4>Choice of <span class="math">\(u_c\)</span> at resonance<a class="headerlink" href="#choice-of-at-resonance" title="Permalink to this headline">¶</a></h4>
<p>The relevant scale for <span class="math">\(u_c\)</span> at or nearby resonance (<span class="math">\(\psi = \omega\)</span>)
becomes different from the previous section, since with damping,
the maximum amplitude is a finite value. For <span class="math">\(t\gg B^{-1}\)</span>, when the
<span class="math">\(\sin\psi t\)</span> term is dominating, we have for <span class="math">\(\psi = \omega\)</span>:</p>
<div class="math">
\[u = \frac{Am^{-1}2B\psi}{4B^2\psi^2}\sin (\psi t) =
\frac{A}{2Bm\psi}\sin (\psi t) =
\frac{A}{b\psi}\sin (\psi t)
{\thinspace .}\]</div>
<p>This motivates the choice</p>
<div class="math">
\[u_c = \frac{A}{b\psi} = \frac{A}{b\omega}{\thinspace .}\]</div>
<p>(It is wise during computations like this to stop and check the
dimensions: <span class="math">\(A\)</span> must be <span class="math">\([\hbox{MLT}^{-2}]\)</span> from the original
equation (<span class="math">\(F(t)\)</span> must have the same dimension as <span class="math">\(mu''\)</span>),
<span class="math">\(bu'\)</span> must also have dimension <span class="math">\([\hbox{MLT}^{-2}]\)</span>, implying that
<span class="math">\(b\)</span> has dimension <span class="math">\([\hbox{MT}^{-1}]\)</span>. <span class="math">\(A/b\)</span> then has dimension
<span class="math">\(LT^{-1}\)</span>, and <span class="math">\(A/(b\psi)\)</span> gets dimension <span class="math">\([L]\)</span>, which matches
what we want for <span class="math">\(u_c\)</span>.)</p>
<p>The differential equation on dimensionless form becomes</p>
<div class="math" id="eq-sec-scale-vib-damped-f-model-scaled1">
\[\tag{87}
\frac{d^2\bar u}{d\bar t^2} + Q^{-1}\frac{d\bar u}{d\bar t} + \bar u =
    \gamma
    \cos(\delta\bar t),
    \quad \bar u(0)=\alpha,\ \bar u'(0)=\beta,\]</div>
<p>with</p>
<div class="math" id="eq-auto21">
\[\tag{88}
\alpha = \frac{I}{u_c} = \frac{Ib}{A}\sqrt{\frac{k}{m}},\]</div>
<div class="math" id="eq-auto22">
\[\tag{89}
\beta  = \frac{Vt_c}{u_c} = \frac{Vb}{A},\]</div>
<div class="math" id="eq-auto23">
\[\tag{90}
\gamma = \frac{t_c^2 A}{mu_c} = \frac{b\omega}{k},\]</div>
<div class="math" id="eq-auto24">
\[\tag{91}
\delta = \frac{t_c}{\psi^{-1}} = \frac{\psi}{\omega} = 1{\thinspace .}\]</div>
</div>
<div class="section" id="id3">
<h4>Choice of <span class="math">\(u_c\)</span> when <span class="math">\(\omega\gg\psi\)</span><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>In the limit <span class="math">\(\omega\gg\psi\)</span> and <span class="math">\(t\gg B^{-1}\)</span>,</p>
<div class="math">
\[u \approx \frac{A}{m\omega^2}\cos\psi t = \frac{A}{k}\cos\psi t,\]</div>
<p>showing that <span class="math">\(u_c=A/k\)</span> is an appropriate displacement scale.
(Alternatively, we get this scale also from demanding <span class="math">\(\gamma=1\)</span> in the ODE.)
The dimensionless numbers <span class="math">\(\alpha\)</span>, <span class="math">\(\beta\)</span>, and <span class="math">\(\delta\)</span> are as
for the forced vibrations without damping.</p>
</div>
<div class="section" id="id4">
<h4>Choice of <span class="math">\(u_c\)</span> when <span class="math">\(\omega\ll\psi\)</span><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>In the limit <span class="math">\(\omega\ll\psi\)</span>, we should base <span class="math">\(t_c\)</span> on the rapid
variations in the excitation: <span class="math">\(t_c=1/\psi\)</span>.</p>
</div>
<div class="section" id="software-6">
<h4>Software<a class="headerlink" href="#software-6" title="Permalink to this headline">¶</a></h4>
<p>It is easy to reuse a solver for a general vibration problem also
in the dimensionless case.
In particular, we may use the <code class="docutils literal"><span class="pre">solver</span></code> function in the
file <a class="reference external" href="http://tinyurl.com/o8pb3yy/vib.py">vib.py</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
</pre></div>
</div>
<p>for solving the ODE problem</p>
<div class="math">
\[mu'' + f(u') + s(u) = F(t),\quad u(0)=I,\ u'(0)=V,\ t\in (0,T],\]</div>
<p>with time steps <code class="docutils literal"><span class="pre">dt</span></code>. With <code class="docutils literal"><span class="pre">damping='linear'</span></code>, we have <span class="math">\(f(u')=bu'\)</span>, while the
other value is <code class="docutils literal"><span class="pre">'quadratic'</span></code>, meaning <span class="math">\(f(u')=b|u'|u'\)</span>.
Given the dimensionless numbers <span class="math">\(\alpha\)</span>, <span class="math">\(\beta\)</span>, <span class="math">\(\gamma\)</span>, <span class="math">\(\delta\)</span>,
and <span class="math">\(Q\)</span>,
an appropriate call for solving <a class="reference internal" href="#eq-sec-scale-vib-undamped-f-model-scaled2"><span class="std std-ref">(74)</span></a> is</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">Q</span><span class="p">,</span>
              <span class="n">s</span><span class="o">=</span><span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="n">u</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">gamma</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">delta</span><span class="o">*</span><span class="n">t</span><span class="p">),</span>
          <span class="n">dt</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">n</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">P</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">n</span></code> is the number of intervals per period and <code class="docutils literal"><span class="pre">P</span></code> is the number
of periods to be simulated.
We way wrap this call in a <code class="docutils literal"><span class="pre">solver_scaled</span></code> function and wrap it furthermore
with <code class="docutils literal"><span class="pre">joblib</span></code> to avoid repeated calls,
as we explained in
the section <a class="reference internal" href="#sec-scale-prog"><span class="std std-ref">Making software for utilizing the scaled model</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">vib</span> <span class="kn">import</span> <span class="n">solver</span> <span class="k">as</span> <span class="n">solver_unscaled</span>

<span class="k">def</span> <span class="nf">solver_scaled</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;&#39; + (1/Q)*u&#39; + u = gamma*cos(delta*t),</span>
<span class="sd">    u(0)=alpha, u&#39;(1)=beta, for (0,T] with step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s1">&#39;Computing the numerical solution&#39;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">cos</span>
    <span class="k">return</span> <span class="n">solver_unscaled</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="n">Q</span><span class="p">,</span>
                           <span class="n">s</span><span class="o">=</span><span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="n">u</span><span class="p">,</span>
                           <span class="n">F</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">gamma</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">delta</span><span class="o">*</span><span class="n">t</span><span class="p">),</span>
                           <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">joblib</span>
<span class="n">disk_memory</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">Memory</span><span class="p">(</span><span class="n">cachedir</span><span class="o">=</span><span class="s1">&#39;temp&#39;</span><span class="p">)</span>
<span class="n">solver_scaled</span> <span class="o">=</span> <span class="n">disk_memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">solver_scaled</span><span class="p">)</span>
</pre></div>
</div>
<p>This code is found in <a class="reference external" href="http://tinyurl.com/o8pb3yy/vib_scaled.py">vib_scaled.py</a>
and features an application for running the scaled problem with
options on the command-line for <span class="math">\(\alpha\)</span>, <span class="math">\(\beta\)</span>, <span class="math">\(\gamma\)</span>, <span class="math">\(\delta\)</span>,
<span class="math">\(Q\)</span>, number of time steps per period, and number of periods (see
the <code class="docutils literal"><span class="pre">main</span></code> function). It is an ideal application for exploring
scaled vibration models.</p>
</div>
</div>
<div class="section" id="oscillating-electric-circuits">
<h3>Oscillating electric circuits<a class="headerlink" href="#oscillating-electric-circuits" title="Permalink to this headline">¶</a></h3>
<p>The differential equation for an oscillating electric circuit is
very similar to the equation for forced, damped,
mechanical vibrations, and their
dimensionless form is identical. This fact will now be demonstrated.</p>
<p>The current <span class="math">\(I(t)\)</span> in a
circuit having an inductor with inductance <span class="math">\(L\)</span>, a capacitor with
capacitance <span class="math">\(C\)</span>, and overall resistance <span class="math">\(R\)</span>, obeys the equation</p>
<div class="math" id="eq-auto25">
\[\tag{92}
\ddot I + \frac{R}{L}\dot I + \frac{1}{LC}I =  V(t),\]</div>
<p>where <span class="math">\(V(t)\)</span> is the voltage source powering the circuit.
We introduce</p>
<div class="math">
\[\bar I=\frac{I}{I_c},\quad \bar t = \frac{t}{t_c},\]</div>
<p>and get</p>
<div class="math">
\[\frac{d^2\bar I}{d\bar t^2} + \frac{t_c R}{L}\frac{d\bar I}{d\bar t}
+ \frac{t_c^2}{LC}\bar I = \frac{t_c^2V_c}{I_c} \bar V(t){\thinspace .}\]</div>
<p>Here, we have scaled <span class="math">\(V(t)\)</span> according to</p>
<div class="math">
\[\bar V(\bar t) = \frac{V(t_c\bar t)}{\max_t V(t)}{\thinspace .}\]</div>
<p>The time scale <span class="math">\(t_c\)</span> is chosen to make <span class="math">\(\ddot I\)</span> and <span class="math">\(I/(LC)\)</span> balance,
<span class="math">\(t_c = \sqrt{LC}\)</span>.
Choosing <span class="math">\(I_c\)</span> to make the coefficient in the source term of unit size,
means <span class="math">\(I_c = LCV_c\)</span>.
With</p>
<div class="math">
\[Q^{-1} = R\sqrt{\frac{C}{L}},\]</div>
<p>we get the scaled equation</p>
<div class="math" id="eq-auto26">
\[\tag{93}
\frac{d^2\bar I}{d\bar t^2} + Q^{-1}\frac{d\bar I}{d\bar t}
    + \bar I = \bar V(t),\]</div>
<p>which is basically the same as we derived for mechanical vibrations.
(Two additional dimensionless variables will arise from the initial
conditions for <span class="math">\(I\)</span>, just as in the mechanics cases.)</p>
</div>
</div>
<div class="section" id="exercises-1">
<h2>Exercises<a class="headerlink" href="#exercises-1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-2-1-perform-unit-conversion">
<span id="sec-scale-exer-us2si1"></span><h3>Exercise 2.1: Perform unit conversion<a class="headerlink" href="#exercise-2-1-perform-unit-conversion" title="Permalink to this headline">¶</a></h3>
<p>Density (mass per volume: <span class="math">\([\hbox{ML}^{-3}]\)</span>) of water is
given as 1.05 ounce per fluid ounce. Use the <code class="docutils literal"><span class="pre">PhysicalQuantity</span></code> object
to convert to <span class="math">\(\hbox{kg\,m}^{-3}\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">density_conversion</span></code>.</p>
</div>
<div class="section" id="problem-2-2-scale-a-simple-formula">
<span id="sec-scale-exer-ball-y"></span><h3>Problem 2.2: Scale a simple formula<a class="headerlink" href="#problem-2-2-scale-a-simple-formula" title="Permalink to this headline">¶</a></h3>
<p>The height <span class="math">\(y\)</span> of a body thrown up in the air is given by</p>
<div class="math">
\[y = v_0t - \frac{1}{2}gt^2,\]</div>
<p>where <span class="math">\(t\)</span> is time, <span class="math">\(v_0\)</span> is the initial velocity of the body at <span class="math">\(t=0\)</span>,
and <span class="math">\(g\)</span> is the acceleration of gravity. Scale this formula. Use
two choices of the characteristic time: the time it takes to reach the
maximum <span class="math">\(y\)</span> value and the time it takes to return to <span class="math">\(y=0\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vertical_motion</span></code>.</p>
</div>
<div class="section" id="exercise-2-3-perform-alternative-scalings">
<span id="sec-scale-exer-decay-cooling-osc"></span><h3>Exercise 2.3: Perform alternative scalings<a class="headerlink" href="#exercise-2-3-perform-alternative-scalings" title="Permalink to this headline">¶</a></h3>
<p>The problem in the section <a class="reference internal" href="#scale-cooling-osc"><span class="std std-ref">Scaling a cooling problem with time-dependent surroundings</span></a> applies a
temperature scaling</p>
<div class="math">
\[\bar T = \frac{T-T_0}{T_m-T_0},\]</div>
<p>which is not always suitable.</p>
<p><strong>a)</strong>
Consider the case <span class="math">\(T_0=T_m\)</span> and the fact that <span class="math">\(|T_m-T_0|\)</span> does not
represent the characteristic temperature scale since it
collapses to zero. Formulate a suitable
scaling in this case. The figure below corresponds to <span class="math">\(T_m=25\)</span> C,
<span class="math">\(T_0=24.9\)</span> C, and <span class="math">\(a=2.5\)</span> C. We clearly see that <span class="math">\(\bar T\)</span> is
not of size unity.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/osc_cooling_wrong_scale.png"><img alt="_images/osc_cooling_wrong_scale.png" src="_images/osc_cooling_wrong_scale.png" style="width: 500px;" /></a>
</div>
<p><strong>b)</strong>
Consider the case where <span class="math">\(a\)</span> is much larger than <span class="math">\(|T_m-T_0|\)</span>.
What is an appropriate scaling of the temperature?</p>
</div>
<div class="section" id="problem-2-4-a-nonlinear-ode-for-vertical-motion-with-air-resistance">
<span id="sec-scale-exer-ball-y-wdrag"></span><h3>Problem 2.4: A nonlinear ODE for vertical motion with air resistance<a class="headerlink" href="#problem-2-4-a-nonlinear-ode-for-vertical-motion-with-air-resistance" title="Permalink to this headline">¶</a></h3>
<p>The velocity <span class="math">\(v(t)\)</span>
of a body moving vertically through a fluid in the gravity field
(with fluid drag, buoyancy, and added mass) is governed by the ODE</p>
<div class="math">
\[mv' + \mu v'
= -\frac{1}{2}C_D\varrho A |v|v - mg + \varrho V g,\quad v(0)=v_0,\]</div>
<p>where <span class="math">\(t\)</span> is time, <span class="math">\(m\)</span> is the mass of the body, <span class="math">\(\mu\)</span> is the body&#8217;s added
mass, <span class="math">\(C_D\)</span> is a drag coefficient,
<span class="math">\(\varrho\)</span> is the density of the fluid, <span class="math">\(A\)</span> is the cross-sectional area
perpendicular to the motion, <span class="math">\(g\)</span> is the acceleration of gravity,
and <span class="math">\(V\)</span> is the volume of the body. Scale this ODE.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vertical_motion_with_drag</span></code>.</p>
</div>
<div class="section" id="exercise-2-5-solve-a-decay-ode-with-discontinuous-coefficient">
<span id="sec-scale-exer-decay-jump"></span><h3>Exercise 2.5: Solve a decay ODE with discontinuous coefficient<a class="headerlink" href="#exercise-2-5-solve-a-decay-ode-with-discontinuous-coefficient" title="Permalink to this headline">¶</a></h3>
<p>Make software for the problem in the section <a class="reference internal" href="#sec-scale-jump"><span class="std std-ref">Variable coefficients</span></a>
so that you can produce Figure <a class="reference internal" href="#sec-scale-jump-fig"><span class="std std-ref">Exponential decay with jump: scaled model (left) and unscaled model (right)</span></a>.</p>
<p><strong>Hint.</strong>
Follow the ideas for software in the section <a class="reference internal" href="#sec-scale-body"><span class="std std-ref">Scaling a generalized problem</span></a>: use the
<a class="reference external" href="http://tinyurl.com/o8pb3yy/decay_vc.py">decay_vc.py</a> module as computational
engine and modify the
<a class="reference external" href="http://tinyurl.com/o8pb3yy/falling_body.py">falling_body.py</a> code.</p>
<p>Filename: <code class="docutils literal"><span class="pre">decay_jump</span></code>.</p>
</div>
<div class="section" id="exercise-2-6-implement-a-scaled-model-for-cooling">
<span id="sec-scale-exer-decay-cooling"></span><h3>Exercise 2.6: Implement a scaled model for cooling<a class="headerlink" href="#exercise-2-6-implement-a-scaled-model-for-cooling" title="Permalink to this headline">¶</a></h3>
<p>Use software for the unscaled problem <a class="reference internal" href="#eq-scale-cooling-model"><span class="std std-ref">(17)</span></a>
to compute the solution of the
scaled problem <a class="reference internal" href="#eq-scale-cooling-model-scaled"><span class="std std-ref">(24)</span></a>.
Let <span class="math">\(T_s\)</span> be a function of time.</p>
<p><strong>Hint.</strong>
You may use the general software <a class="reference external" href="http://tinyurl.com/o8pb3yy/decay_vc.py">decay_vc.py</a>
for computing with the cooling model.
See the section <a class="reference internal" href="#sec-scale-body"><span class="std std-ref">Scaling a generalized problem</span></a> for more ideas.</p>
<p>Filename: <code class="docutils literal"><span class="pre">cooling1</span></code>.</p>
</div>
<div class="section" id="problem-2-7-decay-ode-with-discontinuous-coefficients">
<span id="scale-exer-decay-step"></span><h3>Problem 2.7: Decay ODE with discontinuous coefficients<a class="headerlink" href="#problem-2-7-decay-ode-with-discontinuous-coefficients" title="Permalink to this headline">¶</a></h3>
<p>The goal of this exercise is to scale the problem
<span class="math">\(u^{\prime}(t) = -a(t)u(t) + b(t)\)</span>, <span class="math">\(u(0)=I\)</span>, when</p>
<div class="math">
\[\begin{split}a(t) =\left\lbrace\begin{array}{ll}
Q, &amp; t &lt; s,\\
Q - A, &amp; t\geq s,\end{array}\right.
\quad b = \left\lbrace\begin{array}{ll}
\epsilon t, &amp; t &lt; s,\\
0, &amp; t\geq s,\end{array}\right.\end{split}\]</div>
<p>Here, <span class="math">\(Q,A,\epsilon &gt;0\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">decay_varcoeff</span></code>.</p>
</div>
<div class="section" id="exercise-2-8-alternative-scalings-of-a-cooling-model">
<span id="scale-exer-nonlin-logistic2"></span><h3>Exercise 2.8: Alternative scalings of a cooling model<a class="headerlink" href="#exercise-2-8-alternative-scalings-of-a-cooling-model" title="Permalink to this headline">¶</a></h3>
<p>Implement the scaled model <a class="reference internal" href="#eq-sec-scale-nonlinear-model1-scaled"><span class="std std-ref">(30)</span></a>
and produce a plot with curves corresponding to various values of
<span class="math">\(\alpha\)</span> and <span class="math">\(p\)</span> to summarize how <span class="math">\(\bar u(\bar t)\)</span> looks like.</p>
<p><strong>Hint.</strong>
A centered Crank-Nicolson-style
scheme for <a class="reference internal" href="#eq-sec-scale-nonlinear-model1-scaled"><span class="std std-ref">(30)</span></a>
can use an old time value for the nonlinear coefficient:</p>
<div class="math">
\[\frac{\bar u^{n+1} - \bar u^n}{\Delta t} =
(1 - \alpha\bar u^n)^p\frac{1}{2}(\bar u^n + \bar u^{n+1}){\thinspace .}\]</div>
<p>Filename: <code class="docutils literal"><span class="pre">growth</span></code>.</p>
</div>
<div class="section" id="exercise-2-9-projectile-motion">
<span id="scale-vib-exer-projectile"></span><h3>Exercise 2.9: Projectile motion<a class="headerlink" href="#exercise-2-9-projectile-motion" title="Permalink to this headline">¶</a></h3>
<p>We have the following mathematical model for the motion of a projectile
in two dimensions:</p>
<div class="math">
\[m\ddot\boldsymbol{x} + \frac{1}{2}C_D\varrho A|\dot\boldsymbol{x}|\dot\boldsymbol{x}
= -mg\boldsymbol{j},\quad \boldsymbol{x}(0)=\boldsymbol{0},\ \dot\boldsymbol{x}(0)=v_0\cos\theta\boldsymbol{i} +
v_0\sin\theta\boldsymbol{j}{\thinspace .}\]</div>
<p>Here, <span class="math">\(m\)</span> is the mass of the projectile, <span class="math">\(\boldsymbol{x}=x\boldsymbol{i} + y\boldsymbol{j}\)</span> is
the position vector of the projectile, <span class="math">\(\boldsymbol{i}\)</span> and <span class="math">\(\boldsymbol{j}\)</span>
are unit vectors along the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> axes, respectively,
<span class="math">\(\ddot\boldsymbol{x}\)</span> and <span class="math">\(\dot\boldsymbol{x}\)</span> is the second- and first-order
time derivative of <span class="math">\(\boldsymbol{x}(t)\)</span>, <span class="math">\(C_D\)</span> is a drag coefficient
depending on the shape of the projectile (can be taken as 0.4 for a sphere),
<span class="math">\(\varrho\)</span> is the density of the air, <span class="math">\(A\)</span> is the cross section area
(can be taken as <span class="math">\(\pi R^2\)</span> for a sphere of radius <span class="math">\(R\)</span>), <span class="math">\(g\)</span> is gravity,
<span class="math">\(v_0\)</span> is the initial velocity of the projectile in a direction that makes
the angle <span class="math">\(\theta\)</span> with the ground.</p>
<p><strong>a)</strong>
Neglect the air resistance term proportional to <span class="math">\(\dot\boldsymbol{x}\)</span> and solve
analytically for <span class="math">\(\boldsymbol{x}(t)\)</span>.</p>
<p><strong>b)</strong>
Make the model for projectile motion with air resistance non-dimensional.
Use the maximum height from the simplification in a) as length scale.</p>
<p><strong>c)</strong>
Make the model dimensionless again, but this time by demanding that
the scaled initial velocity is unity in <span class="math">\(x\)</span> direction.</p>
<p><strong>d)</strong>
A soccer ball has radius 11 cm and mass 0.43 kg, the density of air
is 1.2 <span class="math">\(\hbox{kg}\hbox{m}^{-3}\)</span>, a soft kick has velocity 30 km/h,
while a hard kick may have 120 km/h. Estimate the dimensionless parameter
in the scaled problem for a soft and a hard kick with
<span class="math">\(\theta\)</span> corresponding to 45 degrees. Solve the scaled
differential equation for these values and plot the trajectory (<span class="math">\(y\)</span> versus
<span class="math">\(x\)</span>) for the two cases.</p>
<p>Filename: <code class="docutils literal"><span class="pre">projectile</span></code>.</p>
</div>
<div class="section" id="problem-2-10-a-predator-prey-model">
<span id="scale-exer-predprey"></span><h3>Problem 2.10: A predator-prey model<a class="headerlink" href="#problem-2-10-a-predator-prey-model" title="Permalink to this headline">¶</a></h3>
<p id="index-23">The evolution of animal populations with a predator and a prey (e.g.,
lynx and hares, or foxes and rabbits) can be described by the
Lotka-Volterra ODE system</p>
<div class="math" id="eq-scale-exer-predprey-eqh">
\[\tag{94}
H^{\prime} = H(a - bL),\]</div>
<div class="math" id="eq-scale-exer-predprey-eql">
\[\tag{95}
L^{\prime} = L(dH - c),\]</div>
<div class="math" id="eq-auto27">
\[\tag{96}
H(0)=H_0,\]</div>
<div class="math" id="eq-auto28">
\[\tag{97}
L(0)=L_0{\thinspace .}\]</div>
<p>Here, <span class="math">\(H\)</span> is the number of animals of the prey (say hares)
and <span class="math">\(L\)</span> is the corresponding measure of the predator population (say lynx).
There are six parameters: <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, <span class="math">\(c\)</span>, <span class="math">\(d\)</span>, <span class="math">\(H_0\)</span>, and <span class="math">\(L_0\)</span>.</p>
<p>The terms have the following meanings:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(aH\)</span> is the exponential
population growth of <span class="math">\(H\)</span> due to births and deaths and is governed by
the access to nutrition,</li>
<li><span class="math">\(-bHL\)</span> is the loss of preys because they are eaten by predators,</li>
<li><span class="math">\(dHL\)</span> is the increase of predators because they eat preys (but only
a fraction of the eaten preys, <span class="math">\(bHL\)</span>, contribute to population growth
of the predator and therefore <span class="math">\(d &lt; b\)</span>),</li>
<li><span class="math">\(-cL\)</span> is the exponential decay in the predator population because of
deaths (the increase is modeled by <span class="math">\(dHL\)</span>).</li>
</ul>
</div></blockquote>
<p>Dimensionless independent and dependent variables are introduced as usual
by</p>
<div class="math">
\[\bar t = \frac{t}{t_c},\quad
\bar H = \frac{H}{H_c},\quad \bar L = \frac{L}{L_c},\]</div>
<p>where <span class="math">\(t_c\)</span>, <span class="math">\(H_c\)</span>, and <span class="math">\(L_c\)</span> are scales to be determined. Inserted
in the ODE problem we arrive at</p>
<div class="math" id="eq-scale-exer-predprey-eqh-s">
\[\tag{98}
\frac{H_0}{t_c}\frac{d\bar H}{d\bar t} = H_0\bar H(a - bH_0\bar L),\]</div>
<div class="math" id="eq-scale-exer-predprey-eql-s">
\[\tag{99}
\frac{H_0}{t_c}\frac{d\bar L}{d\bar t} = H_0\bar L(dH_0\bar H - c),\]</div>
<div class="math" id="eq-scale-exer-predprey-eqh0-s">
\[\tag{100}
H_c\bar H(0) = H_0,\]</div>
<div class="math" id="eq-scale-exer-predprey-eql0-s">
\[\tag{101}
L_c\bar H(0) = L_0{\thinspace .}\]</div>
<p><strong>a)</strong>
Consider first a simple, intuitive scaling of <span class="math">\(H\)</span> and <span class="math">\(L\)</span> based on
initial conditions <span class="math">\(H_c=H_0\)</span>
and <span class="math">\(L_c=H_c\)</span>. This means that <span class="math">\(\bar H\)</span> starts out at unity and <span class="math">\(\bar L\)</span>
starts out as the fraction <span class="math">\(L_0/H_0\)</span>. Find a time scale and identify
dimensionless parameters in the scaled ODE problem.</p>
<p><strong>b)</strong>
Try a different scaling where the aim is to adjust the scales such that
the ODEs become as simple as possible, i.e, have as few dimensionless
parameters as possible. Compare with the scaling in a).</p>
<p><strong>c)</strong>
A more mathematical approach to determining suitable scales for <span class="math">\(H\)</span> and <span class="math">\(L\)</span>
consists in finding the stationary points <span class="math">\((H,L)\)</span> of the ODE system,
where <span class="math">\(H^{\prime}=L^{\prime}=0\)</span>, and use such points as characteristic
sizes of the dependent variables. Show that <span class="math">\(H^{\prime}=L^{\prime}=0\)</span>
implies <span class="math">\(H=L=0\)</span> or <span class="math">\(L=a/b\)</span> and <span class="math">\(H=c/d\)</span>. Use <span class="math">\(H_c=a/b\)</span>, <span class="math">\(L_c=c/d\)</span>,
and find a time scale. Compare with the result in b).</p>
<p>Filename: <code class="docutils literal"><span class="pre">predator_prey</span></code>.</p>
</div>
<div class="section" id="problem-2-11-a-model-for-competing-species">
<span id="scale-exer-competing-species"></span><h3>Problem 2.11: A model for competing species<a class="headerlink" href="#problem-2-11-a-model-for-competing-species" title="Permalink to this headline">¶</a></h3>
<p id="index-24">Let <span class="math">\(N_1(t)\)</span> and <span class="math">\(N_2(t)\)</span> be the number of animals in two
competing species. A generalized Lotka-Volterra model
is based on a logistic growth of each specie and a predator-prey like
interaction (cf. <a class="reference internal" href="#scale-exer-predprey"><span class="std std-ref">Problem 2.10: A predator-prey model</span></a>):</p>
<div class="math" id="eq-auto33">
\[\tag{102}
\frac{dN_1}{dt} = r_1N_1\left( 1 - \frac{N_1}{M_1} - s_{12}\frac{N_2}{M_1}\right),\]</div>
<div class="math" id="eq-auto34">
\[\tag{103}
\frac{dN_2}{dt} = r_2N_2\left( 1 - \frac{N_2}{M_2} - s_{21}\frac{N_1}{M_2}\right),\]</div>
<p>where <span class="math">\(r_1\)</span>, <span class="math">\(r_2\)</span>, <span class="math">\(M_1\)</span>, <span class="math">\(M_2\)</span>, <span class="math">\(s_{12}\)</span>, and <span class="math">\(s_{21}\)</span> are given constants.
The initial conditions specify <span class="math">\(N_1\)</span> and <span class="math">\(N_2\)</span> at <span class="math">\(t=0\)</span>.
Find suitable scales and derive a dimensionless ODE problem.</p>
<p>Filename: <code class="docutils literal"><span class="pre">competing_species</span></code>.</p>
</div>
<div class="section" id="problem-2-12-find-the-period-of-sinusoidal-signals">
<span id="scale-exer-sine"></span><h3>Problem 2.12: Find the period of sinusoidal signals<a class="headerlink" href="#problem-2-12-find-the-period-of-sinusoidal-signals" title="Permalink to this headline">¶</a></h3>
<p>This exercise aims at investigating various fundamental
concepts like period, wave length,
and frequency in non-damped and damped sinusoidal signals.</p>
<p><strong>a)</strong>
Plot the function</p>
<div class="math">
\[u(t) = A\sin(\omega t),\]</div>
<p>for <span class="math">\(t\in [0, 8\pi/\omega]\)</span>. Choose <span class="math">\(\omega\)</span> and <span class="math">\(A\)</span>.</p>
<p><strong>b)</strong>
The <em>period</em> <span class="math">\(P\)</span> of <span class="math">\(u\)</span> is the shortest distance between two peaks (where
<span class="math">\(u=A\)</span>). Show mathematically that</p>
<div class="math">
\[P = \frac{2\pi}{\omega}{\thinspace .}\]</div>
<p>Frequently, <span class="math">\(P\)</span> is also referred to as the <em>wave length</em> of <span class="math">\(u\)</span>.</p>
<p><strong>c)</strong>
Plot the damped signal <span class="math">\(u(t)=e^{-at}\sin (\omega t)\)</span> over four periods
of <span class="math">\(sin(\omega t)\)</span>. Choose <span class="math">\(\omega\)</span>, <span class="math">\(A\)</span>, and <span class="math">\(a\)</span>.</p>
<p><strong>d)</strong>
What is the period of <span class="math">\(u(t)=e^{-at}\sin (\omega t)\)</span>? We define the
period <span class="math">\(P\)</span> as the shortest distance between two peaks of the signal.</p>
<p><strong>Hint.</strong>
Use that <span class="math">\(v = p\cos(\omega t) + q\sin (\omega t)\)</span> can be rewritten
as <span class="math">\(v = B\cos(\omega t - \phi)\)</span> with <span class="math">\(B=\sqrt{p^2 + q^2}\)</span> and
<span class="math">\(\phi = \tan^{-1}(p/q)\)</span>. Use such a rewrite of <span class="math">\(u'\)</span> to find the peaks of
<span class="math">\(u\)</span> and then the period.</p>
<p>Filename: <code class="docutils literal"><span class="pre">sine_period</span></code>.</p>
<div class="section" id="remarks-1">
<h4>Remarks<a class="headerlink" href="#remarks-1" title="Permalink to this headline">¶</a></h4>
<p>The <em>frequency</em> is the number of up and down cycles in one unit time.
Since there is one cycle in a period <span class="math">\(P\)</span>, the frequency is <span class="math">\(f =1/P\)</span>,
measured in Hz.
The <em>angular frequency</em> <span class="math">\(\omega\)</span> is then <span class="math">\(\omega = 2\pi/P = 2\pi f\)</span>.</p>
</div>
</div>
<div class="section" id="problem-2-13-oscillating-mass-with-sliding-friction">
<span id="scale-vib-exer-sliding"></span><h3>Problem 2.13: Oscillating mass with sliding friction<a class="headerlink" href="#problem-2-13-oscillating-mass-with-sliding-friction" title="Permalink to this headline">¶</a></h3>
<div class="figure" id="id17">
<span id="scale-vib-exer-sliding-fig"></span><a class="reference internal image-reference" href="_images/oscillator_sliding.png"><img alt="_images/oscillator_sliding.png" src="_images/oscillator_sliding.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Body sliding on a surface</em></span></p>
</div>
<p>A mass attached to a spring is sliding on a surface and subject to
a friction force, see Figure <a class="reference internal" href="#scale-vib-exer-sliding-fig"><span class="std std-ref">Body sliding on a surface</span></a>.
The spring represents a force <span class="math">\(-ku\boldsymbol{i}\)</span>, where <span class="math">\(k\)</span> is the spring stiffness.
The friction force is proportional to the normal force on the surface,
<span class="math">\(-mg\boldsymbol{j}\)</span>, and given by <span class="math">\(-f(\dot u)\boldsymbol{i}\)</span>, where</p>
<div class="math">
\[\begin{split}f(\dot u) = \left\lbrace\begin{array}{ll}
-\mu mg,&amp; \dot u &lt; 0,\\
\mu mg, &amp; \dot u &gt; 0,\\
0,      &amp; \dot u=0
\end{array}\right.\end{split}\]</div>
<p>Here, <span class="math">\(\mu \geq 0\)</span> is a friction coefficient. With the signum function</p>
<div class="math">
\[\begin{split}\mbox{sign(x)} = \left\lbrace\begin{array}{ll}
-1,&amp; x &lt; 0,\\
1, &amp; x &gt; 0,\\
0, &amp; x=0
\end{array}\right.\end{split}\]</div>
<p>we can simply write <span class="math">\(f(\dot u) = \mu mg\,\hbox{sign}(\dot u)\)</span>
(the sign function is implemented by <code class="docutils literal"><span class="pre">numpy.sign</span></code>).</p>
<p>The ODE problem for this one-dimensional oscillatory motion reads</p>
<div class="math" id="eq-auto35">
\[\tag{104}
m\ddot u + \mu mg\,\hbox{sign}(\dot u) + ku = 0,\quad u(0)=I,\ \dot u(0)=V{\thinspace .}\]</div>
<p><strong>a)</strong>
Scale the problem.</p>
<p><strong>b)</strong>
Implement the scaled model. Simulate for <span class="math">\(\alpha = 0, 0.05, 0.1\)</span>
and <span class="math">\(\beta =0\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">sliding_box</span></code>.</p>
</div>
<div class="section" id="problem-2-14-pendulum-equations">
<span id="sec-scale-exer-pendulum"></span><h3>Problem 2.14: Pendulum equations<a class="headerlink" href="#problem-2-14-pendulum-equations" title="Permalink to this headline">¶</a></h3>
<p>The equation for a so-called simple pendulum with a mass <span class="math">\(m\)</span> at the end is</p>
<div class="math" id="eq-auto36">
\[\tag{105}
mL\ddot\theta + mg\sin\theta = 0,\]</div>
<p>where <span class="math">\(\theta(t)\)</span> is the angle with the vertical, <span class="math">\(L\)</span> is the length of
the pendulum, and <span class="math">\(g\)</span> is the acceleration of gravity.</p>
<p>A physical pendulum with moment of inertia <span class="math">\(I\)</span> is governed by
a similar equation,</p>
<div class="math" id="eq-auto37">
\[\tag{106}
I\ddot\theta + mgL\sin\theta = 0{\thinspace .}\]</div>
<p>Both equations have the initial conditions <span class="math">\(\theta(0)=\Theta\)</span> and
<span class="math">\(\theta'(0)=0\)</span> (start at rest).</p>
<p><strong>a)</strong>
Use <span class="math">\(\theta\)</span> as dimensionless unknown, find a proper time scale,
and scale both differential equations.</p>
<p><strong>b)</strong>
Some may argue that <span class="math">\(\theta\)</span> is not dimensionless since it is measured
in radians. One may introduce a truly dimensionless angle <span class="math">\(\bar\theta
\in [0,1]\)</span>. Set up the scaled ODE problem in this case.</p>
<p><strong>c)</strong>
Simulate the problem in b) for <span class="math">\(\Theta = 1,20,45,60\)</span> measured in degrees.</p>
<p>Filename: <code class="docutils literal"><span class="pre">pendulum</span></code>.</p>
</div>
<div class="section" id="exercise-2-15-odes-for-a-binary-star">
<span id="sec-scale-exer-binary-star"></span><h3>Exercise 2.15: ODEs for a binary star<a class="headerlink" href="#exercise-2-15-odes-for-a-binary-star" title="Permalink to this headline">¶</a></h3>
<p>The equations for a <a class="reference external" href="https://en.wikipedia.org/wiki/Binary_star">binary star</a>,
or a planet and a moon, are</p>
<div class="math" id="eq-auto38">
\[\tag{107}
m_A\ddot\boldsymbol{x}_A = \boldsymbol{F},\]</div>
<div class="math" id="eq-auto39">
\[\tag{108}
m_B\ddot\boldsymbol{x}_B = -\boldsymbol{F},\]</div>
<p>where <span class="math">\(\boldsymbol{x}_A\)</span> is the position of object (star) A, and <span class="math">\(\boldsymbol{x}_B\)</span> is the position
object B. The corresponding masses are <span class="math">\(m_A\)</span> and <span class="math">\(m_B\)</span>.
The only force is the gravity force</p>
<div class="math">
\[\boldsymbol{F} = \frac{Gm_Am_B}{||\boldsymbol{r}||^3}\boldsymbol{r},\]</div>
<p>where</p>
<div class="math">
\[\boldsymbol{r}(t) = \boldsymbol{x}_B(t) - \boldsymbol{x}_A(t),\]</div>
<p>and <span class="math">\(G\)</span> is the gravitational constant: <span class="math">\(G=6.674\cdot 10^{-11}\hbox{ Nm}^2/\hbox{kg}^2\)</span>. A problem with these equations is that the parameters are very large
(<span class="math">\(m_A\)</span>, <span class="math">\(m_B\)</span>, <span class="math">\(||\boldsymbol{r}||\)</span>) or very small (<span class="math">\(G\)</span>). The rotation time
for binary stars can be very small and large as well.</p>
<p><strong>a)</strong>
Scale the equations.</p>
<p><strong>b)</strong>
Solve the scaled equations numerically for two cases:</p>
<ol class="arabic simple">
<li>a planet around a star:
<span class="math">\(\alpha = 10^{-3}\)</span>, <span class="math">\(\boldsymbol{x}_A(0)=(1,0)\)</span>, <span class="math">\(\dot\boldsymbol{x}_A(0)=(0,1)\)</span>,
<span class="math">\(\boldsymbol{x}_B(0)=0\)</span>, <span class="math">\(\dot\boldsymbol{x}_B(0)=0\)</span></li>
<li>two stars:
<span class="math">\(\alpha = \frac{1}{2}\)</span>, <span class="math">\(\boldsymbol{x}_A(0)=(1,0)\)</span>, <span class="math">\(\dot\boldsymbol{x}_A(0)=(0,\frac{1}{2})\)</span>,
<span class="math">\(\boldsymbol{x}_B(0)=0\)</span>, <span class="math">\(\dot\boldsymbol{x}_B(0)=(0,-\frac{1}{2})\)</span></li>
</ol>
<p>An assumption here is that the orbits are co-planar such that they can
be taken to lie in the <span class="math">\(xy\)</span> plane.</p>
<p>Here is a movie of two rotating stars (point 2 above):</p>
<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov-scaling/binary_star/movie.mp4"  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src="_static/mov-scaling/binary_star/movie.webm" type='video/webm; codecs="vp8, vorbis"'>
    <source src="_static/mov-scaling/binary_star/movie.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script><p>Filename: <code class="docutils literal"><span class="pre">binary_star</span></code>.</p>
</div>
<div class="section" id="problem-2-16-duffing-s-equation">
<span id="scale-vib-exer-duffing"></span><h3>Problem 2.16: Duffing&#8217;s equation<a class="headerlink" href="#problem-2-16-duffing-s-equation" title="Permalink to this headline">¶</a></h3>
<p>Duffing&#8217;s equation is a vibration equation with linear and cubic
spring terms:</p>
<div class="math">
\[mu'' + k_0u + k_1u^3 = 0,\quad u(0)=U_0,\ u'(0)=0{\thinspace .}\]</div>
<p>Scale this problem.</p>
<p>Filename: <code class="docutils literal"><span class="pre">Duffing_eq</span></code>.</p>
</div>
<div class="section" id="problem-2-17-vertical-motion-in-a-varying-gravity-field">
<span id="scale-vib-exer-rocket"></span><h3>Problem 2.17: Vertical motion in a varying gravity field<a class="headerlink" href="#problem-2-17-vertical-motion-in-a-varying-gravity-field" title="Permalink to this headline">¶</a></h3>
<p>A body (e.g., projectile or rocket) is launched vertically
from the surface of the earth with
velocity <span class="math">\(V\)</span>. The body&#8217;s distance (height) from the earth&#8217;s surface
at time <span class="math">\(t\)</span> is represented by the function <span class="math">\(h(t)\)</span>.
Unless <span class="math">\(h\)</span> is very much smaller than the earth&#8217;s radius <span class="math">\(R\)</span>, the motion
takes place in a varying gravity field. The governing ODE problem for
<span class="math">\(h(t)\)</span> is then</p>
<div class="math" id="eq-auto42">
\[\tag{109}
h''(t) = -\frac{R^2g}{(h+R)^2},\quad h(0)=0,\ h'(0)=V,\quad t\in (0,T],\]</div>
<p>where <span class="math">\(g\)</span> is the acceleration of gravity at the earth&#8217;s surface.</p>
<p>The goal is to discuss three scalings of this problem. First we introduce</p>
<div class="math">
\[\bar h = \frac{h}{h_c},\quad \bar t = \frac{t}{t_c},\]</div>
<p>which gives the dimensionless ODE</p>
<div class="math">
\[\frac{d^2\bar h}{d\bar t^2} = -\frac{t_c^2}{h_c}\frac{R^2g}{(h_c\bar h+R)^2}
= -\frac{t_c^2}{h_c^3}\frac{R^2g}{\left(\bar h+ R/h_c\right)^2}\]</div>
<p>and the dimensionless initial condition</p>
<div class="math">
\[\frac{d\bar h}{d\bar t}(0) = \frac{t_cV}{h_c}{\thinspace .}\]</div>
<p>The key dimensionless variable in this problem turns out to be</p>
<div class="math">
\[\epsilon = \frac{V}{\sqrt{Rg}}{\thinspace .}\]</div>
<p><strong>a)</strong>
Assume we study the motion over long distances such that
<span class="math">\(h\)</span> may be of the same size as <span class="math">\(R\)</span>. In this case, <span class="math">\(h_c=R\)</span> is a
reasonable choice. Determine <span class="math">\(t_c\)</span> from requiring the initial velocity
to be unity. Set up the dimensionless ODE problem.</p>
<p><strong>b)</strong>
As a), but determine <span class="math">\(t_c\)</span> by demanding both terms in the scaled ODE to
have unit coefficients.</p>
<p><strong>c)</strong>
For small initial velocity <span class="math">\(V\)</span>, <span class="math">\(h\)</span> will be small compared to <span class="math">\(R\)</span>.
In the limit <span class="math">\(h/R\rightarrow 0\)</span>,
the governing equation simplifies to the well-known motion in a
constant gravity field: <span class="math">\(h''=-g\)</span>. Use this model to suggest a time and
length scale, and derive a dimensionless ODE problem.</p>
<p><strong>d)</strong>
Give an interpretation of the dimensionless parameter <span class="math">\(\epsilon\)</span>.</p>
<p><strong>e)</strong>
Solve numerically for <span class="math">\(\bar h(\bar t)\)</span> in each of the three scalings in
a), b), and c), with <span class="math">\(\epsilon^2 =0.01, 0.1, 0.5, 1, 2\)</span>.
When are the various scalings appropriate? (That is, when are <span class="math">\(\bar t\)</span>
and <span class="math">\(\bar h\)</span> of size unity or at least not very small or big?)</p>
<p>Filename: <code class="docutils literal"><span class="pre">varying_gravity</span></code>.</p>
</div>
<div class="section" id="problem-2-18-a-simplified-schroedinger-equation">
<span id="scale-vib-exer-quantum"></span><h3>Problem 2.18: A simplified Schroedinger equation<a class="headerlink" href="#problem-2-18-a-simplified-schroedinger-equation" title="Permalink to this headline">¶</a></h3>
<p>A simplified stationary
Schroedinger&#8217;s equation for one electron, assuming radial symmetry, takes
the form</p>
<div class="math" id="eq-scale-vib-exer-quantum-req">
\[\tag{110}
-\frac{\hbar^2}{2m}
    \frac{1}{r^2}\frac{d}{dr}\left(r^2\frac{d}{dr}\right) R
    + V(r)R = ER,\]</div>
<p>where <span class="math">\(r\)</span> is the radial coordinate, <span class="math">\(R\)</span> is the wave function,
<span class="math">\(\hbar\)</span> is Planck&#8217;s constant, <span class="math">\(m\)</span> is the mass of the electron,
<span class="math">\(V=\)</span> is the force potential, which is here taken as the
Coulomb potential <span class="math">\(V(r) = {e^2}/(8\pi\epsilon_0 r)\)</span>
(where <span class="math">\(e\)</span> is the charge of the electron and <span class="math">\(\epsilon_0\)</span> is the
permittivity of free space), and <span class="math">\(E\)</span> is
the eigenvalue, for the energy, to be determined along with <span class="math">\(R(r)\)</span>.</p>
<p>Show that the scaled version of <a class="reference internal" href="#eq-scale-vib-exer-quantum-req"><span class="std std-ref">(110)</span></a> can be written</p>
<div class="math" id="eq-scale-vib-exer-quantum-barreq">
\[\tag{111}
- \left(\frac{1}{\bar r^2}\frac{d}{d\bar r}\bar r^2
    \frac{d}{d\bar r}\right)
    \bar R + \frac{1}{\bar r}\bar R = \lambda\bar R,\]</div>
<p>where <span class="math">\(\lambda\)</span> is a dimensionless eigenvalue</p>
<div class="math">
\[\lambda = \frac{(4\pi)^2\epsilon_0^2\hbar^2E}{me^4}{\thinspace .}\]</div>
<p>The symbol <span class="math">\(\bar r\)</span> is the scaled coordinate, and <span class="math">\(\bar R\)</span> is a scaled
version of <span class="math">\(R\)</span> (the scaling factor drops out of the equation).
The length scale, which arises naturally, is the
<a class="reference external" href="https://en.wikipedia.org/wiki/Bohr_radius">Bohr radius</a>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">Schroedinger</span></code>.</p>
<div class="section" id="remarks-2">
<h4>Remarks<a class="headerlink" href="#remarks-2" title="Permalink to this headline">¶</a></h4>
<p>Introducing <span class="math">\(u=\bar r\bar R\)</span> and renaming <span class="math">\(\bar r\)</span> to <span class="math">\(x\)</span>,
<a class="reference internal" href="#eq-scale-vib-exer-quantum-barreq"><span class="std std-ref">(111)</span></a> can be recast in the simpler form</p>
<div class="math">
\[-u''(x) + \frac{1}{x}u(x) = \lambda u(x),\]</div>
<p>which is a simpler eigenvalue problem to solve numerically (the boundary
conditions are <span class="math">\(u(0)=0\)</span> and <span class="math">\(\lim_{x\rightarrow\infty}u(x)=0\)</span>).</p>
</div>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book004.html" title="Basic partial differential equation models"
             >next</a> |</li>
        <li class="right" >
          <a href="._book002.html" title="Dimensions and units"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Scaling of Differential Equations</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Hans Petter Langtangen, Geir K. Pedersen. Released under CC Attribution 4.0 license.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
  </body>
</html>